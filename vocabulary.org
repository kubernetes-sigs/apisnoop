#+TITLE: APISnoop Vocabulary

* Purpose of this Document
  To define the terms we use in our site and code, and the methods we use to assign values to these words.
  Through this process, we can increase clarity in our code, avoid redundancy, and build understanding between ourselves and the larger k8s community.

  Each heading within is a area of our codebase/domain, and the terms used within it.
* Current APISnoop Definitions
Definitions for terms used in the
- backend api
- frontend codebase
- processed logs
- web interface

  In some cases, each area might use the same word but mean subtly different things. The endpoints available to the frontend, through the backend api, are different than the endpoints in the processed logs, for example.  In these cases, we want the difference to be specific and necessary, instead of accidental. These definitions describe _where_ we get the data and what it looks like, rather than what the data means, to achieve this goal.
** sunburst :: main circular graphic
This is a specific name from d3.
     Our  first inspiration: [[Kerry Roden's bl.ocks.org post]]
     Code we use for viz now: [[https://uber.github.io/react-vis/documentation/other-charts/sunburst-diagram][react-vis/sunburst]]
*** Nested Endpoints built with [[file:data-gen/processAuditlog.py::def%20generate_sunburst_tree(openapi_spec):][generate_sunburst_tree()]] :processedLogs:
    #+NAME: def generate_sunburst_tree
    #+BEGIN_SRC python
      def generate_sunburst_tree(openapi_spec):
          # Base sunburst structure, without audit / test loaded

          sunburst = {}

          for endpoint in openapi_spec['paths'].values():

              level = endpoint.get('level')
              if level not in sunburst.keys():
                  sunburst[level] = {
                  }

              for method_name in endpoint['methods'].keys():
                  method = endpoint['methods'][method_name]
                  op = method['operationId']
                  category = method['category']
                  path = endpoint['path']
                  op_method = "%s/%s" % (op, method_name)

                  if category not in sunburst[level].keys():
                      sunburst[level][category] = {
                      }

                  if op_method not in sunburst[level][category].keys():
                      sunburst[level][category][op_method] = {
                      }

          root = {
              "name": "root",
              "children": []
          }
          for level in ['stable', 'beta', 'alpha']:
              categories = sunburst[level]
              category_children = []
              for category, op_methods in categories.items():
                  op_method_children = []
                  for op_method, method_info in op_methods.items():
                      method_info["name"] = op_method
                      method_info["color"] = "green"
                      method_info["size"] = "1"
                      # method_info["color"] = "green"
                      op_method_children.append(method_info)
                  category_children.append(
                      {"name": category,
                       "children": op_method_children})
              root['children'].append(
                  {"name": level,
                   "children": category_children})
          return root

    #+END_SRC

    This is being done again in our frontend, and so is now redundant and can be removed
*** Nested Endpoints built with sunburst bundle                    :frontend:


** node :: individual piece of the sunburst
 specif d3 convention. In APISnoop, nodes generally maps to endpoint+operation.  Is used in code for mouseOver and mouseClick in sunburst Component
** level :: # parse_level_from_path(path)
   Given /v${API_VERSION}${API_LEVEL}${API_LEVEL_VERSION}
   /v1alpha2
   API_VERSION=1
   API_LEVEL=alpha
   API_LEVEL_VERSION=2
   [[file:apisnoop/data-gen/lib/parsers.py::def%20parse_level_from_path(path):][data-gen/lib/parsers.py::parse_level_from_path()]]
   #+NAME: level being one of alpha/beta/stable
   #+BEGIN_SRC python
   LEVEL_PATTERN = re.compile("/v(?P<api_version>[0-9]+)(?:(?P<api_level>alpha|beta)(?P<api_level_version>[0-9]+))?")
   def parse_level_from_path(path):
       # get the level (alpha/beta/stable) and the version from the path
       level = None
       match = LEVEL_PATTERN.search(path)
       if match:
           level = match.groupdict().get("api_level")
       if level is None:
           level = "stable"
       return level
   #+END_SRC
** event :: audit log entry.  refers to an audit log event.
** audit log event:: find out!
** category :: comes from openAPI spec.
** counter :: refers to a tally of some sort, but has several counters and all contextual
   in processAuditlog.py, search for anywhere we do `+=1`
   So counter will be  gathered from where within the endpoint data it is mentioned, and how it maps to the specific lines of code in processAuditlog.py

*** TODO Make counters more explicitly named?

** useragent.endpoints.$endpoint.counter ::
** verb :: HTTP layer of the method
** Operation :: OpenAPISpec naming for an endpoint (sans method)
** method :: operation
   #+NAME: Method within Swagger.json
   #+BEGIN_SRC yaml
       "/api/v1/namespaces/{namespace}/configmaps/{name}": {
         "delete": { # METHOD
           "consumes": [
             "*/*"
           ],
           "description": "delete a ConfigMap",
           "operationId": "deleteCoreV1NamespacedConfigMap",
   #+END_SRC
** endpoints
*** code gathered through generate_endpoints_tree()           :processedLogs:
  [[file:~/apisnoop/data-gen/processAuditlog.py::def%20generate_endpoints_tree(openapi_spec):][data-gen/processAuditlog.py::generate_endpoints_tree()]]
  #+NAME: generate_endpoints_tree
  #+BEGIN_SRC python
    def generate_endpoints_tree(openapi_spec):
        # Base tests structure, without audit / test loaded
        endpoints = {}
        for endpoint in openapi_spec['paths'].values():
            for (method_name, method) in endpoint['methods'].items():
                method = endpoint['methods'][method_name]
                deprecated = re.match("[Dd]eprecated", method["description"])
                if deprecated:
                    # import ipdb; ipdb.set_trace(context=60)
                    continue

                op = method['operationId']
                if op not in endpoints.keys():
                    endpoints[op] = {}

                endpoints[op][method_name] = {
                    "cat": method["category"],
                    "desc": method["description"],
                    "group": method["group"],
                    "kind": method["kind"],
                    "ver": method["version"],
                    "path": endpoint['path'],
                    "level": endpoint['level'],
                    # "deprecated": deprecated,
                    "counter": 0,
                    "agents": [],
                    "test_tags": [],
                    "tests": []
                }
        return endpoints
  #+END_SRC

  We are basing our endpoints around the openAPI Spec for 'paths', and so some of our descriptors come from there.

  #+NAME: sample of processedLogs ['endpoints]'
  #+BEGIN_SRC yaml
  {
    "createStorageV1alpha1VolumeAttachment": {
      "post": {
        "tests": [],
        "agents": [],
        "path": "/apis/storage.k8s.io/v1alpha1/volumeattachments",
        "desc": "create a VolumeAttachment",
        "kind": "VolumeAttachment",
        "group": "storage.k8s.io",
        "level": "alpha",
        "counter": 0,
        "test_tags": [],
        "cat": "storage",
        "ver": "v1alpha1"
      }
    },
    "listApiextensionsV1beta1CustomResourceDefinition": {
      "watch": {
        "tests": [],
        "agents": [
          "kube-apiserver/v1.15.0",
          "kube-controller-manager/v1.15.0"
        ],
        "path": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions",
        "desc": "list or watch objects of kind CustomResourceDefinition",
        "kind": "CustomResourceDefinition",
        "group": "apiextensions.k8s.io",
        "level": "beta",
        "counter": 14,
        "test_tags": [],
        "cat": "apiextensions",
        "ver": "v1beta1"
      },
      "get": {
        "tests": [],
        "agents": [
          "kube-apiserver/v1.15.0",
          "kube-controller-manager/v1.15.0"
        ],
        "path": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions",
        "desc": "list or watch objects of kind CustomResourceDefinition",
        "kind": "CustomResourceDefinition",
        "group": "apiextensions.k8s.io",
        "level": "beta",
        "counter": 2,
        "test_tags": [],
        "cat": "apiextensions",
        "ver": "v1beta1"
      }
    },
  #+END_SRC

*** code pulled from processedLogs through backend config        :backendAPI:
** new_endpoints
*** endoints gathered with generate_new_endpoints_tree        :processedLogs:
  [[file:data-gen/processAuditlog.py::def%20generate_new_endpoints_tree(openapi_spec):][link to code]]
  This appears to be identical to [[*code gathered through generate_endpoints_tree()][code gathered through generate_endpoints_tree()]]
  except for these lines
  #+NAME: diff between new_endpoints and endpoints
  #+BEGIN_SRC python
    op = method['operationId']
    if op not in endpoints.keys(): # commented out in new_endpoints
        endpoints[op] = {} comme # commented out in new_endpoints
  #+END_SRC

  Unclear whether this was the start of a project that is unfinished, or if it is doing something unique that I can't see.  In endpoints, if the =op= does not exist we make it.  In new_endpoints we don't...but seemingly just cos we already know it should be there?
** tests
*** generated as part of generate_coverage_report             :processedLogs:
     [[file:data-gen/processAuditlog.py::if%20event.get('userAgent',%20False)%20and%20useragent.startswith('e2e.test'):][link to code]]

   At start of coverage report, tests is made as an empty dict.
   It is populated only if =event.get('userAgent', False)= AND =useragent.startswith('e2e.test')=

   I believe what this means is we are looking to see if that event //had// a User-Agent and if so, if it started with e2e.test.  If both are true, we know that we can look for the test names within this.
   #+NAME: relevant code within generate_coverage_report
   #+BEGIN_SRC python
# starts at line 276
     if event.get('userAgent', False) and useragent.startswith('e2e.test'):
         test_name_start = ' -- '
         if useragent.find(test_name_start) > -1:
             test_name = useragent.split(test_name_start)[1]
             if test_name not in tests.keys():
                 tests[test_name] = {}
             if test_name not in test_sequences.keys():
                 test_sequences[test_name] = []
             test_sequences[test_name].append([event['requestReceivedTimestamp'],
                                               level, category, method, op])
             if op not in tests[test_name].keys():
                 tests[test_name][op] = {}
             if method not in tests[test_name][op].keys():
                 tests[test_name][op][method] = {
                     "counter": 0
                 }
             tests[test_name][op][method]["counter"] += 1
             tags = re.findall(r'\[.+?\]', test_name)
             for tag in tags:
                 if tag not in test_tags.keys():
                     test_tags[tag] = {}
                 if op not in test_tags[tag].keys():
                     test_tags[tag][op] = {}
                 if method not in test_tags[tag][op].keys():
                     test_tags[tag][op][method] = {
                         "counter": 0
                     }
                 test_tags[tag][op][method]["counter"] += 1
                 if tag not in endpoints[op][method]['test_tags']:
                     endpoints[op][method]['test_tags'].append(tag)
                 if test_name not in endpoints[op][method]['tests']:
                     endpoints[op][method]['tests'].append(test_name)
                 # if tag not in sb_method['test_tags']:
                 #     sb_method['test_tags'].append(tag)

     else:
         # IF we hit here, this is NOT an e2e.test user agent
         if user_agent_available: # 12 and higher
           pass # go on to user agent processing (e2e only)
           # continue # do no further processing (e2e + other)
         else: # 11 and lower
           # Only look at e2e for now, skip anything else
           pass #(log everything)
           # continue # stop here

     endpoints[op][method]["counter"] += 1
     agent = event.get('userAgent', ' ').split(' ')[0]
     if agent not in useragents.keys():
         useragents[agent] = {}
     if op not in useragents[agent].keys():
         useragents[agent][op] = {}
     if method not in useragents[agent][op].keys():
         useragents[agent][op][method] = {
             "counter": 0
         }
     useragents[agent][op][method]["counter"] += 1
     # sunburst[level][category][path][method]['counter'] += 1
     # if agent not in sb_method['agents']:
     #     sb_method['agents'].append(agent)
     # if agent not in sb_method['agents']:
     #     sb_method['agents'].append(agent)
     #     sunburst[level][category][path][method]['agents'].append(agent)
   #+END_SRC

   And so once it finds the tests, it looks to see if that test already exists within op[method][tests] and creates it if not.  If it does, then it ups the counter for tests[op][method].  It's through this counter that we know how many times this particular operationId method is hit by this test.

   In this sample, you can see the test has a long name plus a number of tags as =[tag_name]=.  The output will be a list of operatorId's containing their methods, and within that a counter saying how many times that particular test hit that particular method.
   #+NAME: Example Test Object
   #+BEGIN_SRC shell :dir ./data-gen/processed/ci-kubernetes-e2e-gci-gce/36092 :results output
cat apisnoop.json | jq '.tests["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]"]'
   #+END_SRC
   #+RESULTS: Example Test Object
   #+begin_example
   {
     "listCoreV1NamespacedPod": {
       "get": {
         "counter": 12
       }
     },
     "listRbacAuthorizationV1NamespacedRole": {
       "get": {
         "counter": 1
       }
     },
     "getCertificatesV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getAuthenticationV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listExtensionsV1beta1NamespacedDaemonSet": {
       "get": {
         "counter": 1
       }
     },
     "getRbacAuthorizationV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "createCoreV1NamespacedPod": {
       "post": {
         "counter": 2
       }
     },
     "getBatchV2alpha1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getExtensionsV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listNetworkingV1NamespacedNetworkPolicy": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedServiceAccount": {
       "watch": {
         "counter": 4
       },
       "get": {
         "counter": 1
       }
     },
     "getSchedulingV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedReplicationController": {
       "get": {
         "counter": 1
       }
     },
     "getAPIVersions": {
       "get": {
         "counter": 1
       }
     },
     "getBatchV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listAppsV1NamespacedReplicaSet": {
       "get": {
         "counter": 1
       }
     },
     "readCoreV1Namespace": {
       "get": {
         "counter": 14
       }
     },
     "getAutoscalingV2beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getRbacAuthorizationV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getAppsV1beta2APIResources": {
       "get": {
         "counter": 1
       }
     },
     "readCoreV1NamespacedPodLog": {
       "get": {
         "counter": 2
       }
     },
     "getSchedulingV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getApiregistrationV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getAutoscalingV2beta2APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedSecret": {
       "get": {
         "counter": 1
       }
     },
     "listAppsV1NamespacedDeployment": {
       "get": {
         "counter": 1
       }
     },
     "readCoreV1NamespacedPod": {
       "get": {
         "counter": 7
       }
     },
     "listExtensionsV1beta1NamespacedIngress": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedLimitRange": {
       "get": {
         "counter": 1
       }
     },
     "listAppsV1NamespacedDaemonSet": {
       "get": {
         "counter": 1
       }
     },
     "getAdmissionregistrationV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "createRbacAuthorizationV1beta1NamespacedRoleBinding": {
       "post": {
         "counter": 1
       }
     },
     "getAuthorizationV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getNodeV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listBatchV1NamespacedJob": {
       "get": {
         "counter": 1
       }
     },
     "listCoordinationV1NamespacedLease": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedConfigMap": {
       "get": {
         "counter": 1
       }
     },
     "listPolicyV1beta1NamespacedPodDisruptionBudget": {
       "get": {
         "counter": 1
       }
     },
     "deleteCoreV1NamespacedPod": {
       "delete": {
         "counter": 1
       }
     },
     "listRbacAuthorizationV1NamespacedRoleBinding": {
       "get": {
         "counter": 1
       }
     },
     "listBatchV1beta1NamespacedCronJob": {
       "get": {
         "counter": 1
       }
     },
     "getSettingsV1alpha1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "createCoreV1Namespace": {
       "post": {
         "counter": 1
       }
     },
     "listAppsV1NamespacedControllerRevision": {
       "get": {
         "counter": 1
       }
     },
     "getAuthenticationV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getBatchV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getNetworkingV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedEndpoints": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedService": {
       "get": {
         "counter": 1
       }
     },
     "listExtensionsV1beta1NamespacedDeployment": {
       "get": {
         "counter": 1
       }
     },
     "listSettingsV1alpha1NamespacedPodPreset": {
       "get": {
         "counter": 1
       }
     },
     "getApiregistrationV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getNetworkingV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getEventsV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "createAuthorizationV1beta1SubjectAccessReview": {
       "post": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedPodTemplate": {
       "get": {
         "counter": 1
       }
     },
     "getCoordinationV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listAutoscalingV1NamespacedHorizontalPodAutoscaler": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedResourceQuota": {
       "get": {
         "counter": 1
       }
     },
     "getStorageV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1Node": {
       "get": {
         "counter": 1
       }
     },
     "listAppsV1NamespacedStatefulSet": {
       "get": {
         "counter": 1
       }
     },
     "listExtensionsV1beta1NamespacedReplicaSet": {
       "get": {
         "counter": 1
       }
     },
     "getAppsV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getPolicyV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getCoordinationV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listExtensionsV1beta1NamespacedNetworkPolicy": {
       "get": {
         "counter": 1
       }
     },
     "deleteCoreV1Namespace": {
       "delete": {
         "counter": 1
       }
     },
     "getAutoscalingV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getSchedulingV1alpha1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getAuthorizationV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listEventsV1beta1NamespacedEvent": {
       "get": {
         "counter": 1
       }
     },
     "getCoreAPIVersions": {
       "get": {
         "counter": 1
       }
     },
     "getApiextensionsV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listNetworkingV1beta1NamespacedIngress": {
       "get": {
         "counter": 1
       }
     },
     "getAppsV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getCoreV1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "getStorageV1beta1APIResources": {
       "get": {
         "counter": 1
       }
     },
     "listCoreV1NamespacedPersistentVolumeClaim": {
       "get": {
         "counter": 1
       }
     }
   }
   #+end_example

** test_tags
*** generated as part of generate_coverage_report             :processedLogs:
     [[file:data-gen/processAuditlog.py::if%20event.get('userAgent',%20False)%20and%20useragent.startswith('e2e.test'):][link to code]]

   At start of coverage report, test_tags is made as an empty dict.
   It is populated only if =event.get('userAgent', False)= AND =useragent.startswith('e2e.test')=
   It works as part of the same if loop as =tests=.  relevant code below

   #+NAME: relevant code for test_tags within generate_coverage_report
   #+BEGIN_SRC python
# starts at line 276
     if event.get('userAgent', False) and useragent.startswith('e2e.test'):
         test_name_start = ' -- '
         if useragent.find(test_name_start) > -1:
             test_name = useragent.split(test_name_start)[1]
             tags = re.findall(r'\[.+?\]', test_name)
             for tag in tags:
                 if tag not in test_tags.keys():
                     test_tags[tag] = {}
                 if op not in test_tags[tag].keys():
                     test_tags[tag][op] = {}
                 if method not in test_tags[tag][op].keys():
                     test_tags[tag][op][method] = {
                         "counter": 0
                     }
                 test_tags[tag][op][method]["counter"] += 1
                 if tag not in endpoints[op][method]['test_tags']:
                     endpoints[op][method]['test_tags'].append(tag)
                 if test_name not in endpoints[op][method]['tests']:
                     endpoints[op][method]['tests'].append(test_name)
                 # if tag not in sb_method['test_tags']:
                 #     sb_method['test_tags'].append(tag)
   #+END_SRC
   So we do a regex on the test_name for everything in between =[ ]=, as that's the convention for writing test tags.  If that tag doesn't exist yet in test_tags, we make it.  If the op and method don't exist yet, we make them and start the counter at 0, then we up the counter by 1.

   Also interesting, is that we append the test_name and test_tag name to their respective lists within the endpoints.op.method.  So we could filter endpoints by a test using just that list, but then check how many times an endpoint is hit by a test or tag by referencing it's operatorID and method within either the test or test_tags dicts, respectively.

   #+NAME: Example Test_Tags Object
   #+BEGIN_SRC shell :dir ./data-gen/processed/ci-kubernetes-e2e-gci-gce/36092 :results output
cat apisnoop.json | jq '.test_tags["[LocalVolumeType: dir-bindmounted]"]'
   #+END_SRC

   Since test_tags can be part of multiple tests, the test_tag counter for an object would be high as it accounts for multiple tests.  One thing our code doesn't account for, I don't think, is whether a tag is added multiple times to a test (by accident). Does this ever happen, or could it happen?

** test_sequences
*** generated as part of generate_coverage_report             :processedLogs:
     [[file:data-gen/processAuditlog.py::if%20event.get('userAgent',%20False)%20and%20useragent.startswith('e2e.test'):][link to code]]

   At start of coverage report, test_tags is made as an empty dict.
   It is populated only if =event.get('userAgent', False)= AND =useragent.startswith('e2e.test')=
   It works as part of the same if loop as =tests=.  relevant code below
  #+NAME: Relevant Code for test_sequences
  #+BEGIN_SRC python
    if event.get('userAgent', False) and useragent.startswith('e2e.test'):
        test_name_start = ' -- '
        if useragent.find(test_name_start) > -1:
            test_name = useragent.split(test_name_start)[1]
            if test_name not in test_sequences.keys():
                test_sequences[test_name] = []
                test_sequences[test_name].append([event['requestReceivedTimestamp'],
                                                level, category, method, op])
  #+END_SRC

  And so if the test doesn't already exist in test_sequences, it's created and then we add to it's list a string with timestamp, level, category, method, op for this particular test. So when a new endoint is looked at, and we find the test again, this is also added to the sequence.  In this way, when we click on a test and see its sequence, we are seeing every operatorId[method] this test hit, and at what time.

   #+NAME: Example Test_Sequences Object
   #+BEGIN_SRC shell :dir ./data-gen/processed/ci-kubernetes-e2e-gci-gce/36092 :results output
cat apisnoop.json | jq '.test_sequences["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]"]'
   #+END_SRC

   #+RESULTS: Example Test_Sequences Object
   #+begin_example
   [
     [
       "2019-03-26T00:26:09.778106Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:09.874798Z",
       "stable",
       "core",
       "post",
       "createCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:10.058231Z",
       "stable",
       "core",
       "watch",
       "listCoreV1NamespacedServiceAccount"
     ],
     [
       "2019-03-26T00:26:10.058231Z",
       "stable",
       "core",
       "watch",
       "listCoreV1NamespacedServiceAccount"
     ],
     [
       "2019-03-26T00:26:10.254343Z",
       "beta",
       "rbacAuthorization",
       "post",
       "createRbacAuthorizationV1beta1NamespacedRoleBinding"
     ],
     [
       "2019-03-26T00:26:10.408718Z",
       "beta",
       "authorization",
       "post",
       "createAuthorizationV1beta1SubjectAccessReview"
     ],
     [
       "2019-03-26T00:26:10.454147Z",
       "stable",
       "core",
       "watch",
       "listCoreV1NamespacedServiceAccount"
     ],
     [
       "2019-03-26T00:26:10.454147Z",
       "stable",
       "core",
       "watch",
       "listCoreV1NamespacedServiceAccount"
     ],
     [
       "2019-03-26T00:26:10.518767Z",
       "stable",
       "core",
       "post",
       "createCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:10.590589Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:12.656154Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:12.713070Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:12.754615Z",
       "stable",
       "core",
       "post",
       "createCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:12.802496Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:14.845880Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:16.858815Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:17.088332Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:17.229833Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPodLog"
     ],
     [
       "2019-03-26T00:26:17.229833Z",
       "stable",
       "core",
       "get",
       "readCoreV1NamespacedPodLog"
     ],
     [
       "2019-03-26T00:26:17.351838Z",
       "stable",
       "core",
       "delete",
       "deleteCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:17.419434Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:19.487298Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:21.490188Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:23.488923Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:25.485860Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:27.489263Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:29.504735Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:31.489217Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:33.538381Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:35.484512Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:37.485315Z",
       "stable",
       "core",
       "get",
       "listCoreV1NamespacedPod"
     ],
     [
       "2019-03-26T00:26:37.538757Z",
       "stable",
       "core",
       "get",
       "listCoreV1Node"
     ],
     [
       "2019-03-26T00:26:37.633237Z",
       "stable",
       "core",
       "delete",
       "deleteCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:37.703790Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:39.773001Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:41.753431Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:43.752393Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:45.752690Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:47.754909Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:49.775389Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:51.764497Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:53.759594Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:55.749452Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:57.782862Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:26:59.753060Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:27:01.750654Z",
       "stable",
       "core",
       "get",
       "readCoreV1Namespace"
     ],
     [
       "2019-03-26T00:27:01.800811Z",
       "stable",
       "core",
       "get",
       "getCoreAPIVersions"
     ],
     [
       "2019-03-26T00:27:01.858230Z",
       "stable",
       "apis",
       "get",
       "getAPIVersions"
     ],
     [
       "2019-03-26T00:27:01.909723Z",
       "beta",
       "policy",
       "get",
       "getPolicyV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.911174Z",
       "stable",
       "scheduling",
       "get",
       "getSchedulingV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.911599Z",
       "stable",
       "apps",
       "get",
       "getAppsV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.912539Z",
       "beta",
       "events",
       "get",
       "getEventsV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.913061Z",
       "stable",
       "apiregistration",
       "get",
       "getApiregistrationV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.913470Z",
       "beta",
       "authentication",
       "get",
       "getAuthenticationV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.913794Z",
       "beta",
       "scheduling",
       "get",
       "getSchedulingV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.914502Z",
       "stable",
       "batch",
       "get",
       "getBatchV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.914854Z",
       "beta",
       "authorization",
       "get",
       "getAuthorizationV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.916175Z",
       "beta",
       "storage",
       "get",
       "getStorageV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.916580Z",
       "beta",
       "networking",
       "get",
       "getNetworkingV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.916903Z",
       "beta",
       "coordination",
       "get",
       "getCoordinationV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.917735Z",
       "alpha",
       "settings",
       "get",
       "getSettingsV1alpha1APIResources"
     ],
     [
       "2019-03-26T00:27:01.919051Z",
       "beta",
       "certificates",
       "get",
       "getCertificatesV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.919478Z",
       "stable",
       "storage",
       "get",
       "getStorageV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.919865Z",
       "alpha",
       "scheduling",
       "get",
       "getSchedulingV1alpha1APIResources"
     ],
     [
       "2019-03-26T00:27:01.920336Z",
       "beta",
       "apps",
       "get",
       "getAppsV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.920675Z",
       "beta",
       "rbacAuthorization",
       "get",
       "getRbacAuthorizationV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.921891Z",
       "stable",
       "core",
       "get",
       "getCoreV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.922666Z",
       "beta",
       "autoscaling",
       "get",
       "getAutoscalingV2beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.923270Z",
       "stable",
       "rbacAuthorization",
       "get",
       "getRbacAuthorizationV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.923677Z",
       "beta",
       "extensions",
       "get",
       "getExtensionsV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.924894Z",
       "alpha",
       "batch",
       "get",
       "getBatchV2alpha1APIResources"
     ],
     [
       "2019-03-26T00:27:01.925394Z",
       "stable",
       "networking",
       "get",
       "getNetworkingV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.925773Z",
       "beta",
       "apps",
       "get",
       "getAppsV1beta2APIResources"
     ],
     [
       "2019-03-26T00:27:01.926283Z",
       "stable",
       "authentication",
       "get",
       "getAuthenticationV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.926614Z",
       "beta",
       "node",
       "get",
       "getNodeV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.926921Z",
       "beta",
       "autoscaling",
       "get",
       "getAutoscalingV2beta2APIResources"
     ],
     [
       "2019-03-26T00:27:01.928389Z",
       "beta",
       "apiregistration",
       "get",
       "getApiregistrationV1beta1APIResources"
     ],
     [
       "2019-03-26T00:27:01.928767Z",
       "stable",
       "authorization",
       "get",
       "getAuthorizationV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.929187Z",
       "stable",
       "autoscaling",
       "get",
       "getAutoscalingV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.929514Z",
       "stable",
       "coordination",
       "get",
       "getCoordinationV1APIResources"
     ],
     [
       "2019-03-26T00:27:01.929839Z",
       "beta",
       "batch",
       "get",
       "getBatchV1beta1APIResources"
     ]
   ]
   #+end_example

** useragents
*** generated as part of generate_coverage_report             :processedLogs:
     [[file:data-gen/processAuditlog.py::if%20event.get('userAgent',%20False)%20and%20useragent.startswith('e2e.test'):][link to code]]

    Useragents are either a part of the auditlog event or they are not.  They were intentionally added to the audits starting with release 1.12.

    So we can look for them with =useragent = event.get('userAgent', ' ')= for each auditlog event.  We then take the useragent grabbed and add it to [[unknown_urls]] [[unknown_url_methods]] and its own [[useragents]] section.

    First we add the useragents found to unknown_urls and unknown_url_methods
   #+NAME: add useragents to unknown_urls and unknown_url_methods
   #+BEGIN_SRC python
     def generate_coverage_report(openapi_spec, audit_log, user_agent_available):
     ## endpoints, new_endpoints, sunburst, tests and all that.
         useragents = {}
         unknown_urls = {}
         unknown_url_methods = {}
         for event in audit_log:
             # import ipdb; ipdb.set_trace(context=60)
             spec_entry = find_openapi_entry(openapi_spec, event)
             uri = event['requestURI']
             method = event['method']
             useragent = event.get('userAgent', ' ')

            if useragent and useragent not in unknown_urls[uri][method]['agents']:
                unknown_urls[uri][method]['agents'].append(useragent)
            unknown_urls[uri][method]['counter'] += 1
            continue
        # look for the url+method in the OpenAPI spec
        if method not in spec_entry['methods'].keys():
            if uri not in unknown_url_methods.keys():
                unknown_url_methods[uri] = {}
            if method not in unknown_url_methods[uri]:
                unknown_url_methods[uri][method] = {
                    'counter': 0,
                    'agents': []
                }
            if useragent and useragent not in unknown_url_methods[uri][method]['agents']:
                unknown_url_methods[uri][method]['agents'].append(useragent)
            unknown_url_methods[uri][method]['counter'] += 1
            continue
   #+END_SRC

   I am not honestly sure what we're doing with the unknown dicts...but it looks like for each of them we are tracking a uri and a method, and within each method the agents that are a part of that event...then we up the counter...so the counter is related to how many times this unknown url is being hit, and the useragent behind that hit.  The unknown_url_methods seems to be covering the same ground as just unknown_urls...but i guess it's saying not only is the url unknown, but the method being used is unknown, and yet it's still being hit by this useragent.

   Then we add the useragent  to its own dict. This comes after our work with tests, test_tags, and test sequences

   #+NAME: add useragents to its own dict
   #+BEGIN_SRC python
     def generate_coverage_report(openapi_spec, audit_log, user_agent_available):
              #...all the code up to where we work with tests
        if event.get('userAgent', False) and useragent.startswith('e2e.test'):
            # ...Since we know tests are available, since the useragent is an e2e.test one,
            # add the tests to endpoints, tests, test_tags, test sequence.
         else:
             # IF we hit here, this is NOT an e2e.test user agent
             if user_agent_available: # 12 and higher
                 pass # go on to user agent processing (e2e only)
             # continue # do no further processing (e2e + other)
             else: # 11 and lower
                 # Only look at e2e for now, skip anything else
                 pass #(log everything)
             # continue # stop here

         endpoints[op][method]["counter"] += 1
         agent = event.get('userAgent', ' ').split(' ')[0]
         if agent not in useragents.keys():
             useragents[agent] = {}
         if op not in useragents[agent].keys():
             useragents[agent][op] = {}
         if method not in useragents[agent][op].keys():
             useragents[agent][op][method] = {
                 "counter": 0
             }
             useragents[agent][op][method]["counter"] += 1
             # sunburst[level][category][path][method]['counter'] += 1
             # if agent not in sb_method['agents']:
             #     sb_method['agents'].append(agent)
             # if agent not in sb_method['agents']:
             #     sb_method['agents'].append(agent)
             #     sunburst[level][category][path][method]['agents'].append(agent)

     # This should be calculated on the server, via an index
     # import ipdb; ipdb.set_trace(context=60)
         if agent not in endpoints[op][method]['agents']:
             endpoints[op][method]['agents'].append(agent)
   #+END_SRC

I do not understand the =else= logic on [[add useragents to its own dict][line 1413]].  It seems to pass regardless of true or false.
But regardless, once that's done we up our endopint counter, and add the useragent to our useragents dict, along with the operation and method included in this event.  We up the counter, to show how many times this useragent hit this operation and method (what does it mean if it's higher than 1?  does it tell us anything significant?)

lastly, we append the useragent to the endpoints[op][method][agents]...so we get a list of agents within that section, and we can cross reference this to the useragents dict to get our hit counter.

** unknown_urls
*** generated as part of generate_coverage_report             :processedLogs:
     [[file:data-gen/processAuditlog.py::if%20event.get('userAgent',%20False)%20and%20useragent.startswith('e2e.test'):][link to code]]
An unknown_url is one that is hit during an auditlog event, but cannot be found in our openAPI Spec.

   #+NAME: add useragents to unknown_urls and unknown_url_methods
   #+BEGIN_SRC python
     def generate_coverage_report(openapi_spec, audit_log, user_agent_available):
     ## endpoints, new_endpoints, sunburst, tests and all that.
         useragents = {}
         unknown_urls = {}
         unknown_url_methods = {}
         for event in audit_log:
             # import ipdb; ipdb.set_trace(context=60)
             spec_entry = find_openapi_entry(openapi_spec, event)
             uri = event['requestURI']
             method = event['method']
             useragent = event.get('userAgent', ' ')
             if spec_entry is None:
                 # print("API Entry not found for event URL \"%s\"" % \
                 #   event['requestURI'])
                 # openapi/v2 (kubectl)
                 # /apis/scalingpolicy.kope.io/*/scalingpolcies
                 # /apis/metrics.kope.io/*
                 # /apis/extensions/*/replicationcontrollers
                 if uri not in unknown_urls.keys():
                     unknown_urls[uri] = {}
                 if method not in unknown_urls[uri]:
                     unknown_urls[uri][method] = {
                         'counter': 0,
                         'agents': []
                     }
                 if useragent and useragent not in unknown_urls[uri][method]['agents']:
                     unknown_urls[uri][method]['agents'].append(useragent)
                 unknown_urls[uri][method]['counter'] += 1
                 continue
             # look for the url+method in the OpenAPI spec
             if method not in spec_entry['methods'].keys():
                 # Mostly it's valid urls with /localsubjectaccesreviews appended
                 # TODO: figure out what /localsubjectaccessreviews are
                 # print("API Method %s not found for event URL \"%s\"" % (
                     # event['method'],event['requestURI']))
                 if uri not in unknown_url_methods.keys():
                     unknown_url_methods[uri] = {}
                 if method not in unknown_url_methods[uri]:
                     unknown_url_methods[uri][method] = {
                         'counter': 0,
                         'agents': []
                     }
                 if useragent and useragent not in unknown_url_methods[uri][method]['agents']:
                     unknown_url_methods[uri][method]['agents'].append(useragent)
                 unknown_url_methods[uri][method]['counter'] += 1
                 continue

            if useragent and useragent not in unknown_urls[uri][method]['agents']:
                unknown_urls[uri][method]['agents'].append(useragent)
            unknown_urls[uri][method]['counter'] += 1
            continue
   #+END_SRC

So we can expect the unknown_urls dict to either be empty (which is good?) or to have a number of urls, within each are methods and within this a list of agents that hit this method, and a counter for how many times it is hit.  IT doesn't seem like we can cross reference how many times an individual useragent is hitting an uknown url, just that it was hit a number of times by this speficic list of agents.

** unknown_url_methods
*** generated as part of generate_coverage_report             :processedLogs:
     [[file:data-gen/processAuditlog.py::if%20event.get('userAgent',%20False)%20and%20useragent.startswith('e2e.test'):][link to code]]
An unknown_url_method is v close to unknown_urls.  They are generated and added to in the same section of code.  One is saying whether the url is not in the apispec, the other is saying, "the url is in the spec, but the method is new."  In either case, we track the op and method it hit, upping the counter and adding to the list of useragents the one that hit it.

   #+NAME: add useragents to unknown_urls and unknown_url_methods
   #+BEGIN_SRC python
     def generate_coverage_report(openapi_spec, audit_log, user_agent_available):
     ## endpoints, new_endpoints, sunburst, tests and all that.
         useragents = {}
         unknown_urls = {}
         unknown_url_methods = {}
         for event in audit_log:
             # import ipdb; ipdb.set_trace(context=60)
             spec_entry = find_openapi_entry(openapi_spec, event)
             uri = event['requestURI']
             method = event['method']
             useragent = event.get('userAgent', ' ')
             if spec_entry is None:
                 # print("API Entry not found for event URL \"%s\"" % \
                 #   event['requestURI'])
                 # openapi/v2 (kubectl)
                 # /apis/scalingpolicy.kope.io/*/scalingpolcies
                 # /apis/metrics.kope.io/*
                 # /apis/extensions/*/replicationcontrollers
                 if uri not in unknown_urls.keys():
                     unknown_urls[uri] = {}
                 if method not in unknown_urls[uri]:
                     unknown_urls[uri][method] = {
                         'counter': 0,
                         'agents': []
                     }
                 if useragent and useragent not in unknown_urls[uri][method]['agents']:
                     unknown_urls[uri][method]['agents'].append(useragent)
                 unknown_urls[uri][method]['counter'] += 1
                 continue
             # look for the url+method in the OpenAPI spec
             if method not in spec_entry['methods'].keys():
                 # Mostly it's valid urls with /localsubjectaccesreviews appended
                 # TODO: figure out what /localsubjectaccessreviews are
                 # print("API Method %s not found for event URL \"%s\"" % (
                     # event['method'],event['requestURI']))
                 if uri not in unknown_url_methods.keys():
                     unknown_url_methods[uri] = {}
                 if method not in unknown_url_methods[uri]:
                     unknown_url_methods[uri][method] = {
                         'counter': 0,
                         'agents': []
                     }
                 if useragent and useragent not in unknown_url_methods[uri][method]['agents']:
                     unknown_url_methods[uri][method]['agents'].append(useragent)
                 unknown_url_methods[uri][method]['counter'] += 1
                 continue

            if useragent and useragent not in unknown_urls[uri][method]['agents']:
                unknown_urls[uri][method]['agents'].append(useragent)
            unknown_urls[uri][method]['counter'] += 1
            continue
   #+END_SRC
** endpoint.path :: this is just
** endpoint.test_tags ::
** endpoint.description ::
** endpoint.tests ::
** bucket :: name of GCS bucket API data came from
** job :: K8s build number (?) (where is this from? Prow?)
** release ::  it is the concatination of the values from bucket and job and used to generate the URL.
               Result of hack.  If routing went to "apisnoop.cncf.io/bucket/job..." then release would not be necessary.
** _id :: the unique id given by feathers when entry added to API db
** test :: A test that is part of the e2e suite binary (check)
** isTested :: Whether or not endopint method counter is > 0 (this is incorrect)
   Our current definition is not right.  The actual definition should be whether  the endpoint method's test array has a length greater than 0.  IKn other words, if it contains tests we know it is tested.
*** TODO Adjust  isTested to match correct definition
*** TODO update this definition when we update code.

** test.sequence ::
** Data from apisnoop
#+NAME: Endpoint
#+BEGIN_EXAMPLE
     {
        "name": "readCoreV1NamespacedPersistentVolumeClaimStatus",
        "method": "get",
        "level": "stable",
        "test_tags": [],
        "tests": [],
        "description": "read status of the specified PersistentVolumeClaim",
        "path": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
        "category": "core",
        "isTested": false,
        "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable3-default",
        "job": "460",
        "release": "ci-kubernetes-e2e-gce-cos-k8sstable3-default_460",
        "_id": "6P78EQLmPvD27Ls7"
      }
#+END_EXAMPLE

#+NAME: Useragent snippet
#+BEGIN_EXAMPLE json
  {"name": "kube-apiserver/v1.15.0",
  "endpoints": {
  "listCoreV1LimitRangeForAllNamespaces": {
  "watch": {
  "counter": 7
  },
  "get": {
  "counter": 1
  }
  },
  "createApiregistrationV1APIService": {
  "post": {
  "counter": 51
  }
  }
  }
#+END_EXAMPLE

* Global / Agreed
  :LOGBOOK:
  CLOCK: [2019-04-04 Thu 10:56]--[2019-04-04 Thu 11:21] =>  0:25
  :END:
  - level :: level of stability/support for an api version. See [[https://kubernetes.io/docs/reference/using-api/api-overview/#api-versioning][K8s Docs: API Versioning]]
  - category ::
  -  ::
* globant
** Definitions
*** resources/kind ::
*** E2E name ::
*** E2E Tags ::
*** APIGroups ::
*** Groups ::
*** Batch ::
*** Version ::
*** Subresource ::
*** Verbs ::
* [[https://github.com/kubernetes/kubernetes/tree/master/api/openapi-spec#kubernetess-openapi-specification][openapi spec]]
  Resulting spec is generated as [[https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json][swagger.json]]
- [[https://github.com/kubernetes/kubernetes/tree/master/api/openapi-spec#x-kubernetes-group-version-kind][group-version-kind]] ::
- [[https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#resources][kubernetes resource]] ::
* [[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/][API Documentation]]
** Resource
*** Categories
- Workloads :: used to manage and run your containers on the cluster.
- Discovery & LB :: used to "stitch" your workloads together in into an externally accessible, load-balanced Service.
- Config & Storage :: used to inject initialization data into your applications, and to persist data that is external to your container.
- Cluster :: defines how the cluster itself is configured; these are typically used only by cluster operators.
- Metadata ::  used to configure the behavior of other resources within the cluster, such as [HorizontalPodAutoscaler](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#horizontalpodautoscaler-v1-autoscaling) for scaling workloads.
*** Objects
Resource objects typically have 3 components:

- Resource ObjectMeta :: This is metadata about the resource, such as its name, type, api version, annotations, and labels. This contains fields that maybe updated both by the end user and the system (e.g. annotations).
- ResourceSpec :: This is defined by the user and describes the desired state of system. Fill this in when creating or updating an object.
- ResourceStatus :: This is filled in by the server and reports the current state of the system. In most cases, users don't need to change this.

*** CRUD Operations
- Create :: create the resource in the storage backend. After a resource is create the system will apply the desired state.
- Read / Get :: retrieve a specific resource object by name
- Read / List :: retrieve all resource objects of a specific type within a namespace, and the results can be restricted to resources matching a selector query.
- Read / Watch :: stream results for an object(s) as it is updated. Similar to a callback, watch is used to respond to resource changes.
- Update / Replace :: update the resource by replacing the existing spec with the provided one.
- Update / Patch :: apply a change to a specific field.
- Delete :: delete a resource
- Rollback :: a PodTemplate to a previous version. Only available for some resource types
- Read / Write Scale :: Read or Update the number of replicas for the given resource. Only available for some resource types.
- Read / Write Staus :: Read or Update the Status for a resource object. The Status can only changed through these update operations.
** Definitions
https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#-strong-definitions-strong-

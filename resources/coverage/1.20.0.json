{"release":"1.20.0","release_date":"2020-07-20T20:45:01","spec":"https://raw.githubusercontent.com/kubernetes/kubernetes/5feab0aa1e592a/api/openapi-spec/swagger.json","source":"https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/ci-kubernetes-e2e-gci-gce/1285305862176378880","endpoints":[{"release":"1.20.0","endpoint":"connectCoreV1DeleteNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect DELETE requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1DeleteNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect DELETE requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1DeleteNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect DELETE requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1DeleteNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect DELETE requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1DeleteNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect DELETE requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1DeleteNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect DELETE requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1GetNamespacedPodAttach","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/attach","description":"connect GET requests to attach of Pod","kind":"PodAttachOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1GetNamespacedPodExec","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/exec","description":"connect GET requests to exec of Pod","kind":"PodExecOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]"]},{"release":"1.20.0","endpoint":"connectCoreV1GetNamespacedPodPortforward","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/portforward","description":"connect GET requests to portforward of Pod","kind":"PodPortForwardOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":false,"tests":["[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets"]},{"release":"1.20.0","endpoint":"connectCoreV1GetNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect GET requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1GetNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect GET requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should create endpoints for unready pods"]},{"release":"1.20.0","endpoint":"connectCoreV1GetNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect GET requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1GetNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect GET requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]"]},{"release":"1.20.0","endpoint":"connectCoreV1GetNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect GET requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1GetNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect GET requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":false,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource"]},{"release":"1.20.0","endpoint":"connectCoreV1HeadNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect HEAD requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1HeadNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect HEAD requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1HeadNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect HEAD requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1HeadNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect HEAD requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1HeadNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect HEAD requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1HeadNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect HEAD requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1OptionsNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect OPTIONS requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1OptionsNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect OPTIONS requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1OptionsNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect OPTIONS requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1OptionsNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect OPTIONS requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1OptionsNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect OPTIONS requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1OptionsNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect OPTIONS requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PatchNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect PATCH requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PatchNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect PATCH requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PatchNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect PATCH requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PatchNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect PATCH requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PatchNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect PATCH requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PatchNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect PATCH requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNamespacedPodAttach","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/attach","description":"connect POST requests to attach of Pod","kind":"PodAttachOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNamespacedPodExec","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/exec","description":"connect POST requests to exec of Pod","kind":"PodExecOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNamespacedPodPortforward","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/portforward","description":"connect POST requests to portforward of Pod","kind":"PodPortForwardOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect POST requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect POST requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect POST requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect POST requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect POST requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PostNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect POST requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PutNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect PUT requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PutNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect PUT requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PutNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect PUT requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PutNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect PUT requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PutNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect PUT requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"connectCoreV1PutNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect PUT requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations","description":"create a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]"]},{"release":"1.20.0","endpoint":"createAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations","description":"create a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]"]},{"release":"1.20.0","endpoint":"createApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions","description":"create a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema"]},{"release":"1.20.0","endpoint":"createApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices","description":"create an APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]",null]},{"release":"1.20.0","endpoint":"createAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions","description":"create a ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets","description":"create a DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"post","tested":true,"conf_tested":true,"tests":["[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]",null]},{"release":"1.20.0","endpoint":"createAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments","description":"create a Deployment","kind":"Deployment","version":"v1","group":"apps","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"release":"1.20.0","endpoint":"createAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets","description":"create a ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]",null]},{"release":"1.20.0","endpoint":"createAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets","description":"create a StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"post","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"createAuthenticationV1TokenReview","level":"stable","category":"authentication","path":"/apis/authentication.k8s.io/v1/tokenreviews","description":"create a TokenReview","kind":"TokenReview","version":"v1","group":"authentication.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]"]},{"release":"1.20.0","endpoint":"createAuthorizationV1NamespacedLocalSubjectAccessReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews","description":"create a LocalSubjectAccessReview","kind":"LocalSubjectAccessReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAuthorizationV1SelfSubjectAccessReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/selfsubjectaccessreviews","description":"create a SelfSubjectAccessReview","kind":"SelfSubjectAccessReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]"]},{"release":"1.20.0","endpoint":"createAuthorizationV1SelfSubjectRulesReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/selfsubjectrulesreviews","description":"create a SelfSubjectRulesReview","kind":"SelfSubjectRulesReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAuthorizationV1SubjectAccessReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/subjectaccessreviews","description":"create a SubjectAccessReview","kind":"SubjectAccessReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-api-machinery] Events should delete a collection of events [Conformance]","[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] server version should find the server version [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should find a service from listing all namespaces [Conformance]","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"createAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers","description":"create a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs","description":"create a Job","kind":"Job","version":"v1","group":"batch","action":"post","tested":true,"conf_tested":true,"tests":["[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion",null]},{"release":"1.20.0","endpoint":"createCertificatesV1CertificateSigningRequest","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests","description":"create a CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"createCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases","description":"create a Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]",null]},{"release":"1.20.0","endpoint":"createCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces","description":"create a Namespace","kind":"Namespace","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-api-machinery] Events should delete a collection of events [Conformance]","[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should patch a Namespace [Conformance]","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] server version should find the server version [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should find a service from listing all namespaces [Conformance]","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedBinding","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/bindings","description":"create a Binding","kind":"Binding","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps","description":"create a ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints","description":"create Endpoints","kind":"Endpoints","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] Services should test the lifecycle of an Endpoint","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events","description":"create an Event","kind":"Event","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges","description":"create a LimitRange","kind":"LimitRange","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims","description":"create a PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods","description":"create a Pod","kind":"Pod","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should remove pods when job is deleted","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedPodBinding","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/binding","description":"create binding of a Pod","kind":"Binding","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedPodEviction","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/eviction","description":"create eviction of a Pod","kind":"Eviction","version":"v1beta1","group":"policy","action":"post","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it"]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates","description":"create a PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]"]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers","description":"create a ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas","description":"create a ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets","description":"create a Secret","kind":"Secret","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services","description":"create a Service","kind":"Service","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts","description":"create a ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"createCoreV1NamespacedServiceAccountToken","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token","description":"create token of a ServiceAccount","kind":"TokenRequest","version":"v1","group":"authentication.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes","description":"create a Node","kind":"Node","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes","description":"create a PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"release":"1.20.0","endpoint":"createEventsV1NamespacedEvent","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/namespaces/{namespace}/events","description":"create an Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]"]},{"release":"1.20.0","endpoint":"createNetworkingV1IngressClass","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingressclasses","description":"create an IngressClass","kind":"IngressClass","version":"v1","group":"networking.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]"]},{"release":"1.20.0","endpoint":"createNetworkingV1NamespacedIngress","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses","description":"create an Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"createNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies","description":"create a NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles","description":"create a ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]",null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings","description":"create a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles","description":"create a Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings","description":"create a RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-api-machinery] Events should delete a collection of events [Conformance]","[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] server version should find the server version [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should find a service from listing all namespaces [Conformance]","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"createSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses","description":"create a PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]",null]},{"release":"1.20.0","endpoint":"createStorageV1CSIDriver","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csidrivers","description":"create a CSIDriver","kind":"CSIDriver","version":"v1","group":"storage.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"createStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes","description":"create a CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses","description":"create a StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2",null]},{"release":"1.20.0","endpoint":"createStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments","description":"create a VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations","description":"delete collection of MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]"]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations","description":"delete collection of ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]"]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"delete a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]"]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"delete a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]"]},{"release":"1.20.0","endpoint":"deleteApiextensionsV1CollectionCustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions","description":"delete collection of CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]"]},{"release":"1.20.0","endpoint":"deleteApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"delete a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema"]},{"release":"1.20.0","endpoint":"deleteApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"delete an APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteApiregistrationV1CollectionAPIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices","description":"delete collection of APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAppsV1CollectionNamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions","description":"delete collection of ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAppsV1CollectionNamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets","description":"delete collection of DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAppsV1CollectionNamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments","description":"delete collection of Deployment","kind":"Deployment","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAppsV1CollectionNamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets","description":"delete collection of ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAppsV1CollectionNamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets","description":"delete collection of StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"delete a ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"delete a DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]"]},{"release":"1.20.0","endpoint":"deleteAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"delete a Deployment","kind":"Deployment","version":"v1","group":"apps","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"release":"1.20.0","endpoint":"deleteAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"delete a ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"delete a StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers","description":"delete collection of HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"delete a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteBatchV1CollectionNamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs","description":"delete collection of Job","kind":"Job","version":"v1","group":"batch","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"delete a Job","kind":"Job","version":"v1","group":"batch","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should remove pods when job is deleted",null]},{"release":"1.20.0","endpoint":"deleteCertificatesV1CertificateSigningRequest","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}","description":"delete a CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"deleteCertificatesV1CollectionCertificateSigningRequest","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests","description":"delete collection of CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"deleteCoordinationV1CollectionNamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases","description":"delete collection of Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"delete a Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]"]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps","description":"delete collection of ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints","description":"delete collection of Endpoints","kind":"Endpoints","version":"v1","group":"","action":"deletecollection","tested":true,"conf_tested":false,"tests":["[sig-network] Services should test the lifecycle of an Endpoint",null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events","description":"delete collection of Event","kind":"Event","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges","description":"delete collection of LimitRange","kind":"LimitRange","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims","description":"delete collection of PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods","description":"delete collection of Pod","kind":"Pod","version":"v1","group":"","action":"deletecollection","tested":true,"conf_tested":false,"tests":["[k8s.io] Pods should delete a collection of pods",null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates","description":"delete collection of PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-node] PodTemplates should delete a collection of pod templates [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers","description":"delete collection of ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas","description":"delete collection of ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets","description":"delete collection of Secret","kind":"Secret","version":"v1","group":"","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Secrets should patch a secret [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts","description":"delete collection of ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionNode","level":"stable","category":"core","path":"/api/v1/nodes","description":"delete collection of Node","kind":"Node","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1CollectionPersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes","description":"delete collection of PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"delete a Namespace","kind":"Namespace","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-api-machinery] Events should delete a collection of events [Conformance]","[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should patch a Namespace [Conformance]","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] server version should find the server version [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should find a service from listing all namespaces [Conformance]","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volumes ConfigMap should be mountable"]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"delete a ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-network] DNS should support configurable pod resolv.conf","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Volumes ConfigMap should be mountable"]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"delete Endpoints","kind":"Endpoints","version":"v1","group":"","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"delete an Event","kind":"Event","version":"v1","group":"","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"delete a LimitRange","kind":"LimitRange","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]"]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"delete a PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately"]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"delete a Pod","kind":"Pod","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"delete a PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]"]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"delete a ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"delete a ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource."]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"delete a Secret","kind":"Secret","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set",null]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"delete a Service","kind":"Service","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"deleteCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"delete a ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"deleteCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"delete a Node","kind":"Node","version":"v1","group":"","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"delete a PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"release":"1.20.0","endpoint":"deleteEventsV1CollectionNamespacedEvent","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/namespaces/{namespace}/events","description":"delete collection of Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-instrumentation] Events API should delete a collection of events [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteEventsV1NamespacedEvent","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}","description":"delete an Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]"]},{"release":"1.20.0","endpoint":"deleteNetworkingV1CollectionIngressClass","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingressclasses","description":"delete collection of IngressClass","kind":"IngressClass","version":"v1","group":"networking.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]"]},{"release":"1.20.0","endpoint":"deleteNetworkingV1CollectionNamespacedIngress","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses","description":"delete collection of Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"deleteNetworkingV1CollectionNamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies","description":"delete collection of NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNetworkingV1IngressClass","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingressclasses/{name}","description":"delete an IngressClass","kind":"IngressClass","version":"v1","group":"networking.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]"]},{"release":"1.20.0","endpoint":"deleteNetworkingV1NamespacedIngress","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}","description":"delete an Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"deleteNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"delete a NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"delete a ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"delete a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1CollectionClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles","description":"delete collection of ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1CollectionClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings","description":"delete collection of ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1CollectionNamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles","description":"delete collection of Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1CollectionNamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings","description":"delete collection of RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"delete a Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"delete a RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"deleteSchedulingV1CollectionPriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses","description":"delete collection of PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"delete a PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]"]},{"release":"1.20.0","endpoint":"deleteStorageV1CollectionCSIDriver","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csidrivers","description":"delete collection of CSIDriver","kind":"CSIDriver","version":"v1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1CollectionCSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes","description":"delete collection of CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1CollectionStorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses","description":"delete collection of StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1CollectionVolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments","description":"delete collection of VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1CSIDriver","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csidrivers/{name}","description":"delete a CSIDriver","kind":"CSIDriver","version":"v1","group":"storage.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"release":"1.20.0","endpoint":"deleteStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"delete a CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"delete a StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2"]},{"release":"1.20.0","endpoint":"deleteStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"delete a VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getAdmissionregistrationAPIGroup","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getAdmissionregistrationV1APIResources","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getApiextensionsAPIGroup","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getApiextensionsV1APIResources","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getApiregistrationAPIGroup","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getApiregistrationV1APIResources","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAPIVersions","level":"stable","category":"apis","path":"/apis/","description":"get available API versions","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAppsAPIGroup","level":"stable","category":"apps","path":"/apis/apps/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getAppsV1APIResources","level":"stable","category":"apps","path":"/apis/apps/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAuthenticationAPIGroup","level":"stable","category":"authentication","path":"/apis/authentication.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getAuthenticationV1APIResources","level":"stable","category":"authentication","path":"/apis/authentication.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAuthorizationAPIGroup","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getAuthorizationV1APIResources","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAutoscalingAPIGroup","level":"stable","category":"autoscaling","path":"/apis/autoscaling/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getAutoscalingV1APIResources","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getBatchAPIGroup","level":"stable","category":"batch","path":"/apis/batch/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getBatchV1APIResources","level":"stable","category":"batch","path":"/apis/batch/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getCertificatesAPIGroup","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"getCertificatesV1APIResources","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getCodeVersion","level":"stable","category":"version","path":"/version/","description":"get the code version","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getCoordinationAPIGroup","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getCoordinationV1APIResources","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getCoreAPIVersions","level":"stable","category":"core","path":"/api/","description":"get available API versions","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getCoreV1APIResources","level":"stable","category":"core","path":"/api/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getDiscoveryAPIGroup","level":"stable","category":"discovery","path":"/apis/discovery.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getEventsAPIGroup","level":"stable","category":"events","path":"/apis/events.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getEventsV1APIResources","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getExtensionsAPIGroup","level":"stable","category":"extensions","path":"/apis/extensions/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getFlowcontrolApiserverAPIGroup","level":"stable","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getNetworkingAPIGroup","level":"stable","category":"networking","path":"/apis/networking.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]"]},{"release":"1.20.0","endpoint":"getNetworkingV1APIResources","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getNodeAPIGroup","level":"stable","category":"node","path":"/apis/node.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getPolicyAPIGroup","level":"stable","category":"policy","path":"/apis/policy/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getRbacAuthorizationAPIGroup","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getRbacAuthorizationV1APIResources","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getSchedulingAPIGroup","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getSchedulingV1APIResources","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getSettingsAPIGroup","level":"stable","category":"settings","path":"/apis/settings.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getStorageAPIGroup","level":"stable","category":"storage","path":"/apis/storage.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup"]},{"release":"1.20.0","endpoint":"getStorageV1APIResources","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"listAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations","description":"list or watch objects of kind MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]",null]},{"release":"1.20.0","endpoint":"listAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations","description":"list or watch objects of kind ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]",null]},{"release":"1.20.0","endpoint":"listApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions","description":"list or watch objects of kind CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]",null]},{"release":"1.20.0","endpoint":"listApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices","description":"list or watch objects of kind APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAppsV1ControllerRevisionForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAppsV1DaemonSetForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAppsV1DeploymentForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]",null]},{"release":"1.20.0","endpoint":"listAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]",null]},{"release":"1.20.0","endpoint":"listAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios",null]},{"release":"1.20.0","endpoint":"listAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"release":"1.20.0","endpoint":"listAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]",null]},{"release":"1.20.0","endpoint":"listAppsV1ReplicaSetForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAppsV1StatefulSetForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listBatchV1JobForAllNamespaces","level":"stable","category":"batch","path":"/apis/batch/v1/jobs","description":"list or watch objects of kind Job","kind":"Job","version":"v1","group":"batch","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs","description":"list or watch objects of kind Job","kind":"Job","version":"v1","group":"batch","action":"list","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently",null]},{"release":"1.20.0","endpoint":"listCertificatesV1CertificateSigningRequest","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests","description":"list or watch objects of kind CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoordinationV1LeaseForAllNamespaces","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set",null]},{"release":"1.20.0","endpoint":"listCoreV1ComponentStatus","level":"stable","category":"core","path":"/api/v1/componentstatuses","description":"list objects of kind ComponentStatus","kind":"ComponentStatus","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoreV1ConfigMapForAllNamespaces","level":"stable","category":"core","path":"/api/v1/configmaps","description":"list or watch objects of kind ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1EndpointsForAllNamespaces","level":"stable","category":"core","path":"/api/v1/endpoints","description":"list or watch objects of kind Endpoints","kind":"Endpoints","version":"v1","group":"","action":"list","tested":true,"conf_tested":false,"tests":["[sig-network] Services should test the lifecycle of an Endpoint",null]},{"release":"1.20.0","endpoint":"listCoreV1EventForAllNamespaces","level":"stable","category":"core","path":"/api/v1/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoreV1LimitRangeForAllNamespaces","level":"stable","category":"core","path":"/api/v1/limitranges","description":"list or watch objects of kind LimitRange","kind":"LimitRange","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces","description":"list or watch objects of kind Namespace","kind":"Namespace","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps","description":"list or watch objects of kind ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints","description":"list or watch objects of kind Endpoints","kind":"Endpoints","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges","description":"list or watch objects of kind LimitRange","kind":"LimitRange","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims","description":"list or watch objects of kind PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods","description":"list or watch objects of kind Pod","kind":"Pod","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates","description":"list or watch objects of kind PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers","description":"list or watch objects of kind ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas","description":"list or watch objects of kind ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets","description":"list or watch objects of kind Secret","kind":"Secret","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services","description":"list or watch objects of kind Service","kind":"Service","version":"v1","group":"","action":"list","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"",null]},{"release":"1.20.0","endpoint":"listCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts","description":"list or watch objects of kind ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-api-machinery] Events should delete a collection of events [Conformance]","[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should patch a Namespace [Conformance]","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] server version should find the server version [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should find a service from listing all namespaces [Conformance]","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"listCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes","description":"list or watch objects of kind Node","kind":"Node","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should delete a collection of pods","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","[sig-api-machinery] Events should delete a collection of events [Conformance]","[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should patch a Namespace [Conformance]","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] server version should find the server version [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Ingress API should support creating Ingress API operations [Conformance]","[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should find a service from listing all namespaces [Conformance]","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"listCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes","description":"list or watch objects of kind PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1PersistentVolumeClaimForAllNamespaces","level":"stable","category":"core","path":"/api/v1/persistentvolumeclaims","description":"list or watch objects of kind PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoreV1PodForAllNamespaces","level":"stable","category":"core","path":"/api/v1/pods","description":"list or watch objects of kind Pod","kind":"Pod","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1PodTemplateForAllNamespaces","level":"stable","category":"core","path":"/api/v1/podtemplates","description":"list or watch objects of kind PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1ReplicationControllerForAllNamespaces","level":"stable","category":"core","path":"/api/v1/replicationcontrollers","description":"list or watch objects of kind ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoreV1ResourceQuotaForAllNamespaces","level":"stable","category":"core","path":"/api/v1/resourcequotas","description":"list or watch objects of kind ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoreV1SecretForAllNamespaces","level":"stable","category":"core","path":"/api/v1/secrets","description":"list or watch objects of kind Secret","kind":"Secret","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Secrets should patch a secret [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1ServiceAccountForAllNamespaces","level":"stable","category":"core","path":"/api/v1/serviceaccounts","description":"list or watch objects of kind ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]",null]},{"release":"1.20.0","endpoint":"listCoreV1ServiceForAllNamespaces","level":"stable","category":"core","path":"/api/v1/services","description":"list or watch objects of kind Service","kind":"Service","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-network] Services should find a service from listing all namespaces [Conformance]",null]},{"release":"1.20.0","endpoint":"listEventsV1EventForAllNamespaces","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]",null]},{"release":"1.20.0","endpoint":"listEventsV1NamespacedEvent","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/namespaces/{namespace}/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-instrumentation] Events API should delete a collection of events [Conformance]","[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]",null]},{"release":"1.20.0","endpoint":"listNetworkingV1IngressClass","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingressclasses","description":"list or watch objects of kind IngressClass","kind":"IngressClass","version":"v1","group":"networking.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"listNetworkingV1IngressForAllNamespaces","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"listNetworkingV1NamespacedIngress","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"listNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies","description":"list or watch objects of kind NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listNetworkingV1NetworkPolicyForAllNamespaces","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/networkpolicies","description":"list or watch objects of kind NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles","description":"list or watch objects of kind ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] Job should remove pods when job is deleted","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]",null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings","description":"list or watch objects of kind ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1RoleBindingForAllNamespaces","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1RoleForAllNamespaces","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses","description":"list or watch objects of kind PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1CSIDriver","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csidrivers","description":"list or watch objects of kind CSIDriver","kind":"CSIDriver","version":"v1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes","description":"list or watch objects of kind CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses","description":"list or watch objects of kind StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"list","tested":true,"conf_tested":false,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable",null]},{"release":"1.20.0","endpoint":"listStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments","description":"list or watch objects of kind VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"logFileHandler","level":"stable","category":"logs","path":"/logs/{logpath}","description":null,"kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"logFileListHandler","level":"stable","category":"logs","path":"/logs/","description":null,"kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services"]},{"release":"1.20.0","endpoint":"patchAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"partially update the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]"]},{"release":"1.20.0","endpoint":"patchAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"partially update the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]"]},{"release":"1.20.0","endpoint":"patchApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"partially update the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]"]},{"release":"1.20.0","endpoint":"patchApiextensionsV1CustomResourceDefinitionStatus","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status","description":"partially update status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]"]},{"release":"1.20.0","endpoint":"patchApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"partially update the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchApiregistrationV1APIServiceStatus","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}/status","description":"partially update status of the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"partially update the specified ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"partially update the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]"]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedDaemonSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status","description":"partially update status of the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"partially update the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedDeploymentScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale","description":"partially update scale of the specified Deployment","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedDeploymentStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status","description":"partially update status of the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"partially update the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedReplicaSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale","description":"partially update scale of the specified ReplicaSet","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedReplicaSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status","description":"partially update status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"partially update the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedStatefulSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale","description":"partially update scale of the specified StatefulSet","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAppsV1NamespacedStatefulSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status","description":"partially update status of the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"partially update the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"partially update status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"partially update the specified Job","kind":"Job","version":"v1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchBatchV1NamespacedJobStatus","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status","description":"partially update status of the specified Job","kind":"Job","version":"v1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCertificatesV1CertificateSigningRequest","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}","description":"partially update the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"patchCertificatesV1CertificateSigningRequestApproval","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval","description":"partially update approval of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"patchCertificatesV1CertificateSigningRequestStatus","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status","description":"partially update status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"patchCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"partially update the specified Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]"]},{"release":"1.20.0","endpoint":"patchCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"partially update the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Namespaces [Serial] should patch a Namespace [Conformance]"]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"partially update the specified ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]"]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"partially update the specified Endpoints","kind":"Endpoints","version":"v1","group":"","action":"patch","tested":true,"conf_tested":false,"tests":["[sig-network] Services should test the lifecycle of an Endpoint"]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"partially update the specified Event","kind":"Event","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"partially update the specified LimitRange","kind":"LimitRange","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"partially update the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedPersistentVolumeClaimStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status","description":"partially update status of the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"partially update the specified Pod","kind":"Pod","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]",null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedPodStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/status","description":"partially update status of the specified Pod","kind":"Pod","version":"v1","group":"","action":"patch","tested":true,"conf_tested":false,"tests":["[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]",null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"partially update the specified PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]"]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"partially update the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedReplicationControllerScale","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"partially update scale of the specified ReplicationController","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedReplicationControllerStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status","description":"partially update status of the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"partially update the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedResourceQuotaStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}/status","description":"partially update status of the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"partially update the specified Secret","kind":"Secret","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Secrets should patch a secret [Conformance]"]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"partially update the specified Service","kind":"Service","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"partially update the specified ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]"]},{"release":"1.20.0","endpoint":"patchCoreV1NamespacedServiceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/status","description":"partially update status of the specified Service","kind":"Service","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1NamespaceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/status","description":"partially update status of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"partially update the specified Node","kind":"Node","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"release":"1.20.0","endpoint":"patchCoreV1NodeStatus","level":"stable","category":"core","path":"/api/v1/nodes/{name}/status","description":"partially update status of the specified Node","kind":"Node","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]",null]},{"release":"1.20.0","endpoint":"patchCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"partially update the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoreV1PersistentVolumeStatus","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}/status","description":"partially update status of the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchEventsV1NamespacedEvent","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}","description":"partially update the specified Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]"]},{"release":"1.20.0","endpoint":"patchNetworkingV1IngressClass","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingressclasses/{name}","description":"partially update the specified IngressClass","kind":"IngressClass","version":"v1","group":"networking.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]"]},{"release":"1.20.0","endpoint":"patchNetworkingV1NamespacedIngress","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}","description":"partially update the specified Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"patchNetworkingV1NamespacedIngressStatus","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status","description":"partially update status of the specified Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"patchNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"partially update the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"partially update the specified ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"partially update the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"partially update the specified Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"partially update the specified RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"partially update the specified PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1CSIDriver","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csidrivers/{name}","description":"partially update the specified CSIDriver","kind":"CSIDriver","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"partially update the specified CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"partially update the specified StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"partially update the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1VolumeAttachmentStatus","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}/status","description":"partially update status of the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"read the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]"]},{"release":"1.20.0","endpoint":"readAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"read the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]"]},{"release":"1.20.0","endpoint":"readApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"read the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]"]},{"release":"1.20.0","endpoint":"readApiextensionsV1CustomResourceDefinitionStatus","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status","description":"read status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]"]},{"release":"1.20.0","endpoint":"readApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"read the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]",null]},{"release":"1.20.0","endpoint":"readApiregistrationV1APIServiceStatus","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}/status","description":"read status of the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"read the specified ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"read the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]",null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedDaemonSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status","description":"read status of the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"read the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedDeploymentScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale","description":"read scale of the specified Deployment","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedDeploymentStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status","description":"read status of the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"read the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]",null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedReplicaSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale","description":"read scale of the specified ReplicaSet","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedReplicaSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status","description":"read status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"read the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]",null]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedStatefulSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale","description":"read scale of the specified StatefulSet","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]"]},{"release":"1.20.0","endpoint":"readAppsV1NamespacedStatefulSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status","description":"read status of the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"read the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"read status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"read the specified Job","kind":"Job","version":"v1","group":"batch","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion",null]},{"release":"1.20.0","endpoint":"readBatchV1NamespacedJobStatus","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status","description":"read status of the specified Job","kind":"Job","version":"v1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCertificatesV1CertificateSigningRequest","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}","description":"read the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"readCertificatesV1CertificateSigningRequestApproval","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval","description":"read approval of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"readCertificatesV1CertificateSigningRequestStatus","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status","description":"read status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"readCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"read the specified Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently",null]},{"release":"1.20.0","endpoint":"readCoreV1ComponentStatus","level":"stable","category":"core","path":"/api/v1/componentstatuses/{name}","description":"read the specified ComponentStatus","kind":"ComponentStatus","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"read the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Namespaces [Serial] should patch a Namespace [Conformance]","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"read the specified ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-storage] ConfigMap should be immutable if `immutable` field is set",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"read the specified Endpoints","kind":"Endpoints","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] Services should test the lifecycle of an Endpoint",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"read the specified Event","kind":"Event","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"read the specified LimitRange","kind":"LimitRange","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"read the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedPersistentVolumeClaimStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status","description":"read status of the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"read the specified Pod","kind":"Pod","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","[sig-storage] Volumes ConfigMap should be mountable",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedPodLog","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/log","description":"read log of the specified Pod","kind":"Pod","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedPodStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/status","description":"read status of the specified Pod","kind":"Pod","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"read the specified PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]"]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"read the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedReplicationControllerScale","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"read scale of the specified ReplicationController","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":true,"conf_tested":false,"tests":["[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedReplicationControllerStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status","description":"read status of the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"read the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedResourceQuotaStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}/status","description":"read status of the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"read the specified Secret","kind":"Secret","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Secrets should patch a secret [Conformance]","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"read the specified Service","kind":"Service","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"","[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should provide secure master service  [Conformance]",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"read the specified ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]",null]},{"release":"1.20.0","endpoint":"readCoreV1NamespacedServiceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/status","description":"read status of the specified Service","kind":"Service","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1NamespaceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/status","description":"read status of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"read the specified Node","kind":"Node","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"release":"1.20.0","endpoint":"readCoreV1NodeStatus","level":"stable","category":"core","path":"/api/v1/nodes/{name}/status","description":"read status of the specified Node","kind":"Node","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"read the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"release":"1.20.0","endpoint":"readCoreV1PersistentVolumeStatus","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}/status","description":"read status of the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readEventsV1NamespacedEvent","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}","description":"read the specified Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]"]},{"release":"1.20.0","endpoint":"readNetworkingV1IngressClass","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingressclasses/{name}","description":"read the specified IngressClass","kind":"IngressClass","version":"v1","group":"networking.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]"]},{"release":"1.20.0","endpoint":"readNetworkingV1NamespacedIngress","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}","description":"read the specified Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"readNetworkingV1NamespacedIngressStatus","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status","description":"read status of the specified Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"readNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"read the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"read the specified ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"read the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"read the specified Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"read the specified RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"read the specified PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readStorageV1CSIDriver","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csidrivers/{name}","description":"read the specified CSIDriver","kind":"CSIDriver","version":"v1","group":"storage.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited"]},{"release":"1.20.0","endpoint":"readStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"read the specified CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"read the specified StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","[sig-storage] CSI mock volume storage capacity unlimited","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]",null]},{"release":"1.20.0","endpoint":"readStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"read the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment",null]},{"release":"1.20.0","endpoint":"readStorageV1VolumeAttachmentStatus","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}/status","description":"read status of the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"replace the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]"]},{"release":"1.20.0","endpoint":"replaceAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"replace the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]"]},{"release":"1.20.0","endpoint":"replaceApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"replace the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]"]},{"release":"1.20.0","endpoint":"replaceApiextensionsV1CustomResourceDefinitionStatus","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status","description":"replace status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]",null]},{"release":"1.20.0","endpoint":"replaceApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"replace the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceApiregistrationV1APIServiceStatus","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}/status","description":"replace status of the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"replace the specified ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"replace the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]"]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedDaemonSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status","description":"replace status of the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"replace the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout",null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedDeploymentScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale","description":"replace scale of the specified Deployment","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedDeploymentStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status","description":"replace status of the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"replace the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"put","tested":true,"conf_tested":false,"tests":["[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota",null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedReplicaSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale","description":"replace scale of the specified ReplicaSet","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedReplicaSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status","description":"replace status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"replace the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]"]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedStatefulSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale","description":"replace scale of the specified StatefulSet","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]"]},{"release":"1.20.0","endpoint":"replaceAppsV1NamespacedStatefulSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status","description":"replace status of the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"replace the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"replace status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"replace the specified Job","kind":"Job","version":"v1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceBatchV1NamespacedJobStatus","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status","description":"replace status of the specified Job","kind":"Job","version":"v1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCertificatesV1CertificateSigningRequest","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}","description":"replace the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]"]},{"release":"1.20.0","endpoint":"replaceCertificatesV1CertificateSigningRequestApproval","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval","description":"replace approval of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"replaceCertificatesV1CertificateSigningRequestStatus","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status","description":"replace status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1","group":"certificates.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]",null]},{"release":"1.20.0","endpoint":"replaceCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"replace the specified Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]",null]},{"release":"1.20.0","endpoint":"replaceCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"replace the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]"]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"replace the specified ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-node] ConfigMap should update ConfigMap successfully","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be immutable if `immutable` field is set","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified",null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"replace the specified Endpoints","kind":"Endpoints","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] Services should test the lifecycle of an Endpoint",null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"replace the specified Event","kind":"Event","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"replace the specified LimitRange","kind":"LimitRange","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]"]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"replace the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedPersistentVolumeClaimStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status","description":"replace status of the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"replace the specified Pod","kind":"Pod","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]",null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedPodStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/status","description":"replace status of the specified Pod","kind":"Pod","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]"]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"replace the specified PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"replace the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-network] Services should create endpoints for unready pods"]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedReplicationControllerScale","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"replace scale of the specified ReplicationController","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":true,"conf_tested":false,"tests":["[sig-network] Services should create endpoints for unready pods"]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedReplicationControllerStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status","description":"replace status of the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"replace the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource."]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedResourceQuotaStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}/status","description":"replace status of the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"replace the specified Secret","kind":"Secret","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be immutable if `immutable` field is set"]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"replace the specified Service","kind":"Service","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name"]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"replace the specified ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[sig-auth] ServiceAccounts should ensure a single API token exists",null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespacedServiceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/status","description":"replace status of the specified Service","kind":"Service","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespaceFinalize","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/finalize","description":"replace finalize of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1NamespaceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/status","description":"replace status of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"replace the specified Node","kind":"Node","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]"]},{"release":"1.20.0","endpoint":"replaceCoreV1NodeStatus","level":"stable","category":"core","path":"/api/v1/nodes/{name}/status","description":"replace status of the specified Node","kind":"Node","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"replace the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoreV1PersistentVolumeStatus","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}/status","description":"replace status of the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceEventsV1NamespacedEvent","level":"stable","category":"events","path":"/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}","description":"replace the specified Event","kind":"Event","version":"v1","group":"events.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceNetworkingV1IngressClass","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/ingressclasses/{name}","description":"replace the specified IngressClass","kind":"IngressClass","version":"v1","group":"networking.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]"]},{"release":"1.20.0","endpoint":"replaceNetworkingV1NamespacedIngress","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}","description":"replace the specified Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"replaceNetworkingV1NamespacedIngressStatus","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status","description":"replace status of the specified Ingress","kind":"Ingress","version":"v1","group":"networking.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-network] Ingress API should support creating Ingress API operations [Conformance]"]},{"release":"1.20.0","endpoint":"replaceNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"replace the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"replace the specified ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"replace the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"replace the specified Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"replace the specified RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"replace the specified PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1CSIDriver","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csidrivers/{name}","description":"replace the specified CSIDriver","kind":"CSIDriver","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"replace the specified CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"replace the specified StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"replace the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1VolumeAttachmentStatus","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}/status","description":"replace status of the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations","description":"create a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations","description":"create a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions","description":"create a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices","description":"create an APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAuthenticationV1beta1TokenReview","level":"beta","category":"authentication","path":"/apis/authentication.k8s.io/v1beta1/tokenreviews","description":"create a TokenReview","kind":"TokenReview","version":"v1beta1","group":"authentication.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAuthorizationV1beta1NamespacedLocalSubjectAccessReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/namespaces/{namespace}/localsubjectaccessreviews","description":"create a LocalSubjectAccessReview","kind":"LocalSubjectAccessReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAuthorizationV1beta1SelfSubjectAccessReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/selfsubjectaccessreviews","description":"create a SelfSubjectAccessReview","kind":"SelfSubjectAccessReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAuthorizationV1beta1SelfSubjectRulesReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/selfsubjectrulesreviews","description":"create a SelfSubjectRulesReview","kind":"SelfSubjectRulesReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAuthorizationV1beta1SubjectAccessReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/subjectaccessreviews","description":"create a SubjectAccessReview","kind":"SubjectAccessReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers","description":"create a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers","description":"create a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs","description":"create a CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"post","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently",null]},{"release":"1.20.0","endpoint":"createCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests","description":"create a CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases","description":"create a Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices","description":"create an EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events","description":"create an Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses","description":"create an Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createNetworkingV1beta1IngressClass","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingressclasses","description":"create an IngressClass","kind":"IngressClass","version":"v1beta1","group":"networking.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses","description":"create an Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses","description":"create a RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]"]},{"release":"1.20.0","endpoint":"createPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets","description":"create a PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"post","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status"]},{"release":"1.20.0","endpoint":"createPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies","description":"create a PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"post","tested":true,"conf_tested":true,"tests":["[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]",null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles","description":"create a ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings","description":"create a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles","description":"create a Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings","description":"create a RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses","description":"create a PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers","description":"create a CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes","description":"create a CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses","description":"create a StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments","description":"create a VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations","description":"delete collection of MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations","description":"delete collection of ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"delete a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"delete a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteApiextensionsV1beta1CollectionCustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions","description":"delete collection of CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"delete a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"delete an APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteApiregistrationV1beta1CollectionAPIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices","description":"delete collection of APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers","description":"delete collection of HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"delete a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers","description":"delete collection of HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"delete a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteBatchV1beta1CollectionNamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs","description":"delete collection of CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"delete a CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently"]},{"release":"1.20.0","endpoint":"deleteCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"delete a CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCertificatesV1beta1CollectionCertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests","description":"delete collection of CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoordinationV1beta1CollectionNamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases","description":"delete collection of Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"delete a Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteDiscoveryV1beta1CollectionNamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices","description":"delete collection of EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"delete an EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteEventsV1beta1CollectionNamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events","description":"delete collection of Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"delete an Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteExtensionsV1beta1CollectionNamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses","description":"delete collection of Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"delete an Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNetworkingV1beta1CollectionIngressClass","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingressclasses","description":"delete collection of IngressClass","kind":"IngressClass","version":"v1beta1","group":"networking.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNetworkingV1beta1CollectionNamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses","description":"delete collection of Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNetworkingV1beta1IngressClass","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingressclasses/{name}","description":"delete an IngressClass","kind":"IngressClass","version":"v1beta1","group":"networking.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"delete an Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNodeV1beta1CollectionRuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses","description":"delete collection of RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"delete a RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass"]},{"release":"1.20.0","endpoint":"deletePolicyV1beta1CollectionNamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets","description":"delete collection of PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"deletecollection","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets",null]},{"release":"1.20.0","endpoint":"deletePolicyV1beta1CollectionPodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies","description":"delete collection of PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deletePolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"delete a PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it"]},{"release":"1.20.0","endpoint":"deletePolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"delete a PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"delete a ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"delete a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1CollectionClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles","description":"delete collection of ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1CollectionClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings","description":"delete collection of ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1CollectionNamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles","description":"delete collection of Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings","description":"delete collection of RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"delete a Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"delete a RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteSchedulingV1beta1CollectionPriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses","description":"delete collection of PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"delete a PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1CollectionCSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers","description":"delete collection of CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1CollectionCSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes","description":"delete collection of CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1CollectionStorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses","description":"delete collection of StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1CollectionVolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments","description":"delete collection of VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"delete a CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"delete a CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"delete a StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"delete a VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getAdmissionregistrationV1beta1APIResources","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getApiextensionsV1beta1APIResources","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getApiregistrationV1beta1APIResources","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAuthenticationV1beta1APIResources","level":"beta","category":"authentication","path":"/apis/authentication.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAuthorizationV1beta1APIResources","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAutoscalingV2beta1APIResources","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getAutoscalingV2beta2APIResources","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getBatchV1beta1APIResources","level":"beta","category":"batch","path":"/apis/batch/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getCertificatesV1beta1APIResources","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getCoordinationV1beta1APIResources","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getDiscoveryV1beta1APIResources","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getEventsV1beta1APIResources","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getExtensionsV1beta1APIResources","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getNetworkingV1beta1APIResources","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getNodeV1beta1APIResources","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getPolicyV1beta1APIResources","level":"beta","category":"policy","path":"/apis/policy/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getRbacAuthorizationV1beta1APIResources","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getSchedulingV1beta1APIResources","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getStorageV1beta1APIResources","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"listAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations","description":"list or watch objects of kind MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations","description":"list or watch objects of kind ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions","description":"list or watch objects of kind CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices","description":"list or watch objects of kind APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listBatchV1beta1CronJobForAllNamespaces","level":"beta","category":"batch","path":"/apis/batch/v1beta1/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"list","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-apps] CronJob should delete failed finished jobs with limit of one job","[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob",null]},{"release":"1.20.0","endpoint":"listCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests","description":"list or watch objects of kind CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoordinationV1beta1LeaseForAllNamespaces","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listDiscoveryV1beta1EndpointSliceForAllNamespaces","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/endpointslices","description":"list or watch objects of kind EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices","description":"list or watch objects of kind EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"list","tested":true,"conf_tested":false,"tests":["[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service",null]},{"release":"1.20.0","endpoint":"listEventsV1beta1EventForAllNamespaces","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listExtensionsV1beta1IngressForAllNamespaces","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listNetworkingV1beta1IngressClass","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingressclasses","description":"list or watch objects of kind IngressClass","kind":"IngressClass","version":"v1beta1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listNetworkingV1beta1IngressForAllNamespaces","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses","description":"list or watch objects of kind RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets","description":"list or watch objects of kind PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"list","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets",null]},{"release":"1.20.0","endpoint":"listPolicyV1beta1PodDisruptionBudgetForAllNamespaces","level":"beta","category":"policy","path":"/apis/policy/v1beta1/poddisruptionbudgets","description":"list or watch objects of kind PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"list","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets",null]},{"release":"1.20.0","endpoint":"listPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies","description":"list or watch objects of kind PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] Job should remove pods when job is deleted","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]",null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles","description":"list or watch objects of kind ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings","description":"list or watch objects of kind ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1beta1RoleBindingForAllNamespaces","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1beta1RoleForAllNamespaces","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses","description":"list or watch objects of kind PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers","description":"list or watch objects of kind CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes","description":"list or watch objects of kind CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses","description":"list or watch objects of kind StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments","description":"list or watch objects of kind VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"partially update the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"partially update the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"partially update the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchApiextensionsV1beta1CustomResourceDefinitionStatus","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status","description":"partially update status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"partially update the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchApiregistrationV1beta1APIServiceStatus","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status","description":"partially update status of the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"partially update the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"partially update status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"partially update the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"partially update status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"partially update the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchBatchV1beta1NamespacedCronJobStatus","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status","description":"partially update status of the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"partially update the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCertificatesV1beta1CertificateSigningRequestApproval","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/approval","description":"partially update approval of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCertificatesV1beta1CertificateSigningRequestStatus","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status","description":"partially update status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"partially update the specified Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"partially update the specified EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"partially update the specified Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"partially update the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchExtensionsV1beta1NamespacedIngressStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"partially update status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchNetworkingV1beta1IngressClass","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingressclasses/{name}","description":"partially update the specified IngressClass","kind":"IngressClass","version":"v1beta1","group":"networking.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"partially update the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchNetworkingV1beta1NamespacedIngressStatus","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"partially update status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"partially update the specified RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"partially update the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"patch","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it"]},{"release":"1.20.0","endpoint":"patchPolicyV1beta1NamespacedPodDisruptionBudgetStatus","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status","description":"partially update status of the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"patch","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController should update/patch PodDisruptionBudget status"]},{"release":"1.20.0","endpoint":"patchPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"partially update the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"partially update the specified ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"partially update the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"partially update the specified Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"partially update the specified RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"partially update the specified PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"partially update the specified CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"partially update the specified CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"partially update the specified StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"partially update the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"read the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"read the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"read the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readApiextensionsV1beta1CustomResourceDefinitionStatus","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status","description":"read status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"read the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readApiregistrationV1beta1APIServiceStatus","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status","description":"read status of the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"read the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"read status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"read the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"read status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"read the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"get","tested":true,"conf_tested":false,"tests":["[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently",null]},{"release":"1.20.0","endpoint":"readBatchV1beta1NamespacedCronJobStatus","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status","description":"read status of the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"read the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCertificatesV1beta1CertificateSigningRequestApproval","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/approval","description":"read approval of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCertificatesV1beta1CertificateSigningRequestStatus","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status","description":"read status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"read the specified Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"read the specified EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"read the specified Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"read the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readExtensionsV1beta1NamespacedIngressStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"read status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readNetworkingV1beta1IngressClass","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingressclasses/{name}","description":"read the specified IngressClass","kind":"IngressClass","version":"v1beta1","group":"networking.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"read the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readNetworkingV1beta1NamespacedIngressStatus","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"read status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"read the specified RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass",null]},{"release":"1.20.0","endpoint":"readPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"read the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"get","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status"]},{"release":"1.20.0","endpoint":"readPolicyV1beta1NamespacedPodDisruptionBudgetStatus","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status","description":"read status of the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"get","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should update/patch PodDisruptionBudget status"]},{"release":"1.20.0","endpoint":"readPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"read the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] Job should remove pods when job is deleted","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]",null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"read the specified ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"read the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"read the specified Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"read the specified RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"read the specified PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"read the specified CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"read the specified CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"read the specified StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"read the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"replace the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"replace the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"replace the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceApiextensionsV1beta1CustomResourceDefinitionStatus","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status","description":"replace status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"replace the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceApiregistrationV1beta1APIServiceStatus","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status","description":"replace status of the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"replace the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"replace status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"replace the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"replace status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"replace the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceBatchV1beta1NamespacedCronJobStatus","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status","description":"replace status of the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"replace the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCertificatesV1beta1CertificateSigningRequestApproval","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/approval","description":"replace approval of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCertificatesV1beta1CertificateSigningRequestStatus","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status","description":"replace status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"replace the specified Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"replace the specified EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"replace the specified Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"replace the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceExtensionsV1beta1NamespacedIngressStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"replace status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceNetworkingV1beta1IngressClass","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingressclasses/{name}","description":"replace the specified IngressClass","kind":"IngressClass","version":"v1beta1","group":"networking.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"replace the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceNetworkingV1beta1NamespacedIngressStatus","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"replace status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"replace the specified RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replacePolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"replace the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"put","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it"]},{"release":"1.20.0","endpoint":"replacePolicyV1beta1NamespacedPodDisruptionBudgetStatus","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status","description":"replace status of the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"put","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController should update/patch PodDisruptionBudget status",null]},{"release":"1.20.0","endpoint":"replacePolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"replace the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"replace the specified ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"replace the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"replace the specified Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"replace the specified RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"replace the specified PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"replace the specified CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"replace the specified CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"replace the specified StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"replace the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs","description":"create a CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas","description":"create a FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations","description":"create a PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses","description":"create a RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles","description":"create a ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings","description":"create a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles","description":"create a Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings","description":"create a RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses","description":"create a PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets","description":"create a PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"createStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments","description":"create a VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteBatchV2alpha1CollectionNamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs","description":"delete collection of CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"delete a CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteFlowcontrolApiserverV1alpha1CollectionFlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas","description":"delete collection of FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations","description":"delete collection of PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"delete a FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"delete a PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNodeV1alpha1CollectionRuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses","description":"delete collection of RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"delete a RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"delete a ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"delete a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1CollectionClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles","description":"delete collection of ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings","description":"delete collection of ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1CollectionNamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles","description":"delete collection of Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings","description":"delete collection of RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"delete a Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"delete a RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteSchedulingV1alpha1CollectionPriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses","description":"delete collection of PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"delete a PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteSettingsV1alpha1CollectionNamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets","description":"delete collection of PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"delete a PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1alpha1CollectionVolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments","description":"delete collection of VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"deleteStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"delete a VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getBatchV2alpha1APIResources","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getFlowcontrolApiserverV1alpha1APIResources","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getNodeV1alpha1APIResources","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getRbacAuthorizationV1alpha1APIResources","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"getSchedulingV1alpha1APIResources","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getSettingsV1alpha1APIResources","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"release":"1.20.0","endpoint":"getStorageV1alpha1APIResources","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listBatchV2alpha1CronJobForAllNamespaces","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas","description":"list or watch objects of kind FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations","description":"list or watch objects of kind PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses","description":"list or watch objects of kind RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles","description":"list or watch objects of kind ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings","description":"list or watch objects of kind ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1alpha1RoleBindingForAllNamespaces","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listRbacAuthorizationV1alpha1RoleForAllNamespaces","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses","description":"list or watch objects of kind PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets","description":"list or watch objects of kind PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listSettingsV1alpha1PodPresetForAllNamespaces","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/podpresets","description":"list or watch objects of kind PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"listStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments","description":"list or watch objects of kind VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"partially update the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchBatchV2alpha1NamespacedCronJobStatus","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status","description":"partially update status of the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"partially update the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchFlowcontrolApiserverV1alpha1FlowSchemaStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}/status","description":"partially update status of the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"partially update the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}/status","description":"partially update status of the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"partially update the specified RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"partially update the specified ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"partially update the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"partially update the specified Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"partially update the specified RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"partially update the specified PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"partially update the specified PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"patchStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"partially update the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"read the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readBatchV2alpha1NamespacedCronJobStatus","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status","description":"read status of the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"read the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readFlowcontrolApiserverV1alpha1FlowSchemaStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}/status","description":"read status of the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"read the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}/status","description":"read status of the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"read the specified RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"read the specified ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"read the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"read the specified Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"read the specified RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"read the specified PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"read the specified PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"readStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"read the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"replace the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceBatchV2alpha1NamespacedCronJobStatus","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status","description":"replace status of the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"replace the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceFlowcontrolApiserverV1alpha1FlowSchemaStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}/status","description":"replace status of the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"replace the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}/status","description":"replace status of the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"replace the specified RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"replace the specified ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"replace the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"replace the specified Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"replace the specified RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"replace the specified PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"replace the specified PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"release":"1.20.0","endpoint":"replaceStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"replace the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]}],"tests":[{"release":"1.20.0","test":"","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod Lifecycle, post start exec hook","file":"test/e2e/common/lifecycle_hook.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod Lifecycle, post start http hook","file":"test/e2e/common/lifecycle_hook.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod Lifecycle, prestop exec hook","file":"test/e2e/common/lifecycle_hook.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod Lifecycle, prestop http hook","file":"test/e2e/common/lifecycle_hook.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","conformance_test":true,"testname":"Container Runtime, TerminationMessage, from log output of succeeding container","file":"test/e2e/common/runtime.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","conformance_test":true,"testname":"Container Runtime, TerminationMessage, from file of succeeding container","file":"test/e2e/common/runtime.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","conformance_test":true,"testname":"Container Runtime, TerminationMessage, from container's log output of failing container","file":"test/e2e/common/runtime.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","conformance_test":true,"testname":"Container Runtime, TerminationMessagePath, non-root user and non-default path","file":"test/e2e/common/runtime.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","conformance_test":true,"testname":"Container Runtime, Restart Policy, Pod Phases","file":"test/e2e/common/runtime.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","conformance_test":true,"testname":"Docker containers, with arguments","file":"test/e2e/common/docker_containers.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","conformance_test":true,"testname":"Docker containers, with command and arguments","file":"test/e2e/common/docker_containers.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","conformance_test":true,"testname":"Docker containers, with command","file":"test/e2e/common/docker_containers.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","conformance_test":true,"testname":"Docker containers, without command and arguments","file":"test/e2e/common/docker_containers.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","conformance_test":true,"testname":"init-container-starts-app-restartalways-pod","file":"test/e2e/common/init_container.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","conformance_test":true,"testname":"init-container-starts-app-restartnever-pod","file":"test/e2e/common/init_container.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","conformance_test":true,"testname":"init-container-fails-stops-app-restartnever-pod","file":"test/e2e/common/init_container.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","conformance_test":true,"testname":"init-container-fails-stops-app-restartalways-pod","file":"test/e2e/common/init_container.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Kubelet, managed etc hosts","file":"test/e2e/common/kubelet_etc_hosts.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","conformance_test":true,"testname":"Kubelet, log output, default","file":"test/e2e/common/kubelet.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","conformance_test":true,"testname":"Kubelet, failed pod, delete","file":"test/e2e/common/kubelet.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","conformance_test":true,"testname":"Kubelet, failed pod, terminated reason","file":"test/e2e/common/kubelet.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Kubelet, hostAliases","file":"test/e2e/common/kubelet.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Kubelet, pod with read only root file system","file":"test/e2e/common/kubelet.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] Lease lease API should be available [Conformance]","conformance_test":true,"testname":"lease API should be available","file":"test/e2e/common/lease.go","promotion_release":"1.17.0"},{"release":"1.20.0","test":"[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pods, ActiveDeadlineSeconds","file":"test/e2e/common/pods.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pods, lifecycle","file":"test/e2e/common/pods.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Pods should be updated [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pods, update","file":"test/e2e/common/pods.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pods, service environment variables","file":"test/e2e/common/pods.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Pods should delete a collection of pods","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pods, assigned hostip","file":"test/e2e/common/pods.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pods, remote command execution over websocket","file":"test/e2e/common/pods.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pods, logs from websockets","file":"test/e2e/common/pods.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod liveness probe, using local file, restart","file":"test/e2e/common/container_probe.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod liveness probe, using http endpoint, restart","file":"test/e2e/common/container_probe.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Probing container should be restarted with a local redirect http liveness probe","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod liveness probe, using http endpoint, multiple restarts (slow)","file":"test/e2e/common/container_probe.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod liveness probe, using local file, no restart","file":"test/e2e/common/container_probe.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod liveness probe, using http endpoint, failure","file":"test/e2e/common/container_probe.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod liveness probe, using tcp socket, no restart","file":"test/e2e/common/container_probe.go","promotion_release":"1.18.0"},{"release":"1.20.0","test":"[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod readiness probe, with initial delay","file":"test/e2e/common/container_probe.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","conformance_test":true,"testname":"Pod readiness probe, failure","file":"test/e2e/common/container_probe.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Security Context, runAsUser=65534","file":"test/e2e/common/security_context.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Security Context, privileged=false.","file":"test/e2e/common/security_context.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","conformance_test":true,"testname":"Security Context, readOnlyRootFilesystem=false.","file":"test/e2e/common/security_context.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Security Context, allowPrivilegeEscalation=false.","file":"test/e2e/common/security_context.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] crictl should be able to run crictl on the node","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","conformance_test":true,"testname":"Pod events, verify event from Scheduler and Kubelet","file":"test/e2e/node/events.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds [Disruptive] [Conformance]","conformance_test":true,"testname":"Pod Eviction, Toleration limits","file":"test/e2e/node/taints.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[k8s.io] [sig-node] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction [Disruptive] [Conformance]","conformance_test":true,"testname":"Taint, Pod Eviction on taint removal","file":"test/e2e/node/taints.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","conformance_test":true,"testname":"Pods, QOS","file":"test/e2e/node/pods.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","conformance_test":true,"testname":"Pods, prestop hook","file":"test/e2e/node/pre_stop.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","conformance_test":true,"testname":"Environment variables, expansion","file":"test/e2e/common/expansion.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","conformance_test":true,"testname":"Environment variables, command argument expansion","file":"test/e2e/common/expansion.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","conformance_test":true,"testname":"Environment variables, command expansion","file":"test/e2e/common/expansion.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","conformance_test":true,"testname":"VolumeSubpathEnvExpansion, subpath expansion","file":"test/e2e/common/expansion.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][Slow] [Conformance]","conformance_test":true,"testname":"VolumeSubpathEnvExpansion, subpath with absolute path","file":"test/e2e/common/expansion.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][Slow] [Conformance]","conformance_test":true,"testname":"VolumeSubpathEnvExpansion, subpath with backticks","file":"test/e2e/common/expansion.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][Slow] [Conformance]","conformance_test":true,"testname":"VolumeSubpathEnvExpansion, subpath test writes","file":"test/e2e/common/expansion.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][Slow] [Conformance]","conformance_test":true,"testname":"VolumeSubpathEnvExpansion, subpath ready from failed state","file":"test/e2e/common/expansion.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","conformance_test":true,"testname":"Admission webhook, list mutating webhooks","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","conformance_test":true,"testname":"Admission webhook, list validating webhooks","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","conformance_test":true,"testname":"Admission webhook, update mutating webhook","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","conformance_test":true,"testname":"Admission webhook, update validating webhook","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","conformance_test":true,"testname":"Admission webhook, deny attach","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","conformance_test":true,"testname":"Admission webhook, deny custom resource create and delete","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","conformance_test":true,"testname":"Admission webhook, deny create","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","conformance_test":true,"testname":"Admission webhook, deny custom resource definition","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","conformance_test":true,"testname":"Admission webhook, honor timeout","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","conformance_test":true,"testname":"Admission webhook, discovery document","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","conformance_test":true,"testname":"Admission webhook, ordered mutation","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","conformance_test":true,"testname":"Admission webhook, mutate custom resource","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","conformance_test":true,"testname":"Admission webhook, mutate custom resource with different stored version","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","conformance_test":true,"testname":"Admission webhook, mutate custom resource with pruning","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","conformance_test":true,"testname":"Admission webhook, mutation with defaulting","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","conformance_test":true,"testname":"Admission webhook, admission control not allowed on webhook configuration objects","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","conformance_test":true,"testname":"Admission webhook, fail closed","file":"test/e2e/apimachinery/webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","conformance_test":true,"testname":"aggregator-supports-the-sample-apiserver","file":"test/e2e/apimachinery/aggregator.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","conformance_test":true,"testname":"Custom Resource Definition Conversion Webhook, convert mixed version list","file":"test/e2e/apimachinery/crd_conversion_webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","conformance_test":true,"testname":"Custom Resource Definition Conversion Webhook, conversion custom resource","file":"test/e2e/apimachinery/crd_conversion_webhook.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","conformance_test":true,"testname":"Custom Resource Definition, defaulting","file":"test/e2e/apimachinery/custom_resource_definition.go","promotion_release":"1.17.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","conformance_test":true,"testname":"Custom Resource Definition, discovery","file":"test/e2e/apimachinery/custom_resource_definition.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","conformance_test":true,"testname":"Custom Resource Definition, create","file":"test/e2e/apimachinery/custom_resource_definition.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","conformance_test":true,"testname":"Custom Resource Definition, status sub-resource","file":"test/e2e/apimachinery/custom_resource_definition.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","conformance_test":true,"testname":"Custom Resource Definition, list","file":"test/e2e/apimachinery/custom_resource_definition.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","conformance_test":true,"testname":"Custom Resource Definition, watch","file":"test/e2e/apimachinery/crd_watch.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, stop serving version","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, version rename","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, with x-preserve-unknown-fields at root","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, with x-preserve-unknown-fields in embedded object","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, with x-preserve-unknown-fields in object","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, with validation schema","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, varying groups","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, varying kinds","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","conformance_test":true,"testname":"Custom Resource OpenAPI Publish, varying versions","file":"test/e2e/apimachinery/crd_publish_openapi.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] Discovery Custom resource should have storage version hash","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Discovery should validate PreferredVersion for each APIGroup","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Events should delete a collection of events [Conformance]","conformance_test":true,"testname":"Event, delete a collection","file":"test/e2e/apimachinery/events.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","conformance_test":true,"testname":"Event resource lifecycle","file":"test/e2e/apimachinery/events.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","conformance_test":true,"testname":"Garbage Collector, delete replication controller, propagation policy background","file":"test/e2e/apimachinery/garbage_collector.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","conformance_test":true,"testname":"Garbage Collector, delete deployment,  propagation policy background","file":"test/e2e/apimachinery/garbage_collector.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","conformance_test":true,"testname":"Garbage Collector, delete replication controller, after owned pods","file":"test/e2e/apimachinery/garbage_collector.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","conformance_test":true,"testname":"Garbage Collector, dependency cycle","file":"test/e2e/apimachinery/garbage_collector.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","conformance_test":true,"testname":"Garbage Collector, multiple owners","file":"test/e2e/apimachinery/garbage_collector.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","conformance_test":true,"testname":"Garbage Collector, delete replication controller, propagation policy orphan","file":"test/e2e/apimachinery/garbage_collector.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","conformance_test":true,"testname":"Garbage Collector, delete deployment, propagation policy orphan","file":"test/e2e/apimachinery/garbage_collector.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Namespaces [Serial] should ensure that all pods are removed when a namespace is deleted [Conformance]","conformance_test":true,"testname":"namespace-deletion-removes-pods","file":"test/e2e/apimachinery/namespace.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Namespaces [Serial] should ensure that all services are removed when a namespace is deleted [Conformance]","conformance_test":true,"testname":"namespace-deletion-removes-services","file":"test/e2e/apimachinery/namespace.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Namespaces [Serial] should patch a Namespace [Conformance]","conformance_test":true,"testname":"Namespace patching","file":"test/e2e/apimachinery/namespace.go","promotion_release":"1.18.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","conformance_test":true,"testname":"ResourceQuota, update and delete","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","conformance_test":true,"testname":"ResourceQuota, object count quota, configmap","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","conformance_test":true,"testname":"ResourceQuota, object count quota, pod","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","conformance_test":true,"testname":"ResourceQuota, object count quota, replicaSet","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","conformance_test":true,"testname":"ResourceQuota, object count quota, replicationController","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","conformance_test":true,"testname":"ResourceQuota, object count quota, secret","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","conformance_test":true,"testname":"ResourceQuota, object count quota, service","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","conformance_test":true,"testname":"ResourceQuota, object count quota, resourcequotas","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","conformance_test":true,"testname":"ResourceQuota, quota scope, BestEffort and NotBestEffort scope","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","conformance_test":true,"testname":"ResourceQuota, quota scope, Terminating and NotTerminating scope","file":"test/e2e/apimachinery/resource_quota.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets, pod environment field","file":"test/e2e/common/secrets.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets, pod environment from source","file":"test/e2e/common/secrets.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","conformance_test":true,"testname":"Secrets, with empty-key","file":"test/e2e/common/secrets.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-api-machinery] Secrets should patch a secret [Conformance]","conformance_test":true,"testname":"Secret patching","file":"test/e2e/common/secrets.go","promotion_release":"1.18.0"},{"release":"1.20.0","test":"[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","conformance_test":true,"testname":"API metadata HTTP return","file":"test/e2e/apimachinery/table_conversion.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] Servers with support for Table transformation should return pod details","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-api-machinery] server version should find the server version [Conformance]","conformance_test":true,"testname":"Confirm a server version","file":"test/e2e/apimachinery/server_version.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","conformance_test":true,"testname":"watch-configmaps-closed-and-restarted","file":"test/e2e/apimachinery/watch.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","conformance_test":true,"testname":"watch-configmaps-from-resource-version","file":"test/e2e/apimachinery/watch.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","conformance_test":true,"testname":"watch-configmaps-with-multiple-watchers","file":"test/e2e/apimachinery/watch.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","conformance_test":true,"testname":"watch-configmaps-label-changed","file":"test/e2e/apimachinery/watch.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","conformance_test":true,"testname":"watch-consistency","file":"test/e2e/apimachinery/watch.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-apps] CronJob should delete failed finished jobs with limit of one job","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] CronJob should not emit unexpected warnings","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] CronJob should remove from active list jobs that have been deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] CronJob should replace jobs when ReplaceConcurrent","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] CronJob should schedule multiple jobs concurrently","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Daemon set [Serial] should retry creating failed daemon pods [Conformance]","conformance_test":true,"testname":"DaemonSet-FailedPodCreation","file":"test/e2e/apps/daemon_set.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Daemon set [Serial] should rollback without unnecessary restarts [Conformance]","conformance_test":true,"testname":"DaemonSet-Rollback","file":"test/e2e/apps/daemon_set.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Daemon set [Serial] should run and stop complex daemon [Conformance]","conformance_test":true,"testname":"DaemonSet-NodeSelection","file":"test/e2e/apps/daemon_set.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Daemon set [Serial] should run and stop simple daemon [Conformance]","conformance_test":true,"testname":"DaemonSet-Creation","file":"test/e2e/apps/daemon_set.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Daemon set [Serial] should update pod when spec was updated and update strategy is RollingUpdate [Conformance]","conformance_test":true,"testname":"DaemonSet-RollingUpdate","file":"test/e2e/apps/daemon_set.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Deployment deployment should delete old replica sets [Conformance]","conformance_test":true,"testname":"Deployment RevisionHistoryLimit","file":"test/e2e/apps/deployment.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Deployment deployment should support proportional scaling [Conformance]","conformance_test":true,"testname":"Deployment Proportional Scaling","file":"test/e2e/apps/deployment.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Deployment deployment should support rollover [Conformance]","conformance_test":true,"testname":"Deployment Rollover","file":"test/e2e/apps/deployment.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Deployment iterative rollouts should eventually progress","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","conformance_test":true,"testname":"Deployment Recreate","file":"test/e2e/apps/deployment.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","conformance_test":true,"testname":"Deployment RollingUpdate","file":"test/e2e/apps/deployment.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController should create a PodDisruptionBudget","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","conformance_test":true,"testname":"Jobs, orphan pods, re-adoption","file":"test/e2e/apps/job.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-apps] Job should delete a job [Conformance]","conformance_test":true,"testname":"Jobs, active pods, graceful termination","file":"test/e2e/apps/job.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-apps] Job should fail to exceed backoffLimit","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Job should fail when exceeds active deadline","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Job should remove pods when job is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","conformance_test":true,"testname":"Jobs, completion after task failure","file":"test/e2e/apps/job.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] Job should run a job to completion when tasks succeed","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","conformance_test":true,"testname":"Replica Set, adopt matching pods and release non matching pods","file":"test/e2e/apps/replica_set.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","conformance_test":true,"testname":"Replica Set, run basic image","file":"test/e2e/apps/replica_set.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","conformance_test":true,"testname":"Replication Controller, adopt matching pods","file":"test/e2e/apps/rc.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[sig-apps] ReplicationController should release no longer matching pods [Conformance]","conformance_test":true,"testname":"Replication Controller, release pods","file":"test/e2e/apps/rc.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[sig-apps] ReplicationController should serve a basic image on each replica with a private image","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","conformance_test":true,"testname":"Replication Controller, run basic image","file":"test/e2e/apps/rc.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","conformance_test":true,"testname":"Replication Controller, check for issues like exceeding allocated quota","file":"test/e2e/apps/rc.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Slow] [Conformance]","conformance_test":true,"testname":"StatefulSet, Burst Scaling","file":"test/e2e/apps/statefulset.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Slow] [Conformance]","conformance_test":true,"testname":"StatefulSet, Scaling","file":"test/e2e/apps/statefulset.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","conformance_test":true,"testname":"StatefulSet resource Replica scaling","file":"test/e2e/apps/statefulset.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","conformance_test":true,"testname":"StatefulSet, Rolling Update with Partition","file":"test/e2e/apps/statefulset.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","conformance_test":true,"testname":"StatefulSet, Rolling Update","file":"test/e2e/apps/statefulset.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","conformance_test":true,"testname":"StatefulSet, Recreate Failed Pod","file":"test/e2e/apps/statefulset.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","conformance_test":true,"testname":"CertificateSigningRequest API","file":"test/e2e/auth/certificates.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","conformance_test":true,"testname":"Service account tokens auto mount optionally","file":"test/e2e/auth/service_accounts.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-auth] ServiceAccounts should ensure a single API token exists","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","conformance_test":true,"testname":"Service Account Tokens Must AutoMount","file":"test/e2e/auth/service_accounts.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","conformance_test":true,"testname":"ServiceAccount lifecycle test","file":"test/e2e/auth/service_accounts.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","conformance_test":true,"testname":"Kubectl, guestbook application","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","conformance_test":true,"testname":"Kubectl, check version v1","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","conformance_test":true,"testname":"Kubectl, cluster info","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","conformance_test":true,"testname":"Kubectl, describe pod or rc","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","conformance_test":true,"testname":"Kubectl, diff Deployment","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","conformance_test":true,"testname":"Kubectl, create service, replication controller","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","conformance_test":true,"testname":"Kubectl, label update","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","conformance_test":true,"testname":"Kubectl, logs","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","conformance_test":true,"testname":"Kubectl, patch to annotate","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","conformance_test":true,"testname":"Kubectl, replace","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","conformance_test":true,"testname":"Kubectl, run pod","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","conformance_test":true,"testname":"Kubectl, server-side dry-run Pod","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","conformance_test":true,"testname":"Kubectl, version","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Proxy server should support","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Proxy server should support proxy with","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should contain last line of the log","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should handle in-cluster config","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should return command exit codes","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should support exec","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should support exec using resource/name","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should support inline execution and attach","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Simple pod should support port-forward","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","conformance_test":true,"testname":"Kubectl, replication controller","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","conformance_test":true,"testname":"Kubectl, scale replication controller","file":"test/e2e/kubectl/kubectl.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-instrumentation] Events API should delete a collection of events [Conformance]","conformance_test":true,"testname":"New Event resource lifecycle, testing a list of events","file":"test/e2e/instrumentation/events.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-instrumentation] Events API should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","conformance_test":true,"testname":"New Event resource lifecycle, testing a single event","file":"test/e2e/instrumentation/events.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] DNS should provide DNS for ExternalName services [Conformance]","conformance_test":true,"testname":"DNS, for ExternalName Services","file":"test/e2e/network/dns.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","conformance_test":true,"testname":"DNS, resolve the hostname","file":"test/e2e/network/dns.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","conformance_test":true,"testname":"DNS, resolve the subdomain","file":"test/e2e/network/dns.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-network] DNS should provide DNS for services  [Conformance]","conformance_test":true,"testname":"DNS, services","file":"test/e2e/network/dns.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] DNS should provide DNS for the cluster  [Conformance]","conformance_test":true,"testname":"DNS, cluster","file":"test/e2e/network/dns.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","conformance_test":true,"testname":"DNS, cluster","file":"test/e2e/network/dns.go","promotion_release":"1.14.0"},{"release":"1.20.0","test":"[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","conformance_test":true,"testname":"DNS, PQDN for services","file":"test/e2e/network/dns.go","promotion_release":"1.17.0"},{"release":"1.20.0","test":"[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","conformance_test":true,"testname":"DNS, custom dnsConfig","file":"test/e2e/network/dns.go","promotion_release":"1.17.0"},{"release":"1.20.0","test":"[sig-network] DNS should support configurable pod resolv.conf","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] EndpointSliceMirroring should mirror a custom Endpoints resource through create update and delete","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Firewall rule should have correct firewall rules for e2e cluster","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Ingress API should support creating Ingress API operations [Conformance]","conformance_test":true,"testname":"Ingress API","file":"test/e2e/network/ingress.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","conformance_test":true,"testname":"IngressClass API","file":"test/e2e/network/ingressclass.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","conformance_test":true,"testname":"Networking, intra pod http","file":"test/e2e/common/networking.go","promotion_release":"1.18.0"},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","conformance_test":true,"testname":"Networking, intra pod udp","file":"test/e2e/common/networking.go","promotion_release":"1.18.0"},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Networking, intra pod http, from node","file":"test/e2e/common/networking.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Networking, intra pod http, from node","file":"test/e2e/common/networking.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for node-Service: http","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for node-Service: udp","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for pod-Service: http","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should update endpoints: http","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking Granular Checks: Services should update endpoints: udp","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking should check kube-proxy urls","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","conformance_test":true,"testname":"Proxy, logs service endpoint","file":"test/e2e/network/proxy.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] Service endpoints latency should not be very high  [Conformance]","conformance_test":true,"testname":"Service endpoint latency, thresholds","file":"test/e2e/network/service_latency.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] Services should allow pods to hairpin back to themselves through services","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","conformance_test":true,"testname":"Service, change type, ClusterIP to ExternalName","file":"test/e2e/network/service.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","conformance_test":true,"testname":"Service, change type, ExternalName to ClusterIP","file":"test/e2e/network/service.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","conformance_test":true,"testname":"Service, change type, ExternalName to NodePort","file":"test/e2e/network/service.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","conformance_test":true,"testname":"Service, change type, NodePort to ExternalName","file":"test/e2e/network/service.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-network] Services should be able to create a functioning NodePort service [Conformance]","conformance_test":true,"testname":"Service, NodePort Service","file":"test/e2e/network/service.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","conformance_test":true,"testname":"Service, NodePort type, session affinity to None","file":"test/e2e/network/service.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","conformance_test":true,"testname":"Service, ClusterIP type, session affinity to None","file":"test/e2e/network/service.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] Services should be able to up and down services","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should be rejected when no endpoints exist","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should check NodePort out-of-range","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should create endpoints for unready pods","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should find a service from listing all namespaces [Conformance]","conformance_test":true,"testname":"Find Kubernetes Service in default Namespace","file":"test/e2e/network/service.go","promotion_release":"1.18.0"},{"release":"1.20.0","test":"[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","conformance_test":true,"testname":"Service, NodePort type, session affinity to ClientIP with timeout","file":"test/e2e/network/service.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","conformance_test":true,"testname":"Service, ClusterIP type, session affinity to ClientIP with timeout","file":"test/e2e/network/service.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","conformance_test":true,"testname":"Service, NodePort type, session affinity to ClientIP","file":"test/e2e/network/service.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","conformance_test":true,"testname":"Service, ClusterIP type, session affinity to ClientIP","file":"test/e2e/network/service.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-network] Services should implement service.kubernetes.io/headless","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should implement service.kubernetes.io/service-proxy-name","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should prevent NodePort collisions","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should provide secure master service  [Conformance]","conformance_test":true,"testname":"Kubernetes Service","file":"test/e2e/network/service.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] Services should release NodePorts on delete","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-network] Services should serve a basic endpoint from pods  [Conformance]","conformance_test":true,"testname":"Service, endpoints","file":"test/e2e/network/service.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] Services should serve multiport endpoints from pods  [Conformance]","conformance_test":true,"testname":"Service, endpoints with multiple ports","file":"test/e2e/network/service.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-network] Services should test the lifecycle of an Endpoint","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap, from environment field","file":"test/e2e/common/configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap, from environment variables","file":"test/e2e/common/configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","conformance_test":true,"testname":"ConfigMap, with empty-key","file":"test/e2e/common/configmap.go","promotion_release":"1.14.0"},{"release":"1.20.0","test":"[sig-node] ConfigMap should run through a ConfigMap lifecycle [Conformance]","conformance_test":true,"testname":"ConfigMap lifecycle","file":"test/e2e/common/configmap.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-node] ConfigMap should update ConfigMap successfully","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI, environment for CPU and memory limits and requests","file":"test/e2e/common/downward_api.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI, environment for default CPU and memory limits and requests","file":"test/e2e/common/downward_api.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI, environment for host ip","file":"test/e2e/common/downward_api.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI, environment for name, namespace and ip","file":"test/e2e/common/downward_api.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI, environment for Pod UID","file":"test/e2e/common/downward_api.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-node] PodTemplates should delete a collection of pod templates [Conformance]","conformance_test":true,"testname":"PodTemplate, delete a collection","file":"test/e2e/common/podtemplates.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","conformance_test":true,"testname":"PodTemplate lifecycle","file":"test/e2e/common/podtemplates.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","conformance_test":true,"testname":"LimitRange, resources","file":"test/e2e/scheduling/limit_range.go","promotion_release":"1.18.0"},{"release":"1.20.0","test":"[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPredicates [Serial] validates resource limits of pods that are allowed to run  [Conformance]","conformance_test":true,"testname":"Scheduler, resource limits","file":"test/e2e/scheduling/predicates.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if matching  [Conformance]","conformance_test":true,"testname":"Scheduler, node selector matching","file":"test/e2e/scheduling/predicates.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPredicates [Serial] validates that NodeSelector is respected if not matching  [Conformance]","conformance_test":true,"testname":"Scheduler, node selector not matching","file":"test/e2e/scheduling/predicates.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP [Conformance]","conformance_test":true,"testname":"Scheduling, HostPort and Protocol match, HostIPs different but one is default HostIP (0.0.0.0)","file":"test/e2e/scheduling/predicates.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol [Conformance]","conformance_test":true,"testname":"Scheduling, HostPort matching and HostIP and Protocol not-matching","file":"test/e2e/scheduling/predicates.go","promotion_release":"1.16.0"},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPreemption [Serial] PreemptionExecutionPath runs ReplicaSets to verify preemption running path [Conformance]","conformance_test":true,"testname":"Pod preemption verification","file":"test/e2e/scheduling/preemption.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works [Conformance]","conformance_test":true,"testname":"Scheduler, Basic Preemption","file":"test/e2e/scheduling/preemption.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod [Conformance]","conformance_test":true,"testname":"Scheduler, Preemption for critical pod","file":"test/e2e/scheduling/preemption.go","promotion_release":"1.19.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, text data, binary data","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, create, update and delete","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, without mapping, non-root user","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, without mapping","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, without mapping, volume mode set","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, with mapping, volume mode set","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, with mapping, non-root user","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, with mapping","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, multiple volume maps","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] ConfigMap should be immutable if `immutable` field is set","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"ConfigMap Volume, update","file":"test/e2e/common/configmap_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI mock volume storage capacity unlimited","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read-only inline ephemeral volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should create read/write inline ephemeral volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support multiple inline ephemeral volumes","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: CSI Ephemeral-volume (default fs)] ephemeral should support two pods which share the same volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, CPU limits","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, CPU request","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, memory limits","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, memory request","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, CPU limit, default node allocatable","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, memory limit, default node allocatable","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, pod name","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, volume mode 0400","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, file mode 0400","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, update annotations","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","conformance_test":true,"testname":"DownwardAPI volume, update label","file":"test/e2e/common/downwardapi_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","conformance_test":true,"testname":"EmptyDir, Shared volumes between containers","file":"test/e2e/common/empty_dir.go","promotion_release":"1.15.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium default, volume mode 0644","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium memory, volume mode 0644, non-root user","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium default, volume mode 0666","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium memory, volume mode 0666,, non-root user","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium default, volume mode 0777","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium memory, volume mode 0777, non-root user","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium default, volume mode 0644","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium memory, volume mode 0644","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium default, volume mode 0666","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium memory, volume mode 0666","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium default, volume mode 0777","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium memory, volume mode 0777","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium default, volume mode default","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"EmptyDir, medium memory, volume mode default","file":"test/e2e/common/empty_dir.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for configmaps [Serial] [Conformance]","conformance_test":true,"testname":"EmptyDir Wrapper Volume, ConfigMap volumes, no race","file":"test/e2e/storage/empty_dir_wrapper.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","conformance_test":true,"testname":"EmptyDir Wrapper Volume, Secret and ConfigMap volumes, no conflict","file":"test/e2e/storage/empty_dir_wrapper.go","promotion_release":"1.13.0"},{"release":"1.20.0","test":"[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Flexvolumes should be mountable when non-attachable","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] GCP Volumes GlusterFS should be mountable","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] HostPath should support r/w [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] HostPath should support subPath [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Mounted volume expand Should verify mounted devices can be resized","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Pod Disks should be able to delete a non-existent PD without error","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, multiple projections","file":"test/e2e/common/projected_combined.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, create, update and delete","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, non-root user","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, volume mode default","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, volume mode 0400","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, mapped, volume mode 0400","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, mapped, non-root user","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, mapped","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, multiple volume paths","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, ConfigMap, update","file":"test/e2e/common/projected_configmap.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, CPU limits","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, CPU request","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, memory limits","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, memory request","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, CPU limit, node allocatable","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, memory limit, node allocatable","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, pod name","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, volume mode 0400","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, volume mode 0400","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, update annotation","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, DownwardAPI, update labels","file":"test/e2e/common/projected_downwardapi.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, Secrets, create, update delete","file":"test/e2e/common/projected_secret.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Project Volume, Secrets, non-root, custom fsGroup","file":"test/e2e/common/projected_secret.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, Secrets, volume mode default","file":"test/e2e/common/projected_secret.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, Secrets, volume mode 0400","file":"test/e2e/common/projected_secret.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, Secrets, mapped, volume mode 0400","file":"test/e2e/common/projected_secret.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, Secrets, mapped","file":"test/e2e/common/projected_secret.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","conformance_test":true,"testname":"Projected Volume, Secrets, mapped, multiple paths","file":"test/e2e/common/projected_secret.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, create, update and delete","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, volume mode default, secret with same name in different namespace","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, volume mode 0440, fsGroup 1001 and uid 1000","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, default","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, volume mode 0400","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, mapping, volume mode 0400","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, mapping","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","conformance_test":true,"testname":"Secrets Volume, mapping multiple volume paths","file":"test/e2e/common/secrets_volume.go","promotion_release":"1.9.0"},{"release":"1.20.0","test":"[sig-storage] Secrets should be immutable if `immutable` field is set","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","conformance_test":true,"testname":"SubPath: Reading content from a configmap volume.","file":"test/e2e/storage/subpath.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","conformance_test":true,"testname":"SubPath: Reading content from a configmap volume.","file":"test/e2e/storage/subpath.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","conformance_test":true,"testname":"SubPath: Reading content from a downwardAPI volume.","file":"test/e2e/storage/subpath.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","conformance_test":true,"testname":"SubPath: Reading content from a projected volume.","file":"test/e2e/storage/subpath.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","conformance_test":true,"testname":"SubPath: Reading content from a secret volume.","file":"test/e2e/storage/subpath.go","promotion_release":"1.12.0"},{"release":"1.20.0","test":"[sig-storage] Subpath Container restart should verify that container can restart successfully after configmaps modified","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Volume limits should verify that all nodes have volume limits","conformance_test":false,"testname":null,"file":null,"promotion_release":null},{"release":"1.20.0","test":"[sig-storage] Volumes ConfigMap should be mountable","conformance_test":false,"testname":null,"file":null,"promotion_release":null}]}

#+TITLE: App.org
#+TODO: IDEA(i) TODO(t) NEXT(n) IN-PROGRESS(p) BLOCKED(b) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+PROPERTY: header-args:js :results silent :noweb yes

* Architecture
  - create-react-app as beginning boilerplate
  - redux-bundler
  - react
  - tachyons
  - pull everything from jsons inside =/data=
* Index.js
  :PROPERTIES:
  :header-args: :tangle ./src/index.js
  :END:
 #+NAME: index.js
 #+BEGIN_SRC js
   import React from 'react'
   import { render } from 'react-dom'
   import './index.css'

   import { Provider } from 'redux-bundler-react'

   import App from './components/app'
   import createStore from './bundles'
   var store = createStore()

   document.title = 'APISnoop | ' // + store.getState().routing.release

   render(
       <Provider store={store}>
       <App />
       </Provider>,
     document.getElementById('root')
   )
 #+END_SRC
* Components
** App
    :PROPERTIES:
    :header-args: :tangle ./src/components/app.js
    :END:
    the initiatory component.  This is sort of the standard layout in which all other views are placed within.
    #+Name: App.js
    #+BEGIN_SRC js
      import React from 'react'
      import navHelper from 'internal-nav-helper'
      import { connect } from 'redux-bundler-react'

      import Header from './header'
      import Footer from './footer'
      import MainPage from '../pages/main-page'

      export default connect(
        () => {
          return (
              <div>
              <Header />
              <MainPage />
              <Footer />
              </div>
          )
        }
      )
    #+END_SRC

    #+Name: App.js Original
    #+BEGIN_EXAMPLE js
      import React from 'react'
      import navHelper from 'internal-nav-helper'
      import { connect } from 'redux-bundler-react'

      import Header from './header'
      import Footer from './footer'

      export default connect(
        'selectMasterRelease',
        'selectRouteInfo',
        'doUpdateUrl',
        'selectRoute',
        ({ masterRelease, routeInfo, doUpdateUrl, route }) => {
          const CurrentPage = route
          if (masterRelease && routeInfo.url === '/') {
            doUpdateUrl(`/${masterRelease.name}`)
          }
          return (
              <div onClick={navHelper(doUpdateUrl)}>
              <Header />
              <CurrentPage />
              <Footer />
              </div>
          )
        }
      )
    #+END_EXAMPLE
** Header
    :PROPERTIES:
    :header-args: :tangle ./src/components/header.js
    :END:
   #+NAME: Header
   #+BEGIN_SRC js
import React from 'react'

export default () => (
    <header className='flex flex-row pt2 pb2 pl4 pr4 h3_5 items-center justify-between bg-light-gray black shadow-3'>
      <div id='logo' className= 'flex flex-wrap items-center'>
      <img className='h2' src='./assets/apisnoop_logo_v1.png' alt='logo for apisnoop, a magnifying glass with a sunburst graph inside.' />
      <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
      </div>
      <div id='source-code' className='flex items-center'>
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fillRule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
        <a href='https://github.com/cncf/apisnoop' title='github repo for apisnoop' className='link f7 pl1'>Source Code</a>
      </div>
    </header>
)


   #+END_SRC
** Metadata
    :PROPERTIES:
    :header-args: :tangle ./src/components/metadata.js
    :END:

    The heading of the page, detailing the job result, the bucket it came from, and more.
    #+NAME: Metadata
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'


      const Metadata = (props) => {
        const {
          metadata
        } = props
        return (
          <section id='metadata'>
            <h1>{metadata.version}</h1>
            <p>from job {metadata.job} in bucket {metadata.bucket}</p>
          </section>
        )
      }

      export default connect(
        'selectMetadata',
        Metadata
      )
    #+END_SRC
** Footer
    :PROPERTIES:
    :header-args: :tangle ./src/components/footer.js
    :END:
   #+NAME: Footer
   #+BEGIN_SRC js
     import React from 'react'

     export default () => (
         <footer className='w-100 flex flex-row-ns pt2 pb2 h3 pl4 pr4 items-center justify-between bg-black black shadow-3 white'>
         <div id='logo' className= 'flex flex-wrap items-center justify-center'>
         <a className='contain bg-cncf bg-center white h-100 w4 mr4' href='https://cncf.io' title='leads to external cncf homepage'>
         <span className='o-0'>cncf</span>
         </a>
         <a className='contain bg-packet bg-center h-100 w4 mr4' href='https://packet.net' title='leads to external packet homepage'>
         <span className='o-0'>packet</span>
         </a>
         <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
         </div>
         <div id='source-code' className='flex items-center'>
         </div>
         </footer>
     )
   #+END_SRC
* Pages
** Main Page
  :PROPERTIES:
  :header-args: :tangle ./src/pages/main-page.js
  :END:
  #+NAME: Main Page
  #+BEGIN_SRC js
    import React from 'react'
    import { connect } from 'redux-bundler-react'

    // import FilterContainer from '../components/filter-container' # a regex filter for endpoints.
    import Metadata from '../components/metadata'
    // import UseragentSearchContainer from '../components/useragent-search-container'
    // import SunburstAndSummary from '../components/sunburst-and-summary'
    // import ActiveTestsList from '../components/active-tests-list'
    // import ActiveTestSequence from '../components/active-test-sequence'

    function MainPage () {
      return (
        <main id='main-splash' className='min-vh-80 pa4 ma4 flex flex-column'>
          <Metadata />
          <h1>HELLO YOU ARE DOING GOOD</h1>
          {/*<FilterContainer />*/}
          {/* <UseragentSearchContainer /> */}
          {/* <SunburstAndSummary /> */}
          {/* <ActiveTestsList /> */}
          {/* <ActiveTestSequence /> */}
        </main>
      )
    }

    export default connect(
      MainPage
    )
    #+END_SRC

* Bundles
** Index
   :PROPERTIES:
   :header-args: :tangle ./src/bundles/index.js
   :END:
   This is the root bundler, that takes all the other individual ones and composes a single super bundle.
***  Import modules and bundles
    We import all the various bundles we make here.  The only module we need is redux-bundle's compose bundle function.

    #+NAME: bundle index: Import modules and bundles
    #+BEGIN_SRC js
      import { composeBundles } from 'redux-bundler'
      import jobResultsMetadata from './job-results-metadata'
      import endpoints from './endpoints'

    #+END_SRC
***  Compose Bundle
    Then, we compose the bundles into a single store, listing all the ones we imported above.
    #+NAME: bundle index: compose bundle
    #+BEGIN_SRC js
      export default composeBundles(
        endpoints,
        jobResultsMetadata
      )
    #+END_SRC
** Endpoints
  :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints.js :noweb yes
    :END:

  The operatorId's and their methods from the job results
****  Layout
    #+NAME: Endpoints bundle
    #+BEGIN_SRC js
      export default {
        name: 'endpoints',
        <<Endpoints Reducer>>
      }
    #+END_SRC

**** Endpoints Reducer
   #+NAME: Endpoints Reducer
   #+BEGIN_SRC js :tangle no
     getReducer: () => {
       const initialState = []
       return (state=initialState, action) => {
         return state
       }
     }
   #+END_SRC
** JobResultsMetadata
  :PROPERTIES:
    :header-args: :tangle ./src/bundles/job-results-metadata.js :noweb yes
    :END:

  Metadata from job results used to populate our header information

****  Layout
    #+NAME: JobResultsMetadata bundle
    #+BEGIN_SRC js
      import jobResultsMetadata from '../data/job-results-metadata.json'

      export default {
        name: 'jobResultsMetadata',
        <<JobResultsMetadata Reducer>>,
        <<selectMetadata>>
      }
    #+END_SRC
****  TODO Tests Layout
     color as an example to draw from.
     #+NAME: Colours Tests Setup
     #+BEGIN_SRC js :tangle no
       import { Reducer, Selector } from 'redux-testkit'
       import {composeBundlesRaw} from 'redux-bundler'
       import colours from './colours.js'

       const store = composeBundlesRaw(colours)
       const state = store().getState()

       <<Colours Initial State>>

       describe('Colours Reducer', () => {
         <<Colours Reducer Test>>
       })

       describe('Colours Selectors', () => {
         <<selectLevelColours Test>>
         <<selectCategoryColours Test>>
       })
     #+END_SRC

**** Reducer

     **Action -> JRMState**
    Receives any actions and, no matter its payload, returns the initial JRMState.
    JRMState is ◊JobResultsMetadata , and draws from our =data= folder


     #+NAME: JobResultsMetadata Reducer Test
     #+BEGIN_SRC js :tangle no
       it('should have initial state', () => {
         expect(colours.getReducer()()).toEqual(initialState)
       })
       it('should not have unknown actions affect state', ()=> {
         Reducer(colours.getReducer())
           .expect({type: 'NOT_EXISTING'})
           .toReturnState(initialState)
       })
     #+END_SRC

     #+NAME: JobResultsMetadata Reducer
     #+BEGIN_SRC js :tangle no
        getReducer: () => {
       const initialState = jobResultsMetadata
          return (state=initialState, action) => {
            return state
          }
        }
     #+END_SRC

**** selectMetadata
     **JRMState -> JRMState**
     selects entire output of the JRM State to be used in our components.


     #+NAME: selectMetadata
     #+BEGIN_SRC js :tangle no
    selectMetadata: (state) => state.jobResultsMetadata
     #+END_SRC

* Data Definitions
** JobResultsMetadata (<<<◊JobResultsMetadata>>>)
   JobResultsMetadata is a JSON Object.
   Interpretation: metadata used to populate the header of our page, with information on the job release we are looking at.
   #+NAME: JobResultsMetadata Definition Example
   #+BEGIN_SRC json :tangle ./src/data/job-results-metadata.json
     {
       "job": "36092",
       "bucket": "ci-kubernetes-e2e-gci-gce",
       "version": "v1.15.0-alpha.0.1493",
       "job-version": "v1.15.0-alpha.0.1493+1cb550295a9314",
       "master_os_image": "cos-beta-73-11647-64-0",
       "infra-commit": "279855f78",
       "node_os_image": "cos-beta-73-11647-64-0",
       "pod": "8fa53d0a-4f5a-11e9-8a35-0a580a6c1338",
       "passed": true,
       "result": "SUCCESS",
       "timestamp": 1553561320
     }
   #+END_SRC

   We can test it is valid json with =jq=
   #+BEGIN_SRC shell :results output
  cat ./data/job-results-metadata.json | jq .
   #+END_SRC

   #+RESULTS:
   #+begin_example
   {
     "job": "36092",
     "bucket": "ci-kubernetes-e2e-gci-gce",
     "version": "v1.15.0-alpha.0.1493",
     "job-version": "v1.15.0-alpha.0.1493+1cb550295a9314",
     "master_os_image": "cos-beta-73-11647-64-0",
     "infra-commit": "279855f78",
     "node_os_image": "cos-beta-73-11647-64-0",
     "pod": "8fa53d0a-4f5a-11e9-8a35-0a580a6c1338",
     "passed": true,
     "result": "SUCCESS",
     "timestamp": 1553561320
   }
   #+end_example
** Endpoints...
   :PROPERTIES:
   :header-args: :dir ../..
   :END:
*** Exploration
**** overall
      If we base it off swagger.json, what does that look like?
      #+BEGIN_SRC  shell
     cat swagger.json | jq '. | keys'
      #+END_SRC

      #+RESULTS:
      | [                   |
      | definitions         |
      | info                |
      | paths               |
      | security            |
      | securityDefinitions |
      | swagger             |
      | ]                   |
**** Irrelevant sections
     Still useful in general, but not for our app
     #+NAME: swagger.info
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.info'
      #+END_SRC

      #+RESULTS: swagger.info
      | {       |            |
      | title   | Kubernetes |
      | version | v1.15.0    |
      | }       |            |

     #+NAME: swagger.security
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.security'
      #+END_SRC
      #+RESULTS: swagger.security
      | [           |    |
      | {           |    |
      | BearerToken | [] |
      | }           |    |
      | ]           |    |

     #+NAME: swagger.securityDefinitions
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.securityDefinitions'
      #+END_SRC
      #+RESULTS: swagger.securityDefinitions

     #+NAME: swagger.swagger
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.swagger'
      #+END_SRC
      #+RESULTS: swagger.swagger
      : 2.0

      here is a sample definition
     #+NAME: swagger.definitions
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.definitions["io.k8s.api.apps.v1.ControllerRevisionList"] | keys'
      #+END_SRC

      #+RESULTS: swagger.definitions
      | [                               |
      | description                     |
      | properties                      |
      | required                        |
      | type                            |
      | x-kubernetes-group-version-kind |
      | ]                               |
**** Relevant Section: Paths
     #+NAME: Example Path
     #+BEGIN_SRC shell
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"] | keys'
    #+END_SRC

    #+RESULTS: Example Path
    | [          |
    | delete     |
    | get        |
    | parameters |
    | patch      |
    | put        |
    | ]          |

    So here is a path, that has four methods/verbs, along with the parameters.

    And the operation id for each verb
    #+NAME: Operation ID's for each verb
    #+BEGIN_SRC shell :results output
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["delete"]["operationId"]'
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["get"]["operationId"]'
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["patch"]["operationId"]'
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["put"]["operationId"]'

    #+END_SRC

    #+RESULTS: Operation ID's for each verb
    : "deleteNetworkingV1NamespacedNetworkPolicy"
    : "readNetworkingV1NamespacedNetworkPolicy"
    : "patchNetworkingV1NamespacedNetworkPolicy"
    : "replaceNetworkingV1NamespacedNetworkPolicy"

    And within one of these, there isn't a section for "methods", but each one does have parameters.

    #+NAME: look at a single verb
    #+BEGIN_SRC shell :results output
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["delete"]'
    #+END_SRC

    #+RESULTS: look at a single verb
    #+begin_example
    {
      "consumes": [
        "*/*"
      ],
      "description": "delete a NetworkPolicy",
      "operationId": "deleteNetworkingV1NamespacedNetworkPolicy",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "401": {
          "description": "Unauthorized"
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "networking_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "networking.k8s.io",
        "kind": "NetworkPolicy",
        "version": "v1"
      }
    }
    #+end_example

    Our current mode is to look at the opId and then the method's within.  And each opId has a path.  I assume this is the path we are taking.  What are the paramters related to?  And where are we getting the additional methods?

*** Initial Definition

I think the basic endpoint, without redundant info, could be:
#+NAME: Endpoint Definition
#+BEGIN_SRC json
  {
    "operationId": '',
    "path": '',
    "level": '',
    "category": '',
    "group": '',
    "version": '',
    "kind": '',
    "methods": [
      "get": {
        isTested: boolean,
        isConformance: boolean,
      },
      "watch": {
        isTested: boolean,
        isConformance: boolean,
      }
    ]
  }

#+END_SRC

The test tags and tests and such aren't needed, as they are in their own path.  When you hover over the method of an opId, then that becomes the  "activeOp" and we select the tests whose list of keys contain this opID[method].

we make the tested booleans more specific, as these determine the color in the sunburst and it's easy to just have it checked on render whether something is true or false, rather than determining if true on render.

We are't using counters yet, and there's so many different counters...that I'd rather not include them here (counter for hit by a test, a test tag, a user-agent, etc.)

IF we are filtering on zoom, then the zoom will have:
- level
- category
- opId
- method

you don't wnat to zoom all the way to method, though, cos you just get a big donut.  you wanna freeze the method, but zoom into opId.  So we can keep our basic filter and then just say if "zoom.method !== null then freeze sunburst" and freeze just disables the mouseOver/mouseAway options.

What does a useragent filter look like?
we'd have a list of opId methods that are hit by that user-agent  so it'd be nested.
So let's assume we could have something like this

#+NAME: endpointA
#+BEGIN_SRC json
  {
    "operationId": 'readFoo',
    "path": 'foo/',
    "level": 'stable',
    "category": 'core',
    "group": 'foos',
    "version": 'foo1',
    "kind": 'foothings',
    "methods": [
      "get": {
        isTested: true,
        isConformance: true,
      },
      "watch": {
        isTested: false,
        isConformance: false,
      }
    ]
  }
#+END_SRC

And our list of endpoints hit by user-agent as
#+NAME: endpointsHitByUseragent
#+BEGIN_SRC json
[
"readFoo": [ "get"],
"readBar": ["get", "watch"]
]
#+END_SRC

so this is saying that readFoo[get] was hit by the user-agent but readFoo[watch] was not.  WE know this because watch is absent in the array.

And when we are filteirng we'd filter all the way down to the method, as the concern is whether they're conformance or not....so we'd want to say"

- if useragent filter is set...
- then return endpoint.filtered where the opId is in "endpointsHitByUseragent"
- then, remove any methods within the endpoint that are not within the array of endointsHitByUseragent[endpoint]

Is there a simpler way for this?  it's a filter, then a prune essentially....If that method worked, we could use the same method for tests too and any other section.








* Tasks
** DONE setup basic dev environment
   CLOSED: [2019-04-08 Mon 09:28]
   this would need to be its own react app, in its own folder that we could point to, so it has its own package.json....otherwise the scripts we run would be for client and not app.
   #+NAME: Create React App for new app
   #+BEGIN_SRC shell :dir ./
  npx create-react-app app
   #+END_SRC

   #+NAME: Explore Files in app
   #+BEGIN_SRC shell :dir ./app/ :results output
  tree -I "node_modules"
   #+END_SRC

   #+RESULTS: Explore Files in app
   #+begin_example
   .
   ├── package.json
   ├── package-lock.json
   ├── public
   │   ├── favicon.ico
   │   ├── index.html
   │   └── manifest.json
   ├── README.md
   └── src
       ├── App.css
       ├── App.js
       ├── App.test.js
       ├── index.css
       ├── index.js
       ├── logo.svg
       └── serviceWorker.js

   2 directories, 13 files
   #+end_example
** DONE [5/5] Port over Code from client.org to get basic site
   CLOSED: [2019-04-08 Mon 10:30]
   - [X] header
   - [X] footer
   - [X] pngs
   - [X] tachyons css
   - [X] it says "HELLO YOU ARE DOING GOOD!"
** DONE [4/4] Display Job Results Metadata at top of header
   CLOSED: [2019-04-08 Mon 12:14]
   - [X]  Define  JobResultsMetadata
   - [X] Create Data Folder and put sample of job results metadata into that
   - [X] Create bundle that loads the job results into state
   - [X] Create component that grabs from that store
** TODO [0/3]Display Endpoint Bundle With Success
   - [ ] understand the data that the current endpoint resource needs.
   - [ ] Make up data definition for endpoint as it is now
   - [ ] change the wording if needed (operatorId's instead of endpoints?)
** TODO re-tangle backend.org to bring back correct index.js

#+TITLE: Generate lists of tests per release
#+AUTHOR: Hippie Hacker
#+EMAIL: hh@ii.coop
#+CREATOR: ii.coop
#+DATE: 30th of April, 2019
* Ask

#+BEGIN_QUOTE
I don’t actually know how much progress has been made in adding tests,

I’m looking real quickly at 

the “x/y Tests Passed!” line in spyglass for each of the gce-conformance jobs,

it’s confusing to me that the 1.14 job seems to have fewer than any other…

maybe we really did drop the number of tests?

and we’ve now added a whole bunch in 1.15?
#+END_QUOTE

as rendered by spyglass:

- 1.13 https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-13/1123274473122828295
- 1.14 https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-14/1123274473189937152
- master https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance/1123274473122828292

* Generate
** data-gen/sources.yaml

Update these as needed:

#+BEGIN_SRC yaml :tangle ~/apisnoop/data-gen/sources.yaml
source: prow.k8s.io
default-view:
  bucket: ci-kubernetes-gce-conformance
  job: '1123274473122828292'
buckets:
  ci-kubernetes-gce-conformance:
    jobs:
      - '1123274473122828292'
  ci-kubernetes-gce-conformance-latest-1-13:
    jobs:
      - '1123274473122828295'
  ci-kubernetes-gce-conformance-latest-1-14:
    jobs:
      - '1123274473189937152'
#+END_SRC  

** process

#+BEGIN_SRC tmate
  cd ~/apisnoop
  rm -rf ./data-gen/{processed,cache}
  ./apisnoop.sh --update-cache
  ./apisnoop.sh --process-cache
#+END_SRC

** tests

#+BEGIN_SRC tmate
  cd ~/apisnoop
  cat data-gen/processed/ci-kubernetes-gce-conformance/1123274473122828292/tests.json | jq keys | jq -r .[]  | sort > tests.master
  cat data-gen/processed/ci-kubernetes-gce-conformance-latest-1-14/1123274473189937152/tests.json | jq keys | jq -r .[]  | sort > tests.1.14
  cat data-gen/processed/ci-kubernetes-gce-conformance-latest-1-13/1123274473122828295/tests.json | jq keys | jq -r .[]  | sort > tests.1.13
#+END_SRC

** endpoints

#+BEGIN_SRC tmate
  cd ~/apisnoop
  cat data-gen/processed/ci-kubernetes-gce-conformance/1123274473122828292/endpoints.json | jq keys | jq -r .[]  | sort > endpoints.master
  cat data-gen/processed/ci-kubernetes-gce-conformance-latest-1-14/1123274473189937152/endpoints.json | jq keys | jq -r .[]  | sort > endpoints.1.14
  cat data-gen/processed/ci-kubernetes-gce-conformance-latest-1-13/1123274473122828295/endpoints.json | jq keys | jq -r .[]  | sort > endpoints.1.13
#+END_SRC

* Articulate
:PROPERTIES:
:header-args:shell+: :dir ~/apisnoop
:END:
** python
#+BEGIN_SRC tmate
  
  cd ~/apisnoop/
  python explore.py
  pp data
#+END_SRC

** process
#+BEGIN_SRC tmate
   
  cd ~/apisnoop/
  python ~/ii/org/cncf/apisnoop/foo.py
  pp data
  pp version_summary
  pp test_summary
#+END_SRC
#+BEGIN_SRC tmate
  continue
  versions ; previous_version ; current_version ; removed_tags ; added_tags 
#+END_SRC

#+BEGIN_SRC tmate
  continue
  current_version
  pp data
  pp version_summary
  pp test_summary
#+END_SRC

#+BEGIN_SRC python :results output :dir ~/apisnoop/ :tangle ~/apisnoop/explore.py :async yes
  import json
  import yaml
  import os
  import pprint
  import re
  import pickle

  syaml = yaml.load(open('./audit-sources.yaml').read(),Loader=yaml.FullLoader)
  versions={}

  # for bucket, entry in syaml['buckets'].items():
  #     #only grab the first bucket
  #     job = entry['jobs'][0] 
  #     tests = yaml.load(
  #         open(os.path.join('./data-gen/processed',
  #                           bucket,job,'tests.json')
  #         ).read(),Loader=yaml.FullLoader)
  #     metadata = yaml.load(
  #         open(os.path.join('./data-gen/processed',
  #                           bucket,job,'metadata.json')
  #         ).read(),Loader=yaml.FullLoader)
  #     version = metadata['revision'].split('+')[0].split('-')[0]
  #     versions[version] = tests

  # jar = open('versions.pickle','w')
  # pickle.dump(versions,jar)
  # jar.close()
  pickle_jar = open('versions.pickle','r')
  versions = pickle.load(pickle_jar)
  pickle_jar.close()
  # import ipdb; ipdb.set_trace(context=60)

  tagless_tests={}
  for version, tests in versions.items():
      for test_name, test_entry in tests.items():
          tags = re.findall(r'\[.+?\]', test_name)
          tagless_name = test_name
          for tag in tags:
              tagless_name = tagless_name.replace(tag,'').strip()
          if not tagless_tests.has_key(tagless_name):
              tagless_tests[tagless_name] = {"test_names":{},"test_tags":{}}
          tagless_tests[tagless_name]["test_names"][version]=test_name
          tagless_tests[tagless_name]["test_tags"][version]=tags
          tagless_tests[tagless_name]["removed_tags"]={}
          tagless_tests[tagless_name]["added_tags"]={}
          tagless_tests[tagless_name]["added_test"]={}
          tagless_tests[tagless_name]["removed_test"]={}

  version_list=sorted(versions.keys())
  for tagless_name, data in tagless_tests.items():
      for version_idx in range(len(version_list[1:])):
          current_version=version_list[version_idx+1]
          # skip to next version if this version doesn't have any tests
          if not data['test_names'].has_key(current_version):
              continue
          previous_version=version_list[version_idx]
          # If there is a previous and current version this isn't a new test
          if data['test_names'].has_key(previous_version) and \
             data['test_names'].has_key(current_version):
              previous_test_name = data['test_names'][previous_version]
              previous_test_tags = data['test_tags'][previous_version]
              current_test_tags = data['test_tags'][current_version]
              removed_tags = sorted(list(set(sorted(previous_test_tags)) - set(current_test_tags)))
              added_tags = sorted(list(set(sorted(current_test_tags)) - set(previous_test_tags)))
              if removed_tags:
                  tagless_tests[tagless_name]["removed_tags"][current_version]=removed_tags
              if added_tags:
                  tagless_tests[tagless_name]["added_tags"][current_version]=added_tags
          # If there is a previous version and not a current version we deleted it
          elif data['test_names'].has_key(previous_version) and not data['test_names'].has_key(current_version):
              tagless_tests[tagless_name]["deleted_test"][current_version]=True
          # Else this IS a now test, with fresh tags
          else:
              tagless_tests[tagless_name]["added_test"][current_version]=True
          previous_version = current_version

  # import ipdb; ipdb.set_trace(context=60)
  version_summary={}
  test_summary={}
  for tagless_name, data in tagless_tests.items():
      test_versions = sorted(data['test_names'].keys())
      final_test_name=data['test_names'][test_versions[-1]]
      for version_idx in range(len(test_versions)):
          current_version=test_versions[version_idx]
          if data['removed_tags'].has_key(current_version) or \
             data['added_tags'].has_key(current_version) or \
             data['added_test'].has_key(current_version):
              # create the hashes for this version
              if not version_summary.has_key(current_version):
                  version_summary[current_version]={}
              version_summary[current_version][final_test_name]={}
              # create the hashes for this final_test_name
              if not test_summary.has_key(final_test_name):
                  test_summary[final_test_name]={}
              test_summary[final_test_name][current_version]={}
          if data['removed_tags'].has_key(current_version):
              test_summary[final_test_name][current_version]['removed_tags']\
                  =data['removed_tags'][current_version]
              version_summary[current_version][final_test_name]['removed_tags']\
                  =data['removed_tags'][current_version]
          if data['added_tags'].has_key(current_version):
              test_summary[final_test_name][current_version]['added_tags']\
                  =data['added_tags'][current_version]
              version_summary[current_version][final_test_name]['added_tags']\
                  =data['added_tags'][current_version]
          if data['added_test'].has_key(current_version):
              test_summary[final_test_name][current_version]['added_test']\
                  =data['added_test'][current_version]
              version_summary[current_version][final_test_name]['added_test']\
                  =data['added_test'][current_version]
      pass
  json.dump(version_summary,open('version_summary.json','w'))
  json.dump(version_summary['v1.15.0'],open('master_summary.json','w'))
  json.dump(test_summary,open('test_summary.json','w'))
#+END_SRC

#+RESULTS:
: 37c78c21b54f1ad686a1d7d7e14488f7

* Footnotes
  :PROPERTIES:
  :VISIBILITY: folded
  :END:

#+PROPERTY: header-args:shell :results output code verbatim replace
#+PROPERTY: header-args:shell+ :exports both
#+PROPERTY: header-args:shell+ :wrap "EXAMPLE :noeval t"
#+PROPERTY: header-args:shell+ :eval no-export
#+PROPERTY: header-args:shell+ :noweb-ref (nth 4 (org-heading-components))
#+PROPERTY: header-args:tmate  :socket (symbol-value 'socket)
#+PROPERTY: header-args:tmate+ :session (concat (user-login-name) ":" (nth 4 (org-heading-components)))
#+PROPERTY: header-args:tmate+ :noweb yes
#+PROPERTY: header-args:json  :noweb yes
#+PROPERTY: header-args:json+ :noweb-ref (nth 4 (org-heading-components))
#+PROPERTY: header-args:yaml  :noweb yes
#+PROPERTY: header-args:yaml+ :comments org
#+PROPERTY: header-args:yaml+ :noweb-ref (nth 4 (org-heading-components))
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+STARTUP: content
# Local Variables:
# eval: (set (make-local-variable 'org-file-dir) (file-name-directory buffer-file-name))
# eval: (set (make-local-variable 'user-buffer) (concat user-login-name "." (file-name-base buffer-file-name)))
# eval: (set (make-local-variable 'tmpdir) (make-temp-file (concat "/dev/shm/" user-buffer "-") t))
# eval: (set (make-local-variable 'socket) (concat "/tmp/" user-buffer ".iisocket"))
# eval: (set (make-local-variable 'select-enable-clipboard) t)
# eval: (set (make-local-variable 'select-enable-primary) t)
# eval: (set (make-local-variable 'start-tmate-command) (concat "tmate -S " socket " new-session -A -s " user-login-name " -n main \"tmate wait tmate-ready && tmate display -p '#{tmate_ssh}' | xclip -i -sel p -f | xclip -i -sel c; bash --login\""))
# eval: (xclip-mode 1)
# eval: (gui-select-text start-tmate-command)
# eval: (xclip-mode 0)
# org-babel-tmate-session-prefix: ""
# org-babel-tmate-default-window-name: "main"
# org-confirm-babel-evaluate: nil
# org-use-property-inheritance: t
# End:



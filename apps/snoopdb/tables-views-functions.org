#+TITLE: Tables, Views, Functions
#+PROPERTY: header-args:sql-mode :product postgres :noweb yes :comments no :results silent

* Purpose
  This document holds all the definitions for the snoopdb database.
  Each table, view, function, and comment defined here is tangled into the ~postgres/initdb~ folder in this same directory, which is initialized as part of the docker image.

  This document, then, is the source of truth for the database and anything related to it should be defined here and tangled to its necessary path.
* Basic Database Setup
The database is organized around three schemas: public, conformance, testing.
- public :: default schema related to the overall testing coverage of k8s and the evolving definition of its api
- conformance :: relations related to conformance coverage specifically, and so focused on stable, conformant-eligible endpoints and the things to know about them
- testing :: relations related to the live-testing environment of apisnoop.  Our auditlogger will insert audit events here so we can see whether the functions we're writing increase coverage
* Numbering Scheme of relations
Our numbering is based on the _type_ of relation, but moves across schemas.
- 000 - 099 :: any admin/setup for the db, like addiong extensions and schemas
- 100 - 199 :: all our tables
- 200 - 299 :: all our views, organized by their dependencies (e.g if one view requires another to already exist)
- 300 - 399 :: all our functions
- 400 - 499 :: all our triggers

  We also define some selection scripts that are useful for work outside of the db, like a sql script that generates the latest coverage json.  These are defined here, but the tangling is not keeping with the numbering system.
* Setup
** Create Schemas
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/000_create_schemas.sql
   :END:
   #+begin_src sql-mode
     create schema conformance;
     create schema testing;

     comment on schema conformance is 'relations focused on conformance coverage and stable, conformance-eligible endpoints';
     comment on schema testing is 'relations related to our live testing environment, to test if mock tests hit desired endpoints';
   #+end_src
** Create Extensions
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/001_create_extensions.sql
   :END:
   #+begin_src sql-mode
     create extension plpython3u;
     create extension semver;
   #+end_src
* Tables
** open_api
   :PROPERTIES:
   :header-args: :tangle ./initdb/02_table_open_api.sql
   :END:
   #+NAME: openapi
   #+begin_src sql-mode
     create table open_api
       (
         release text,
         release_date timestamp,
         endpoint text,
         level text,
         category text,
         path text,
         k8s_group text,
         k8s_version text,
         k8s_kind text,
         k8s_action text,
         deprecated boolean,
         description text,
         spec text,
         primary key (release, endpoint)
       );

   #+end_src

   #+NAME: open_api comments
   #+begin_src sql-mode
     comment on table open_api is 'endpoint details from openAPI spec';
     comment on column open_api.release is 'kubernetes release of this spec';
     comment on column open_api.release_date is 'canonical release date for k8s release';
     comment on column open_api.endpoint is 'kubernetes endpoint, the operation_id in the spec';
     comment on column open_api.level is 'alpha, beta, or stable';
     comment on column open_api.category is 'endpoint category, roughly its group, taken from the first tag in the spec.';
     comment on column open_api.path is 'the http path of the endpoint';
     comment on column open_api.k8s_group is 'k8s group for endpoint';
     comment on column open_api.k8s_version is 'k8s version for endpoint';
     comment on column open_api.k8s_kind  is 'k8s kind  for endpoint';
     comment on column open_api.k8s_action is 'endpoint action, roughly related to an http method';
     comment on column open_api.deprecated is 'is endpoint marked as deprecated?';
     comment on column open_api.description is 'description of endpoint';
     comment on column open_api.spec is 'the source for this open api spec, taken from github.';

   #+end_src
** audit_event
   :PROPERTIES:
   :header-args: :tangle ./initdb/03_table_audit_event.sql
   :END:

   #+NAME: audit event definition
   #+begin_src sql-mode
     CREATE UNLOGGED TABLE audit_event (
       release text,
       release_date text,
       audit_id text NOT NULL,
       endpoint text,
       useragent text,
       test text,
       test_hit boolean,
       conf_test_hit boolean,
       data jsonb NOT NULL,
       source text,
       id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       ingested_at timestamp DEFAULT CURRENT_TIMESTAMP);

   #+end_src

   #+NAME: audit event comments
   #+begin_src sql-mode
     comment on table audit_event is 'every event from an e2e test run, or multiple test runs.';

     comment on column audit_event.release is 'release this test suite was run for';
     comment on column audit_event.release_date is 'canonical release date (or test run date if version not released yet';
     comment on column audit_event.audit_id is 'audit event id as given in log.  Note these are not necessarily unique.';
     comment on column audit_event.endpoint is 'endpoint hit by this audit event';
     comment on column audit_event.useragent is 'useragent of the event, taken from events request header';
     comment on column audit_event.test is 'the test codename if it can be extracted from useragent, else null';
     comment on column audit_event.test_hit is 'is the useragent of the event a test?';
     comment on column audit_event.conf_test_hit is 'is the useragent of the event a conformance test?';
     comment on column audit_event.data is 'the full json of the audit event';
     comment on column audit_event.source is 'url of the bucket where the test run logs are stored';
     comment on column audit_event.id is 'generated id, this will be unique';
     comment on column audit_event.ingested_at is 'the time at which the audit_event was added to this table';
   #+end_src

** test
   :PROPERTIES:
   :header-args: :tangle ./initdb/04_table_test.sql
   :END:

  #+NAME: Test Definition
  #+begin_src sql-mode
    create table test
      (
        testname text,
        codename text,
        release text,
        description text,
        file text
    );

  #+end_src

  #+NAME: Test Comments
  #+begin_src sql-mode
    comment on table test is 'info for each conformance test, from latest conformance.yaml';
    comment on column test.testname is 'name of the test';
    comment on column test.codename is 'How the test is displayed within a useragent';
    comment on column test.release is 'release in which this test was promoted to conformance';
    comment on column test.description is 'Description of this test';
    comment on column test.file is 'File in kubernetes/kubernetes where this test is defined';
  #+end_src
* Views
** Endpoint Coverage
   :PROPERTIES:
   :header-args: :tangle ./initdb/11_view_endpoint_coverage.sql
   :END:
   #+NAME: endpoint_coverage definition
   #+begin_src sql-mode
     create or replace view endpoint_coverage as
     select release, endpoint, level, category, path, description,
            k8s_kind as kind,
            k8s_version as version,
            k8s_group as group,
            k8s_action as action,
            (count(test_hit) filter(where test_hit is true)>0) as tested,
            (count(conf_test_hit) filter(where conf_test_hit is true)>0) as conf_tested,
            array_agg(distinct test) as tests
       from      open_api
       left join audit_event using (endpoint, release)
      where deprecated is false
      group by release, endpoint, level, category, path, description, kind, version, k8s_group, k8s_action
      order by level desc, endpoint;

   #+end_src

   #+NAME: endpoint_coverage comments
   #+begin_src sql-mode
     comment on view endpoint_coverage is 'Coverage info for every endpoint in a release, taken from audit events for that release';

     comment on column endpoint_coverage.release is 'Release the endpoint details come from';
     comment on column endpoint_coverage.endpoint is 'a kubernetes endpoint, the operation_id in the spec';
     comment on column endpoint_coverage.level is 'alpha, beta, or stable';
     comment on column endpoint_coverage.category is 'endpoint category, roughly its group, taken from the first tag in the spec.';
     comment on column endpoint_coverage.path is 'the http path of the endpoint';
     comment on column endpoint_coverage.group is 'k8s group for endpoint';
     comment on column endpoint_coverage.version is 'k8s version for endpoint';
     comment on column endpoint_coverage.kind  is 'k8s kind  for endpoint';
     comment on column endpoint_coverage.action is 'endpoint action, roughly related to an http method';
     comment on column endpoint_coverage.tested is 'was endpoint hit at least once by a test useragent';
     comment on column endpoint_coverage.conf_tested is 'was endpoint hit at least once by a conformance test useragent';
     comment on column endpoint_coverage.tests is 'array of codenames of all tests that hit this endpoint';

   #+end_src
** Audit Event Test
   :PROPERTIES:
   :header-args: :tangle ./initdb/12_view_audit_event_test.sql
   :END:
   #+NAME: audit_event_test definition
   #+begin_src sql-mode :results silent
     create or replace view audit_event_test as
       select audit_event.release,
              test,
              (testname is not null) as conformance_test,
                test.testname,
              test.file,
              test.release as promotion_release
         from      audit_event
         left join test on(test = codename)
        where test is not null
        group by test, testname, file, test.release, audit_event.release;
   #+end_src

   #+NAME: audit_event_test comments
   #+begin_src sql-mode

     comment on view audit_event_test is 'every test in the audit_log of a release';
     comment on column audit_event_test.release is 'audit log relesae this test is pulled from';
     comment on column audit_event_test.test is 'test as it appears in audit event, would be codename in conformance.yaml';
     comment on column audit_event_test.conformance_test is 'is this a conformance test?';
     comment on column audit_event_test.testname is 'if conformance, testname as it appears in conformance.yaml, else null.';
     comment on column audit_event_test.file is 'if conformance, file in which test is defined, else null';
     comment on column audit_event_test.promotion_release is 'if conformance, release in which it was promoted, else null.';
   #+end_src

   #+begin_src sql-mode
     select 'audit_event_test defined and commented' as "build log";
   #+end_src

* Functions
** load_open_api
   :PROPERTIES:
   :header-args: :tangle ./initdb/05_fn_load_open_api.sql
   :END:

    #+NAME: load_open_api definition
    #+begin_src sql-mode
      CREATE OR REPLACE FUNCTION load_open_api (
        custom_release text default null
        )
      RETURNS text AS $$
      from string import Template
      import json
      import time
      import datetime
      from urllib.request import urlopen, urlretrieve
      import urllib
      import yaml

      K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
      OPEN_API_PATH = "/api/openapi-spec/swagger.json"
      RELEASES_URL = "https://raw.githubusercontent.com/apisnoop/snoopDB/master/resources/coverage/releases.yaml"

      # Get info about latest release from our releases.yaml
      releases = yaml.safe_load(urlopen(RELEASES_URL))
      latest_release = releases[0]
      latest_release_date = datetime.datetime.now()

      release_dates = {
        "v1.0.0": "2015-07-10",
        "v1.1.0": "2015-11-09",
        "v1.2.0": "2016-03-16",
        "v1.3.0": "2016-07-01",
        "v1.4.0": "2016-09-26",
        "v1.5.0": "2016-12-12",
        "v1.6.0": "2017-03-28",
        "v1.7.0": "2017-06-30",
        "v1.8.0": "2017-08-28",
        "v1.9.0": "2017-12-15",
        "v1.10.0": "2018-03-26",
        "v1.11.0":  "2018-06-27",
        "v1.12.0": "2018-09-27",
        "v1.13.0": "2018-12-03" ,
        "v1.14.0": "2019-03-25",
        "v1.15.0": "2019-06-19",
        "v1.16.0": "2019-09-18",
        "v1.17.0": "2019-12-07",
        "v1.18.0": "2020-03-25",
        "v1.19.0": "2020-08-25"
      }
      print(latest_release)

      # Set values for sql template  based on if custom_release argument was passed
      if custom_release is not None:
        open_api_url = K8S_REPO_URL + custom_release + OPEN_API_PATH
      # check to see if we can load this custom_release url
        try:
          open_api = json.loads(urlopen(open_api_url).read().decode('utf-8'))
          release = custom_release
          rd = release_dates[release]
          release_date = time.mktime(datetime.datetime.strptime(rd, "%Y-%m-%d").timetuple())
        except urllib.error.HTTPError as e:
          raise ValueError('http error with', e)
      else:
        open_api_url = K8S_REPO_URL + 'master' + OPEN_API_PATH
        open_api = json.loads(urlopen(open_api_url).read().decode('utf-8'))
        release = latest_release
        release_date = time.mktime(datetime.datetime.now().timetuple())
      sql = Template("""
         WITH open AS (
           SELECT '${open_api}'::jsonb as api_data)
             INSERT INTO open_api(
               release,
               release_date,
               endpoint,
               level,
               category,
               path,
               k8s_group,
               k8s_version,
               k8s_kind,
               k8s_action,
               deprecated,
               description,
               spec
             )
         SELECT
           trim(leading 'v' from '${release}') as release,
           to_timestamp(${release_date}) as release_date,
           (d.value ->> 'operationId'::text) as endpoint,
           CASE
             WHEN paths.key ~~ '%alpha%' THEN 'alpha'
             WHEN paths.key ~~ '%beta%' THEN 'beta'
             ELSE 'stable'
           END AS level,
           split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
           paths.key AS path,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
           (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
           CASE
             WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
             ELSE false
           END AS deprecated,
                       (d.value ->> 'description'::text) AS description,
                       '${open_api_url}' as spec
           FROM
               open
                , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
                , jsonb_each(paths.value) d(key, value)
                , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
          ORDER BY paths.key;
                    """).substitute(release = release,
                                    release_date = release_date,
                                    open_api = json.dumps(open_api).replace("'","''"),
                                    open_api_url = open_api_url)
      try:
        plpy.execute((sql))
        return "{} open api is loaded".format(custom_release if custom_release else "current")
      except Exception as e:
        return "an error occurred: " + e
      $$ LANGUAGE plpython3u ;
      reset role;
    #+end_src

    #+NAME: load_open_api comments
    #+begin_src sql-mode

      comment on function load_open_api is 'loads given release to open_api table.  Pass release (as "v.X.XX.X") to load specific release, otherwise loads latest';
    #+end_src

** load_audit_events
   :PROPERTIES:
   :header-args: :tangle ./initdb/06_fn_load_audit_events.sql
   :END:
    #+NAME: load_audit_events definition
    #+begin_src sql-mode
      CREATE OR REPLACE FUNCTION load_audit_events(
        custom_bucket text default null,
        custom_job text default null)
        RETURNS text AS $$
        from string import Template
        from urllib.request import urlopen
        import json
        import yaml
        from snoopUtils import determine_bucket_job, download_and_process_auditlogs

        GCS_LOGS="https://storage.googleapis.com/kubernetes-jenkins/logs/"
        RELEASES_URL = "https://raw.githubusercontent.com/apisnoop/snoopDB/master/resources/coverage/releases.yaml"

        releases = yaml.safe_load(urlopen(RELEASES_URL))
        latest_release = releases[0]

        bucket, job = determine_bucket_job(custom_bucket, custom_job)
        auditlog_file = download_and_process_auditlogs(bucket, job)

        metadata_url = ''.join([GCS_LOGS, bucket, '/', job, '/finished.json'])
        metadata = json.loads(urlopen(metadata_url).read().decode('utf-8'))

        release_date = int(metadata['timestamp'])
        release = metadata["version"].split('-')[0].replace('v','')

        num = release.replace('.','')

        if int(release.split('.')[1]) > int(latest_release.split('.')[1]):
          release = latest_release
        # if we are grabbing latest release, and its on cusp of new release,
        # then test runs will show their version as the next release...which is confusing,
        # as the testing changes affect the about-to-be-released one.
        # so if that happens, we set release to what is the canonical latest.
        if custom_bucket is None and custom_job is None:
          release = latest_release

        sql = Template("""
          CREATE TEMPORARY TABLE audit_event_import${job}(data jsonb not null) ;
          COPY audit_event_import${job}(data)
          FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

          INSERT INTO audit_event(release, release_date,
                                  audit_id, endpoint,
                                  useragent, test,
                                  test_hit, conf_test_hit,
                                  data, source)

          SELECT trim(leading 'v' from '${release}') as release,
                  '${release_date}',
                  (raw.data ->> 'auditID'),
                  (raw.data ->> 'operationId') as endpoint,
                  (raw.data ->> 'userAgent') as useragent,
                  CASE
                    WHEN ((raw.data ->> 'userAgent') like 'e2e.test%')
                      THEN trim(split_part((raw.data->>'userAgent'), '--'::text, 2))
                    ELSE null
                  END as test,
                  ((raw.data ->> 'userAgent') like 'e2e.test%') as test_hit,
                  ((raw.data ->> 'userAgent') like '%[Conformance]%') as conf_test_hit,
                  raw.data,
                  'https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/${bucket}/${job}' as source
            FROM audit_event_import${job} raw;
                  """).substitute(
                      audit_logfile = auditlog_file,
                      release = release,
                      bucket = bucket,
                      job = job,
                      release_date = release_date
                  )
        try:
            plpy.execute(sql)
            return "events for {} loaded, from {}/{}".format(release, bucket, job)
        except plpy.SPIError as plpyError:
            print("something went wrong with plpy: ")
            return plpyError
        except:
            return "something unknown went wrong"
        $$ LANGUAGE plpython3u ;
        reset role;
    #+end_src


    #+NAME: load_open_api comments
    #+begin_src sql-mode
      comment on function load_audit_events is 'loads all audit events from given bucket, job.  if neither given, loads latest successful job from sig-release blocking. if just bucket given, loads latest successful job for that bucket.';
    #+end_src
** load_tests
   :PROPERTIES:
   :header-args: :tangle ./initdb/07_fn_load_tests.sql
   :END:
   #+NAME: load_tests definition
   #+begin_src sql-mode
     CREATE OR REPLACE FUNCTION load_tests()
     RETURNS text AS $$
     from string import Template
     import json
     import yaml
     from urllib.request import urlopen, urlretrieve

     TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
     tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
     sql = Template("""
                   WITH jsonb_array AS (
                   SELECT jsonb_array_elements('${tests}'::jsonb) as test_data)
                   INSERT INTO test(testname, codename, release, description, file)
                      SELECT
                      (test_data->>'testname') as testname,
                      (test_data->>'codename') as codename,
                      CASE
                        WHEN ((test_data->>'release') = '') THEN '1.9.0'
                        WHEN ((test_data->>'release') like '%,%')
                          THEN trim(leading 'v' from split_part((test_data->>'release'), ', ', 2))||'.0'
                        ELSE trim(leading 'v' from (test_data->>'release')) ||'.0'
                      END as release,
                      (test_data->>'description') as description,
                      (test_data->>'file') as file
                      from jsonb_array;
                   """).substitute(tests = tests.replace("'","''"))
     try:
         plpy.execute(sql)
         return 'conformance.yaml loaded into test!'
     except Exception as e:
         return 'error occured: ', e
     $$ LANGUAGE plpython3u;
   #+end_src

   #+NAME: load_tests comment
   #+begin_src sql-mode

     comment on function load_tests is 'loads latest conformance.yaml into test table';
   #+end_src
** Generate latest coverage json
   :PROPERTIES:
   :header-args: :tangle ./initdb/13_fn_generate_latest_coverage_json.sql
   :END:
   #+begin_src sql-mode
     create function generate_latest_coverage_json()
       returns json as $$
     declare latest_release varchar;
     begin
     select release into latest_release from audit_event order by release::semver limit 1;
     return(
       select row_to_json(c) from (
         select release, release_date, spec,
                (select array_agg(source) from (select source from audit_event where release = latest_release group by source) s) as sources,
                (select array_agg(row_to_json(endpoint_coverage)) from endpoint_coverage where release = latest_release) as endpoints,
                (select array_agg(row_to_json(audit_event_test)) from audit_event_test where release = latest_release) as tests
           from open_api
          where release = latest_release
          group by release, release_date, spec) c);
     end;
     $$ language plpgsql;
   #+end_src
   #+NAME: generate latest coverage json comment
   #+begin_src sql-mode

     comment on function generate_latest_coverage_json is 'helper to create properly formatted json to be output as a  coverage/X.XX.json file';
   #+end_src
** describe_relations
   :PROPERTIES:
   :header-args: :tangle ./initdb/20_fn_describe_relations.sql
   :END:
   #+begin_src sql-mode
     create or replace function describe_relations(
       out schema text,
       out name text,
       out description text
     )
       returns setof record
     as $$
       select table_schema::text as schema,
       table_name::text as name,
       obj_description(table_name::regclass) as description
       from information_schema.tables
       where table_schema = 'public'
       union
       select table_schema as schema,
              table_name as name,
              obj_description(table_name::regclass) as description
       from information_schema.views
       where table_schema = 'public'
       union
       select  table_schema as schema,
               table_name as name,
               obj_description(('conformance.'||table_name)::regclass) as description
       from information_schema.views
       where table_schema = 'conformance'
       union
       select  table_schema as schema,
               table_name as name,
               obj_description(('conformance.'||table_name)::regclass) as description
       from information_schema.tables
       where table_schema = 'conformance'
       group by name, table_schema
       order by schema desc, name;
     $$ language SQL;
   #+end_src
** describe_relation
   :PROPERTIES:
   :header-args: :tangle ./initdb/21_fn_describe_relation.sql
   :END:
   #+begin_src sql-mode
     create or replace function describe_relation(
       schema text,
       relation text
     )
       returns text
     as $$
       select obj_description((schema||'.'||relation)::regclass)
     $$ language SQL;
   #+end_src
** describe_columns
   :PROPERTIES:
   :header-args: :tangle ./initdb/22_fn_describe_columns.sql
   :END:
     #+begin_src sql-mode
       create or replace function describe_columns(
         in schema text,
         in relation text,
         out "column" text,
         out description text
       )
         returns setof record
       as $$
       select cols.column_name::text as "column",
              pg_catalog.col_description(c.oid, cols.ordinal_position::int)::text as description
         from pg_catalog.pg_class c, information_schema.columns cols
        where cols.table_schema = schema
          and cols.table_name = relation
          and cols.table_name = c.relname;
       $$ language SQL;
   #+end_src
** describe_column
   :PROPERTIES:
   :header-args: :tangle ./initdb/23_fn_describe_column.sql
   :END:
     #+begin_src sql-mode
              create or replace function describe_column(
                in schema text,
                in relation text,
                in col text,
                out "column" text,
                out "description" text
              )
              returns setof record
                   as $$
              select cols.column_name::text as "column",
                     pg_catalog.col_description(c.oid, cols.ordinal_position::int)::text as description
                from pg_catalog.pg_class c, information_schema.columns cols
               where cols.table_schema = schema
                 and cols.table_name = relation
                 and cols.column_name = col
                 and cols.table_name = c.relname;
               $$ language SQL;
   #+end_src
* Conformance Views
** eligible endpoint
   :PROPERTIES:
   :header-args: :tangle ./initdb/14_view_conformance_eligible_endpoint.sql
   :END:
   #+begin_src sql-mode
     create or replace view conformance.eligible_endpoint as
          select endpoint
            from open_api
                   join (
                     select release
                       from open_api
                      order by release::semver desc
                      limit 1) latest using(release)
           where level = 'stable'
          except
          select endpoint
            from open_api
           where path ~~ any('{"%volume%", "%storage%"}')
              or deprecated is true
              or k8s_kind = 'ComponentStatus'
              or (k8s_kind = 'Node' and k8s_action = any('{"delete", "post"}'))
              or endpoint = any('{"getFlowcontrolApiserverAPIGroup", "createCoreV1NamespacedServiceAccountToken"}');
    #+end_src

    #+begin_src sql-mode
      comment on view conformance.eligible_endpoint is 'all current stable endpoints for which conformant tests could be written, following conformance guidelines';

      comment on column conformance.eligible_endpoint.endpoint is 'the endpoint, as its defined in the open_api table';
    #+end_src
   #+begin_src sql-mode
     select 'conformance.eligible_endpoint defined and commented' as "build log";
   #+end_src

** ineligible endopoint
   :PROPERTIES:
   :header-args: :tangle ./initdb/24_view_conformance_ineligible_endpoint.sql
   :END:
  #+begin_src sql-mode
create or replace view conformance.ineligible_endpoint as
    with current_stable_endpoints as (
      select endpoint, path, k8s_kind, k8s_action
        from open_api
       where deprecated is false
         and level = 'stable'
         and release = (
           select release
             from open_api
            order by release::semver desc
            limit 1
         )
    )
    (
        -- vendor specific features
        select endpoint,
                'vendor specific feature' as reason,
                'path includes "volume" or "storage"' as "sql logic",
            'https://github.com/kubernetes/community/blame/master/contributors/devel/sig-architecture/conformance-tests.md#L64' as link
        from current_stable_endpoints
        where path ~~ any('{"%volume%", "%storage%"}')
    )
    union
    (
        -- endpoint is pending deprecation
        select endpoint,
                'pending deprecation' as reason,
                'kind equals ComponentStatus' as "sql logic",
            'https://github.com/kubernetes/community/blame/master/contributors/devel/sig-architecture/conformance-tests.md#L69' as link
        from current_stable_endpoints
        where k8s_kind = 'ComponentStatus'
    )
    union
    (
        -- Uses the kubelet api
        select endpoint,
                'uses kubelet api' as reason,
                'kind equals Node and action equals delete or post' as "sql logic",
            'https://github.com/kubernetes/community/blame/master/contributors/devel/sig-architecture/conformance-tests.md#L36' as link
        from current_stable_endpoints
        where k8s_kind = 'Node'
            and k8s_action = any('{"delete", "post"}')
    )
    union
    (
    -- Optional feature
    select endpoint,
    'optional feature' as reason,
    'endpoint = ' || endpoint as "sql logic",
    'https://github.com/kubernetes/kubernetes/issues/80770' as link
    from current_stable_endpoints
    where endpoint = 'createCoreV1NamespacedServiceAccountToken'
    )
    union
    (
    -- Dependent on Alpha Feature
    select endpoint,
    'depends on alpha feature' as reason,
    'endpoint = ' || endpoint as "sql logic",
    'https://github.com/kubernetes/enhancements/blob/f16c4c7f1c9e28a3cc4bb4d0e6503efea2ae7987/keps/sig-api-machinery/20190228-priority-and-fairness.md' as link
    from current_stable_endpoints
    where endpoint = 'getFlowcontrolApiserverAPIGroup'
    )
    order by reason;
  #+end_src

  #+begin_src sql-mode
    comment on view conformance.ineligible_endpoint is 'endpoints ineligible for conformance testing and the reason for ineligibility.';

    comment on column conformance.ineligible_endpoint.endpoint is 'the ineligible endpoint';
    comment on column conformance.ineligible_endpoint.reason is 'reason, from conformance guidelines, for ineligibility';
    comment on column conformance.ineligible_endpoint."sql logic" is 'how we tested reason using sql';
    comment on column conformance.ineligible_endpoint.link is 'url source for reason';
  #+end_src

   #+begin_src sql-mode
     select 'conformance.ineligible_endpoint defined and commented' as "build log";
   #+end_src
** eligible endpoint coverage
   :PROPERTIES:
   :header-args: :tangle ./initdb/15_view_conformance_eligible_endpoint_coverage.sql
   :END:
   #+NAME: eligible endpoint coverage definition
   #+begin_src sql-mode :results silent
          create materialized view conformance.eligible_endpoint_coverage as
            select
            oa.endpoint,
            (array_agg(test.release order by test.release::semver))[1] as first_conformance_test,
            (array_agg(test.testname order by test.release::semver))[1] as test,
            (array_agg(test.codename order by test.release::semver))[1] as codename,
            (array_agg(test.file order by test.release::semver))[1] as file,
            (array_agg(oa.release order by oa.release::semver))[1] as first_release,
            array_remove((array_agg(distinct test.release::semver order by test.release::semver)), null) as all_test_releases
            from
                      open_api oa
           inner join conformance.eligible_endpoint using(endpoint)
            left join audit_event ae using(endpoint)
            left join test on (ae.test = test.codename)
     group by endpoint;
   #+end_src

   #+NAME: eligible endopint coverage comments
   #+begin_src sql-mode
     comment on materialized view conformance.eligible_endpoint_coverage is 'in-depth coverage info for eligible endpoints';

     comment on column conformance.eligible_endpoint_coverage.endpoint is 'endpoint as defined in table open_api';
     comment on column conformance.eligible_endpoint_coverage.first_conformance_test is 'release of earliest conformance test that hits endpoint. May be earlier than release of endpoint.';
     comment on column conformance.eligible_endpoint_coverage.test is 'Name of first test that hits endopint, as given in conformance.yaml';
     comment on column conformance.eligible_endpoint_coverage.codename is 'first test as it appears in useragent of auditlog';
     comment on column conformance.eligible_endpoint_coverage.file is 'file where this first test is defined';
     comment on column conformance.eligible_endpoint_coverage.first_release is 'release in which this endpoint first appears in the open_api spec as an eligible endpoint.';
     comment on column conformance.eligible_endpoint_coverage.all_test_releases is 'set of releases for tests that hit this endpoint';
   #+end_src

   #+begin_src sql-mode
     select 'conformance.eligible_endpoint_coverage defined and commented' as "build log";
   #+end_src
** conformance progress
   :PROPERTIES:
   :header-args: :tangle ./initdb/16_view_conformance_progress.sql
   :END:
  #+NAME: conformance progress definition
  #+begin_src sql-mode
    create or replace view conformance.progress as
        with endpoints_per_release as (-- this filters out endpoints that were dropped after the release
          select release, endpoint
            from      open_api
           inner join conformance.eligible_endpoint using(endpoint)
        )
        select distinct
          epr.release::semver,
          count(*) filter (where epr.release = coverage.first_release) as new_endpoints,
          (select count(*) from test where test.release = epr.release) as new_tests,
          count(*) filter (
            where epr.release = coverage.first_release
            and coverage.all_test_releases @> array[epr.release::semver]
          ) as new_endpoints_promoted_with_tests,
          count(*) filter (
            where epr.release = coverage.first_release
            and coverage.first_conformance_test = coverage.first_release
          ) as new_endpoints_covered_by_new_tests,
          count(*) filter (
          where coverage.first_release = epr.release
          and coverage.first_conformance_test::semver < epr.release::semver
          ) new_endpoints_covered_by_old_tests,
          count(*) filter (
            where coverage.first_release::semver < epr.release::semver
              and coverage.first_conformance_test = epr.release
          ) old_endpoints_covered_by_new_tests,
          count(*) as total_endpoints,
          count(*) filter (
            where coverage.first_release::semver <= epr.release::semver
            and coverage.first_conformance_test::semver <= epr.release::semver
          ) as total_tested_endpoints,
          count(*) filter (
            where coverage.first_release = epr.release
            AND coverage.first_conformance_test is null
          ) endpoints_still_untested_today
        from      endpoints_per_release epr
        left join conformance.eligible_endpoint_coverage coverage using (endpoint)
        where release::semver >= '1.8.0'::semver
        group by epr.release
        order by epr.release::semver;
    #+end_src

    #+NAME: conformance progress comments
    #+begin_src sql-mode
      comment on view conformance.progress is 'per release, the # of new, eligible endpoints and coverage ratios';

      comment on column conformance.progress.release is 'the kubernetes release';
      comment on column conformance.progress.new_endpoints is '# of eligible endpoints promoted to stable in this release';
      comment on column conformance.progress.new_tests is '# of tests promoted to conformance this release';
      comment on column conformance.progress.new_endpoints_promoted_with_tests is '# of new endpoints hit by a new test, meaning the test and endpoint were promoted in tandem';
      comment on column conformance.progress.new_endpoints_covered_by_new_tests is '# of new endpoints whose first test is one that was promoted this release';
      comment on column conformance.progress.new_endpoints_covered_by_old_tests is '# of new endpoints that were hit by an existing test';
      comment on column conformance.progress.old_endpoints_covered_by_new_tests is '# old endoints hit for the first time by a test from this release.  This shows the payment of technical debt';
      comment on column conformance.progress.total_tested_endpoints is 'total # of eligible endopints hit by tests';
      comment on column conformance.progress.endpoints_still_untested_today is '# of new endopints from this release that are unhit as of the present day';
    #+end_src

   #+begin_src sql-mode
     select 'conformance.conformance_progress defined and commented' as "build log";
   #+end_src
** coverage per release
   :PROPERTIES:
   :header-args: :tangle ./initdb/17_view_conformance_coverage_per_release.sql
   :END:

  #+NAME: coverage_per_release definition
  #+begin_src sql-mode :results silent
create or replace view conformance.coverage_per_release as
          with endpoints_per_release as (
            select release, endpoint
              from       open_api
              inner join conformance.eligible_endpoint using(endpoint)
          ), counts as (
          select distinct epr.release::semver,
                 count(*) filter (where epr.release = firsts.first_release) as new_endpoints,
                 count(*) filter (where epr.release = firsts.first_release and first_conformance_test is not null) as tested,
                 count(*) filter (where epr.release = firsts.first_release and first_conformance_test is null) as untested
          from      endpoints_per_release epr
          left join conformance.eligible_endpoint_coverage firsts on (epr.endpoint = firsts.endpoint)
         group by epr.release
         order by epr.release::semver
       )
          select release,
                 new_endpoints as "new endpoints",
                 tested,
                 untested,
                 sum(tested) over (order by release::semver) as "total tested",
                 sum(untested) over (order by release::semver) as "total untested",
                 sum(new_endpoints) over (order by release::semver) as "total endpoints"
            from counts;
    ;
    #+end_src

    #+NAME: coverage per release definition
    #+begin_src sql-mode
      comment on view conformance.coverage_per_release is 'How many endopoints from a release are tested today?';

      comment on column conformance.coverage_per_release.release is 'the given kubernetes release';
      comment on column conformance.coverage_per_release.tested is '# of endpoints from this release that are tested today';
      comment on column conformance.coverage_per_release.untested is '# of endpoints from this release that are untested today.';
      comment on column conformance.coverage_per_release."new endpoints" is '# of endpoints introduced in this release';
      comment on column conformance.coverage_per_release."total tested" is '# of total tested endpoints from this release and earlier. will be higher than same column in conformance.progress as it includes endpoints hit by tests introduced in a later release.';
      comment on column conformance.coverage_per_release."total untested" is '# of total untested endpoints from this release and earlier';
      comment on column conformance.coverage_per_release."total endpoints" is '# of total endpoints at time of release';


    #+end_src

   #+begin_src sql-mode
     select 'conformance.coverage_per_release defined and commented' as "build log";
   #+end_src
** new endpoints
   :PROPERTIES:
   :header-args: :tangle ./initdb/18_view_conformance_new_endpoints.sql
   :END:

   #+NAME: new endpoints definition
   #+begin_src sql-mode
     create view conformance.new_endpoint as
          select endpoint,
                 first_release as release,
                 (first_conformance_test is not null) as tested
                   from conformance.eligible_endpoint_coverage
               order by first_release::semver desc, tested;

   #+end_src

   #+begin_src sql-mode
     comment on view conformance.new_endpoint is 'eligible endpoints sorted by release and whether they are tested';

     comment on column conformance.new_endpoint.endpoint is 'eligible endpoint as defined in table open_api';
     comment on column conformance.new_endpoint.release is 'release in which this endpoint was promoted';
     comment on column conformance.new_endpoint.endpoint is 'is this endpoint hit by a conformance test, as of latest test run?';
   #+end_src

   #+begin_src sql-mode
     select 'conformance.new_endpoint defined and commented' as "build log";
   #+end_src

* Useful Scripts
These aren't static relations in the db, but scripts we run as part of the db's initialization
** Load all our open_api
   :PROPERTIES:
   :header-args: :tangle ./initdb/08_load_all_open_api.sql
   :END:
   #+NAME: Load all open api
   #+begin_src sql-mode
     begin;
     with releases as (
       select column1 as release
         from (values
         ('v1.5.0'),
         ('v1.6.0'),
         ('v1.7.0'),
         ('v1.8.0'),
         ('v1.9.0'),
         ('v1.10.0'),
         ('v1.11.0'),
         ('v1.12.0'),
         ('v1.13.0'),
         ('v1.14.0'),
         ('v1.15.0'),
         ('v1.16.0'),
         ('v1.17.0'),
         ('v1.18.0'),
         ('v1.19.0')
         ) as rlist
     )
     select f.*
       from
       releases r
       , lateral load_open_api(r.release) f("build log");
     select * from load_open_api() f("build log");
     commit;

   #+end_src

** Load tests
   :PROPERTIES:
   :header-args: :tangle ./initdb/09_load_all_tests.sql
   :END:
   #+NAME: load tests
   #+begin_src sql-mode
     begin;
     select * from load_tests() f("build log");
     commit;
   #+end_src

** Load latest audit_events
   :PROPERTIES:
   :header-args: :tangle ./initdb/10_load_all_audit_events.sql
   :END:
   #+NAME: load latest audit events
  #+begin_src sql-mode
     begin;
     select * from load_audit_events() f("build log");
     select * from load_audit_events('ci-kubernetes-gce-conformance-latest') f("build log");
     commit;
  #+end_src
** Load latest tests
** output latest coverage to file
   #+begin_src sql-mode
     begin;
     select (select release from audit_event order by release limit 1) as latest_release
     \gset
     \set output_file '../resources/coverage/':latest_release'.json'
     \t
     \a
     \o :output_file
       select * from generate_latest_coverage_json();
     \o
     \a
     \t
     commit;
   #+end_src

** output conformance progress to json
 #+begin_src sql-mode
   begin;
   \t
   \a
   \o ../resources/coverage/conformance-progress.json
     select json_agg(json_build_object(
     'release', release,
     'total', json_build_object(
       'endpoints', total_endpoints,
       'tested', total_tested_endpoints,
       'new', new_endpoints,
       'new_with_tests', new_endpoints_promoted_with_tests,
       'new_tested', new_endpoints_covered_by_new_tests + new_endpoints_covered_by_old_tests,
       'still_untested', endpoints_still_untested_today
     )
    ))from conformance.progress;
   \o
   \a
   \t
   commit;
 #+end_src
*** output conformance progress to file
*** output conformance coverage per release to file
** output conformance coverage per release to json
 #+begin_src sql-mode
   begin;
   \t
   \a
   \o '../resources/coverage/conformance-coverage-per-release.json'
   select json_agg(cp) as output_json
     from (
       select * from conformance.coverage_per_release
     )cp;
   \o
     \a
   \t
   commit;
 #+end_src
** output new endpoints

** output untested endpoints
   :PROPERTIES:
   :header-args: :tangle ./initdb/25_output_untested_endpoints.sql
   :END:
  #+BEGIN_SRC sql-mode
begin;

select 'writing untested endpoints for ' || release || ' to /tmp/untested-endpoints.txt' as "build log"
from open_api
order by release::semver desc
limit 1;

\t
\a
\o '/tmp/untested-endpoints.txt'

  with latest_release as (
  select release::semver as release
    from open_api
   order by release::semver desc
   limit 1
  )

  select endpoint
    from conformance.new_endpoint ne
           join latest_release on ne.release::semver = latest_release.release
where tested is false;

\o
\a
\t
commit;
  #+END_SRC
* Scratch
#+begin_src sql-mode
select * from generate_latest_coverage_json();
#+end_src

   #+begin_src sql-mode :results replace
     create or replace view new_endpoints as
     select first_release as release, array_agg(endpoint) as endpoints from (
       select distinct endpoint,
                       (array_agg(oa.release order by oa.release::semver))[1] as first_release
         from open_api oa
        group by endpoint, level, k8s_kind, k8s_action
     ) a
      group by first_release
      order by first_release::semver;
   #+end_src

   #+RESULTS:
   #+begin_SRC example
   CREATE VIEW
   #+end_SRC

#+begin_src sql-mode
  begin;
  \t
    \a
    \o ../resources/coverage/new-endpoints.json
    select json_agg(ne) from
    (
      select * from new_endpoints
      ) ne;
    \o
    \a
    \t
    commit;

#+end_src

#+BEGIN_SRC sql-mode
select count(*) from conformance.ineligible_endpoint;
#+END_SRC

#+BEGIN_SRC shell
wc -l ../resources/untested-endpoints.txt
#+END_SRC

#+RESULTS:
#+BEGIN_example
0 ../resources/untested-endpoints.txt
#+END_example

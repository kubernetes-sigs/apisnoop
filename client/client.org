#+NAME: APISnoop WebUI Client
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+TODO: IDEA(i) TODO(t) NEXT(n) IN-PROGRESS(p) BLOCKED(b) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+XPROPERTY: header-args:shell :results silent
#+XPROPERTY: header-args:shell :exports code
#+XPROPERTY: header-args:shell :wrap "SRC text"
#+PROPERTY: header-args:js :results silent :noweb yes
* Understanding our Client
  This is a web-based visual interface to the data curation and manipulation we are doing as the APISnoop project.  The purpose is to display previously unseen connections between the testing coverage of kubernetes, and the people and communities these various parts of kubernetes matter to.
* Architecture
  The frontend is written with React and Redux (via redux-bundler).  The visualization for the sunburst is done with react-vis, a d3 library for react.
** React
  React allows for a dynamic site built out of a servies of discrete components.  So our site with a header, a list of releases, a sunburst, and a list of tests will have header, sunburst, release list, and test list components.  This allows for someone on the team to work on a single component individually without affecting the rest of the site.  It also allows for reusability: for example, if we wanted to have three different filters in our site - for test tags, useragents, and regex-- we can do this with a single filter component given three different variables.  It speeds up frontend development while maintaining consistent style.
** Redux
  Redux is a state-management tool which allows for one simple, immutable, trackable state.  It holds all the business-logic of the app, and any data or manipulation of data the app requires.  Said simply, it is sort of the backend server inside the front-end, but a server that runs as a single, parsale object.
** Connecting to the Backend
   We do not communicate with the backend much, and the majority of the code to handle it is in our [[*Config][Config Bundle]] and in our *Resource bundles.  Whenever someone changes the release, it triggers a fetch of data to the backend listed in the config file.  Our Endpoints resource fetches all endpoints from that release, our Test Resource bundle fetches all tests, etc.   There's a nice synergy between this frontend iand Feathers, where feathers has a built-in connector we can use for these fetches...but it's simple enough that the config file could be refactored to something new and it wouldn't affect the rest of the code that much.

   The majority of the work in the code is handled by selectors, which continuously filter down the data based on the current url paramaters.

** Our Design Philosophy
  In our [[index.js]] file we connect the entire React site to Redux, which allows for every component to have access to whichever parts of the state they need.

  This allows for a consistent philosophy for how new features and components are built:
*** React should be dumb.
    No react component should do anything fancy.  It should only present the data it is given and nothing more.  There should be no internal state that a component has to manage.

 There will be times when you need to handle mouse or keyboard events.  When this happens, the eventHandler should update redux with what happened and let redux manage how to handle it, and update the data react presents.
*** Redux should be boring
If the redux store feels like one big spreadsheet, then we are doing a good job.  There shouldn't be multiple manipulations of the state to manage, or nested logic that you have to travel through to understand how the app got to where it was.  Instead, we hold raw data in a nice clear, mostly untouched column, and then filter or combine that data as necessary-- like macros in an excel sheet.
*** The URL guides all
    To make redux as boring as possible we follow a basic flow where events on a react component change the current url, and redux determines the data to give components based on the current url.  This makes it easy to share specific configurations of apisnoop with others, but also makes a clean process for building out new features...a new feature essentially is an added url query paramter.
*** Coding should be pleasant
    I refactor the code often with this philosophy in mind.  I want the overall flow of the app to be clear to future me and to whoever else we collaborate with.  Super clever(and super obscure) functions are avoided, and things that no longer server a clear purpose are pruned.  I also try to reduce the amount of boilerplate needed (or abstract it within this org file), so the focus can just be on the functions and components.
*** Our work should support learning
    I refactor the org file more often than the code, to help future developers learn what it is we're doing and why. No important things should be held in a conversational memory, but instead linked and explained here.  The risk with this is verbosity.  So cleaning up sentence structure and explanations is as important as refactoring code.

The downside of this is that apisnoop developers should be doing it from within the org file--but the strengths are strong enough to make this worthwhile I think.
* The Code
** index.js
   :PROPERTIES:
   :header-args: :tangle ./src/index.js
   :END:

   An Initiatory File.  The first point of access into the rest of the code, and what connects the components and pages to the data held in the bundles.

   #+NAME: index.js
   #+BEGIN_SRC js
      import React from 'react'
      import { render } from 'react-dom'
      import './index.css'

      import { Provider } from 'redux-bundler-react'

      import App from './components/app'
      import createStore from './bundles'

      var store = createStore()

      document.title = 'APISnoop | ' // + store.getState().routing.release

      render(
          <Provider store={store}>
           <App />
           </Provider>,
         document.getElementById('root')
      )
   #+END_SRC
** _redirects
   :PROPERTIES:
   :header-args: :tangle ./public/_redirects
   :END:

   This lives in our public folder, and makes it so that when the site is deployed on netlify, all url's given will work--as they'll point back to our index.html page which will dynamically route them.

   #+NAME: _redirects
   #+BEGIN_SRC yaml
     /*    /index.html   200
   #+END_SRC
** Bundle
*** Understanding Bundles
**** What they Are
   Another way of thinking of these are 'concerns'.  As we add functionality, it will come in the form of a bundle.  This bundle will define:
 - the state as related to this concern (reducers),
 - How we manipulate and then give the data in the state to our components (the selectors),
 - How we listen for conditions in the state that would trigger actions to happen (the reactors),
 - The actions that change the state (Actions)
**** How they're written in this org file
     To help future us, we strive to define each function within a bundle by its inputs, purpose, and tests.  By defining these first, we can better understand how to build out the function.  This requires a little bit of org boilerplate, as some of this is code and some of this is org, and the snippets of code belong in different files.  So at the start of the bundle we setup our bundle layout and our testing layout.  As we add new selectors, we weave them into the layout before writing them in their own code block.

A good example of this can be found in our Colours bundle.

*** Index
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/index.js
    :END:
    This is the root bundler, that takes all the other individual ones and composes a single super bundle.
****  Import modules and bundles
     We import all the various bundles we make here.  The only module we need is redux-bundle's compose bundle function.

     #+NAME: bundle index: Import modules and bundles
     #+BEGIN_SRC js
       import { composeBundles } from 'redux-bundler'

       import colours from './colours'
       import config from './config'
       import currentReleaseResource from './current-release-resource'
       import endpointsResource from './endpoints-resource'
       import endpoints from './endpoints'
       import filter from './filter'
       import releases from './releases'
       import releasesIndexResource from './releases-index-resource'
       import routes from './routes'
       import sunburst from './sunburst'
       import summary from './summary'
       import testsResource from './tests-resource'
       import tests from './tests'
       import useragentsResource from './useragents-resource'
       import useragents from './useragents'
       import zoom from './zoom'

     #+END_SRC
****  Compose Bundle
     Then, we compose the bundles into a single store, listing all the ones we imported above.
     #+NAME: bundle index: compose bundle
     #+BEGIN_SRC js
       export default composeBundles(
         colours,
         config,
         currentReleaseResource,
         endpointsResource,
         endpoints,
         filter,
         releases,
         releasesIndexResource,
         routes,
         sunburst,
         summary,
         testsResource,
         tests,
         useragentsResource,
         useragents,
         zoom
       )
     #+END_SRC
*** Colours
  :PROPERTIES:
    :header-args: :tangle ./src/bundles/colours.js :noweb yes
    :END:

    The colors used for our app, mapped to our levels and categories.  Now we can always identify a level by its color, no matter if we are seeing the level in our sunburst chart or as a title/tag somewhere else in the page.

****  Layout
    #+NAME: Colours bundle
    #+BEGIN_SRC js
      export default {
        name: 'colours',
        <<Colours Reducer>>,
        <<selectLevelColours>>,
        <<selectCategoryColours>>
      }
    #+END_SRC
****  Tests Layout

     (This sets up a mock store, state to run our tests on later.  everything dealing with tests ends up within =src/bundles/colours.test.js but is distributed throughout this passage so that the tests can be next to the functions they are testing.)

     #+NAME: Colours Tests Setup
     #+BEGIN_SRC js :tangle ./src/bundles/colours.test.js
       import { Reducer, Selector } from 'redux-testkit'
       import {composeBundlesRaw} from 'redux-bundler'
       import colours from './colours.js'

       const store = composeBundlesRaw(colours)
       const state = store().getState()

       <<Colours Initial State>>

       describe('Colours Reducer', () => {
         <<Colours Reducer Test>>
       })

       describe('Colours Selectors', () => {
         <<selectLevelColours Test>>
         <<selectCategoryColours Test>>
       })
     #+END_SRC

****  Colours Reducer

     **Action -> ColourState**
    Receives any actions and, no matter its payload, returns the initial Colourstate.

     #+NAME: Colours Initial State
     #+BEGIN_SRC js :tangle no
       const initialState = {
         colours: {
           'alpha': 'rgba(230, 25, 75, 1)',
           'beta': 'rgba(0, 130, 200, 1)',
           'stable': 'rgba(60, 180, 75, 1)',
           'unused': 'rgba(255, 255, 255, 1)'
         },
         moreColours: [
           'rgba(183, 28, 28, 1)',
           'rgba(136, 14, 79, 1)',
           'rgba(74, 20, 140, 1)',
           'rgba(49, 27, 146, 1)',
           'rgba(26, 35, 126, 1)',
           'rgba(13, 71, 161, 1)',
           'rgba(1, 87, 155, 1)',
           'rgba(0, 96, 100, 1)',
           'rgba(0, 77, 64, 1)',
           'rgba(27, 94, 32, 1)',
           'rgba(51, 105, 30, 1)',
           'rgba(130, 119, 23, 1)',
           'rgba(245, 127, 23, 1)',
           'rgba(255, 111, 0, 1)',
           'rgba(230, 81, 0, 1)',
           'rgba(191, 54, 12, 1)',
           'rgba(244, 67, 54, 1)',
           'rgba(233, 30, 99, 1)',
           'rgba(156, 39, 176, 1)',
           'rgba(103, 58, 183, 1)',
           'rgba(63, 81, 181, 1)',
           'rgba(33, 150, 243, 1)',
           'rgba(3, 169, 244, 1)',
           'rgba(0, 188, 212, 1)',
           'rgba(0, 150, 136, 1)',
           'rgba(76, 175, 80, 1)',
           'rgba(139, 195, 74, 1)',
           'rgba(205, 220, 57, 1)',
           'rgba(255, 235, 59, 1)',
           'rgba(255, 193, 7, 1)',
           'rgba(255, 152, 0, 1)',
           'rgba(255, 87, 34, 1)'

         ],
         categories: [
           "admissionregistration",
           "apiextensions",
           "apiregistration",
           "apis",
           "apps",
           "authentication",
           "authorization",
           "autoscaling",
           "batch",
           "certificates",
           "core",
           "events",
           "extensions",
           "logs",
           "networking",
           "policy",
           "rbacAuthorization",
           "scheduling",
           "settings",
           "storage",
           "version",
           "auditregistration",
           "coordination"
         ]
       }
     #+END_SRC


     #+NAME: Colours Reducer Test
     #+BEGIN_SRC js :tangle no
       it('should have initial state', () => {
         expect(colours.getReducer()()).toEqual(initialState)
       })
       it('should not have unknown actions affect state', ()=> {
         Reducer(colours.getReducer())
         .expect({type: 'NOT_EXISTING'})
         .toReturnState(initialState)
       })
     #+END_SRC

     #+NAME: Colours Reducer
     #+BEGIN_SRC js :tangle no
        getReducer: () => {
          <<Colours Initial State>>
          return (state=initialState, action) => {
            return state
          }
        }
     #+END_SRC

****  selectLevelColours
     ◊ColourState -> ◊LevelColours
     Given the ColourState return the LevelColours from the Colourstate
     Colours is an object structured as {level_name: rgba code}

     #+NAME: selectLevelColours Test
     #+BEGIN_SRC js :tangle no
       it('should list all the level colours', () => {
         var result = {
           alpha: 'rgba(230, 25, 75, 1)',
           beta: 'rgba(0, 130, 200, 1)',
           stable: 'rgba(60, 180, 75, 1)',
           unused: 'rgba(255, 255, 255, 1)'
         }
         Selector(colours.selectLevelColours).expect(state).toReturn(result)
       })
     #+END_SRC

     #+NAME: selectLevelColours
     #+BEGIN_SRC js :tangle no
    selectLevelColours: (state) => state.colours.colours
     #+END_SRC

****  selectCategoryColours

     ◊ColourState -> ◊CategoryColours
     Given the state, return object mapping categories to their colours
     CategoryColours is an object structured as {category.name : rgbaColor}

     #+NAME: selectCategoryColours Test
     #+BEGIN_SRC js :tangle no
       it('should show categories mapped to colours', () => {
         var result = {
           'category.admissionregistration': 'rgba(183, 28, 28, 1)',
           'category.apiextensions': 'rgba(49, 27, 146, 1)',
           'category.apiregistration': 'rgba(1, 87, 155, 1)',
           'category.apis': 'rgba(27, 94, 32, 1)',
           'category.apps': 'rgba(245, 127, 23, 1)',
           'category.authentication': 'rgba(191, 54, 12, 1)',
           'category.authorization': 'rgba(156, 39, 176, 1)',
           'category.autoscaling': 'rgba(33, 150, 243, 1)',
           'category.batch': 'rgba(0, 150, 136, 1)',
           'category.certificates': 'rgba(205, 220, 57, 1)',
           'category.core': 'rgba(255, 152, 0, 1)',
           'category.events': 'rgba(136, 14, 79, 1)',
           'category.extensions': 'rgba(26, 35, 126, 1)',
           'category.logs': 'rgba(0, 96, 100, 1)',
           'category.networking': 'rgba(51, 105, 30, 1)',
           'category.policy': 'rgba(255, 111, 0, 1)',
           'category.rbacAuthorization': 'rgba(244, 67, 54, 1)',
           'category.scheduling': 'rgba(103, 58, 183, 1)',
           'category.settings': 'rgba(3, 169, 244, 1)',
           'category.storage': 'rgba(76, 175, 80, 1)',
           'category.version': 'rgba(255, 235, 59, 1)',
           'category.auditregistration': 'rgba(255, 87, 34, 1)',
           'category.coordination': 'rgba(74, 20, 140, 1)'
         }
         Selector(colours.selectCategoryColours).expect(state).toReturn(result)
       })
     #+END_SRC

     #+NAME: selectCategoryColours
     #+BEGIN_SRC js :tangle no
       selectCategoryColours: (state) => {
         var colours = {}
         for (var catidx = 0; catidx < state.colours.categories.length; catidx++) {
           var category = state.colours.categories[catidx]
           colours['category.' + category] = state.colours.moreColours[(catidx * 3) % state.colours.moreColours.length]
         }
         return colours
       }

     #+END_SRC

*** Endpoints Resource
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints-resource.js :noweb yes
    :END:
    #+NAME: endpoints-resource.js
    #+BEGIN_SRC js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'endpointsResource',
        getPromise: ({ client, store }) => {
          const currentReleaseName = store.selectCurrentReleaseName()
          return fetchEndpointsByReleaseName(client, currentReleaseName)
        }
      })

      bundle.reactEndpointsFetch = createSelector(
        'selectEndpointsResourceShouldUpdate',
        (shouldUpdate, currentReleaseId) => {
          if (!shouldUpdate) return
          return { actionCreator: 'doFetchEndpointsResource' }
        }
      )


      export default bundle

      function fetchEndpointsByReleaseName (client, releaseName) {
        return client.service('endpoints').find({
          query: {
            release: releaseName
          }
        })
      }
    #+END_SRC
*** Endpoints
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints.js :noweb yes
    :END:

      Our endpoints resource manages all the endpoints, grabbing and storing them for whatever is the current release.  This means we don't have to have an endpoint reducer.  Everything we do is just selecting and filtering from that list.

      We are making it now so that the endpoints filter on the query at the start.   The key thing is whether or not a zoom is part of the query.  If it is, we filter by whatever depth the zoom is at.

**** Imports and Layout
    #+NAME: endpoints bundle layout
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import {
        groupBy,
        keyBy,
        mapValues } from 'lodash'

      import { calculateCoverage } from '../lib/utils.js'

      export default {
        name: 'endpoints',
          <<selectFilteredEndpoints>>,
          <<selectFilteredAndZoomedEndpoints>>,
          <<selectZoomedEndpoint>>,
          <<selectEndpointsById>>,
          <<selectEndpointsByLevelAndCategoryAndNameAndMethod>>,
          <<selectEndpointsWithTestCoverage>>,
          <<selectActiveEndpoint>>
      }
    #+END_SRC
**** Tests Layout

     We have a set of 20 endpoints we use throughout this, but it's good to have 3 or 4 for the endpoints by Id to make it a bit easier to manage.
     #+NAME: smallEndpointsSample
     #+BEGIN_SRC js :tangle no
       var smallEndpointsSample = [
         {
           "name": "readCoreV1NamespaceStatus",
           "method": "get",
           "level": "stable",
           "test_tags": [],
           "tests": [],
           "description": "read status of the specified Namespace",
           "path": "/api/v1/namespaces/{name}/status",
           "category": "core",
           "isTested": false,
           "bucket": "9058",
           "job": "apisnoop.json",
           "release": "9058_apisnoop.json",
           "_id": "6OBwAVYGdU2tOKE8"
         },
         {
           "name": "readCoreV1NamespacedPersistentVolumeClaimStatus",
           "method": "get",
           "level": "stable",
           "test_tags": [],
           "tests": [],
           "description": "read status of the specified PersistentVolumeClaim",
           "path": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
           "category": "core",
           "isTested": false,
           "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable3-default",
           "job": "460",
           "release": "ci-kubernetes-e2e-gce-cos-k8sstable3-default_460",
           "_id": "6P78EQLmPvD27Ls7"
         },
         {
           "name": "listCoreV1NamespacedEvent",
           "method": "watch",
           "level": "stable",
           "test_tags": [],
           "tests": [],
           "description": "list or watch objects of kind Event",
           "path": "/api/v1/namespaces/{namespace}/events",
           "category": "core",
           "isTested": false,
           "bucket": "34681",
           "job": "apisnoop.json",
           "release": "34681_apisnoop.json",
           "_id": "6PGRw4iDxJrA4QaS"
         },
         {
           "name": "listSettingsV1alpha1NamespacedPodPreset",
           "method": "get",
           "level": "alpha",
           "test_tags": [],
           "tests": [],
           "description": "list or watch objects of kind PodPreset",
           "path": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets",
           "category": "settings",
           "isTested": true,
           "bucket": "1814",
           "job": "apisnoop.json",
           "release": "1814_apisnoop.json",
           "_id": "6PxTDVRO9ZhOsmXz"
         }
       ]

     #+END_SRC

      #+NAME: smallEndpointsObjectSample
      #+BEGIN_SRC js :tangle no
        var smallEndpointsObjectSample = {
          "6OBwAVYGdU2tOKE8": {
            "name": "readCoreV1NamespaceStatus",
            "method": "get",
            "level": "stable",
            "test_tags": [],
            "tests": [],
            "description": "read status of the specified Namespace",
            "path": "/api/v1/namespaces/{name}/status",
            "category": "core",
            "isTested": false,
            "bucket": "9058",
            "job": "apisnoop.json",
            "release": "9058_apisnoop.json",
            "_id": "6OBwAVYGdU2tOKE8"
          },
          "6P78EQLmPvD27Ls7": {
            "name": "readCoreV1NamespacedPersistentVolumeClaimStatus",
            "method": "get",
            "level": "stable",
            "test_tags": [],
            "tests": [],
            "description": "read status of the specified PersistentVolumeClaim",
            "path": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
            "category": "core",
            "isTested": false,
            "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable3-default",
            "job": "460",
            "release": "ci-kubernetes-e2e-gce-cos-k8sstable3-default_460",
            "_id": "6P78EQLmPvD27Ls7"
          },
          "6PGRw4iDxJrA4QaS": {
            "name": "listCoreV1NamespacedEvent",
            "method": "watch",
            "level": "stable",
            "test_tags": [],
            "tests": [],
            "description": "list or watch objects of kind Event",
            "path": "/api/v1/namespaces/{namespace}/events",
            "category": "core",
            "isTested": false,
            "bucket": "34681",
            "job": "apisnoop.json",
            "release": "34681_apisnoop.json",
            "_id": "6PGRw4iDxJrA4QaS"
          },
          "6PxTDVRO9ZhOsmXz": {
            "name": "listSettingsV1alpha1NamespacedPodPreset",
            "method": "get",
            "level": "alpha",
            "test_tags": [],
            "tests": [],
            "description": "list or watch objects of kind PodPreset",
            "path": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets",
            "category": "settings",
            "isTested": true,
            "bucket": "1814",
            "job": "apisnoop.json",
            "release": "1814_apisnoop.json",
            "_id": "6PxTDVRO9ZhOsmXz"
          }
        }
      #+END_SRC
     #+NAME: Endpoints Tests Setup
     #+BEGIN_SRC js :tangle ./src/bundles/endpoints.test.js
       import { Selector } from 'redux-testkit'
       import {composeBundlesRaw} from 'redux-bundler'
       import endpoints from './endpoints.js'
       import endpointsSample from '../test_resources/endpoints.json'

       const store = composeBundlesRaw(endpoints)
       <<smallEndpointsSample>>
       <<smallEndpointsObjectSample>>



       describe('Endpoints Selectors', () => {
         <<selectFilteredEndpoints Tests>>
         <<selectFilteredAndZoomedEndpoints Tests>>
         <<selectZoomedEndpoint Tests>>
         <<selectEndpointsById Tests>>
       })
     #+END_SRC
**** selectFilteredEndpoints

     *◊EndpointsFilter -> ◊Endpoints*
     /given all endpoints and a set filter, return only the endpoints that match that filter./

     We are doing a basic regex search, so we can perform a similar search using =jq= to get our proper results, and then use that to create our expected results


     We use this as inspiration for our tests

     #+NAME: selectFilteredEndpoints Tests
     #+BEGIN_SRC js :tangle no
       it('regex filters should return proper number of results', () => {
         var expectedLength = {
           APIG: 1,
           CORE: 0,
           Core: 7,
           Rbac: 4,
           Rzach: 0
         }
         var filterResult = endpoints.selectFilteredEndpoints.resultFunc
         expect(filterResult(endpointsSample, /APIG/).length).toEqual(expectedLength.APIG)
         expect(filterResult(endpointsSample, /CORE/).length).toEqual(expectedLength.CORE)
         expect(filterResult(endpointsSample, /Core/).length).toEqual(expectedLength.Core)
         expect(filterResult(endpointsSample, /Rbac/).length).toEqual(expectedLength.Rbac)
         expect(filterResult(endpointsSample, /Rzach/).length).toEqual(expectedLength.Rzach)
       })
     #+END_SRC

     #+NAME: selectFilteredEndpoints
     #+BEGIN_SRC js :tangle no
       selectFilteredEndpoints: createSelector(
         'selectEndpointsResource',
         'selectFilter',
         (endpoints, filter) => {
           if (endpoints == null) return null
           if (filter) {
             var filterAsRegexp = new RegExp(filter)
             endpoints = endpoints.filter(endpoint => filterAsRegexp.test(endpoint.name))
           }
           return endpoints
         }
       )
     #+END_SRC

**** selectFilteredAndZoomedEndpoints
     *◊Endpoints  ◊Zoom -> ◊Endpoints*
     _Given a set of endpoints, and a zoom level and location, return endpoints whose location matches the zoom._
     These endpoints may be filtered down, which does not change their structure, just the amount of entries being given to the selector

     If the depth is endpoint, we don't want to zoom into just that endpoint as it makes the sunburst look like a big donut.  So We only zoom into category.

     I can test this with =jq= first, and use the results to populate the expected Lengths

     #+NAME: selectFilteredAndZoomedEndpoints Tests
     #+BEGIN_SRC js :tangle no
       it('endpoints available should match current zoom depth and location', () => {
         // How many endpoints zoom should return
         var expectedLength = {
           toLevel: 13,
           toCategory: 7,
           toEndpoint: 7,
           none: 21
         }

         // Setup our Zooms
         var toLevel = {
           level: "stable",
           depth: "level"
         }

         var toCategory = {
           category: "core",
           level: "stable",
           depth: "category"
         }

         var toEndpoint = {
           level: "stable",
           category: "core",
           endpoint: "deleteCoreV1Namespace",
           depth: "endpoint"
         }

         var filterResult = endpoints.selectFilteredAndZoomedEndpoints.resultFunc
         expect(filterResult(endpointsSample, toLevel).length).toEqual(expectedLength.toLevel)
         expect(filterResult(endpointsSample, toCategory).length).toEqual(expectedLength.toCategory)
         expect(filterResult(endpointsSample, toEndpoint).length).toEqual(expectedLength.toEndpoint)
         expect(filterResult(endpointsSample).length).toEqual(expectedLength.none)
       })

     #+END_SRC

     #+NAME: selectFilteredAndZoomedEndpoints
     #+BEGIN_SRC js :tangle no
       selectFilteredAndZoomedEndpoints: createSelector(
         'selectFilteredEndpoints',
         'selectZoom',
         'selectEndpointsHitByFilteredUseragents',
         (endpoints, zoom, uaEndpoints) => {
           if (endpoints == null) return null
           if (zoom) {
             if (zoom.depth === 'endpoint' || zoom.depth === 'category') {
               endpoints = endpoints.filter(endpoint => endpoint.level === zoom.level && endpoint.category === zoom.category)
             } else if (zoom.depth === 'level') {
               endpoints = endpoints.filter(endpoint => endpoint.level === zoom.level)
             }
           }
           if (uaEndpoints.length) {
             endpoints = endpoints.filter(ep => uaEndpoints.some(ua => ua.name === ep.name && ua.method === ep.method))
           }
           return endpoints
         }
       )
     #+END_SRC

When running this with just a useragent filter, I get 900 results in 'selectEndpointsHitByFilteredUseragents' but only 400 results in these endpoints.  Why the sharp decrease?  These numbers should be the same, unless I am confusing some aspect of this.

**** selectZoomedEndpoint
     *◊Endpoints  ◊Zoom -> ◊Endpoint*
     _When the Zoom contains a depth of endpoint, return the endpoint at the zoom's location matching on endpoint's name._

     I realize with this, that it doesn't account for endpoints that have the same name, but may be a part of a different level or category.  Does that ever come up?

     #+NAME: selectZoomedEndpoint Tests
     #+BEGIN_SRC js :tangle no
       var zoomDepthCategory = {
         depth: "category",
         level: "stable",
         category: "core"
       }

       var zoomDepthEndpoint = {
         depth: "endpoint",
         level: "stable",
         category: "core",
         name: "listCoreV1NamespacedEvent"
       }

       var zoomExpectedEndpoint =  {
         "name": "listCoreV1NamespacedEvent",
         "method": "watch",
         "level": "stable",
         "test_tags": [],
         "tests": [],
         "description": "list or watch objects of kind Event",
         "path": "/api/v1/namespaces/{namespace}/events",
         "category": "core",
         "isTested": false,
         "bucket": "34681",
         "job": "apisnoop.json",
         "release": "34681_apisnoop.json",
         "_id": "6PGRw4iDxJrA4QaS"
       }

       it('zoomedEndpoint returns nothing if there are no endpoints', () => {
         var filterResult = endpoints.selectZoomedEndpoint.resultFunc
         expect(filterResult(null, zoomDepthEndpoint )).toEqual(null)
       })
       it('zoomedEndpoint returns nothing if Zoom depth is not endpoint', () => {
         var filterResult = endpoints.selectZoomedEndpoint.resultFunc
         expect(filterResult(endpointsSample, zoomDepthCategory)).toEqual(undefined)
       })
       it('zoomedEndpoint, with depth of endpoint, returns correct endpoint', () => {
         var filterResult = endpoints.selectZoomedEndpoint.resultFunc
         expect(filterResult(endpointsSample, zoomDepthEndpoint)).toEqual(zoomExpectedEndpoint)
       })

     #+END_SRC


     #+NAME: selectZoomedEndpoint
     #+BEGIN_SRC js :tangle no
       selectZoomedEndpoint: createSelector(
         'selectEndpointsResource',
         'selectZoom',
         (endpoints,zoom) => {
           if (endpoints == null) return null
           if (zoom == null | zoom === undefined) return null
           if (zoom.depth === 'endpoint') {
             var zoomedEndpoint = endpoints.find(endpoint => endpoint.name === zoom.name)
             return zoomedEndpoint
           }
         }
       )
     #+END_SRC

**** selectEndpointsById
     *◊Endpoints -> ◊EndpointsObject*
     _Given a set of endpoints, returns EndpointsObject containing only this set, each entry a value of its id_


      #+NAME: selectEndpointsById Tests
      #+BEGIN_SRC js :tangle no
        // setup selectEndpointsById Tests
        var endpointsByIdSelector = endpoints.selectEndpointsById.resultFunc
        it('endpointsById returns null if there are no endpoints', () => {
          expect(endpointsByIdSelector()).toEqual(null)
        })

        it('endpointsById  returns EndpointObject with correct set of endpoints', () => {
          expect(endpointsByIdSelector(smallEndpointsSample)).toEqual(smallEndpointsObjectSample)
        })


      #+END_SRC

     #+NAME: selectEndpointsById
     #+BEGIN_SRC js :tangle no
       selectEndpointsById: createSelector(
         'selectFilteredAndZoomedEndpoints',
         (endpoints) => {
           if (endpoints == null) return null
           return keyBy(endpoints, '_id')
         }
       )
     #+END_SRC
**** selectEndpointsByLevelAndCategoryAndNameAndMethod
     #+NAME: selectEndpointsByLevelAndCategoryAndNameAndMethod
     #+BEGIN_SRC js :tangle no
       selectEndpointsByLevelAndCategoryAndNameAndMethod: createSelector(
         'selectEndpointsById',
         (endpointsById) => {
           var endpointsByLevel = groupBy(endpointsById, 'level')
           return mapValues(endpointsByLevel, endpointsInLevel => {
             var endpointsByCategory = groupBy(endpointsInLevel, 'category')
             return mapValues(endpointsByCategory, endpointsInCategory => {
               var endpointsByName = groupBy(endpointsInCategory, 'name')
               return mapValues(endpointsByName, endpointsInName => {
                 return keyBy(endpointsInName, 'method')
               })
             })
           })
         }
       )
     #+END_SRC
**** selectEndpointsWithTestCoverage
     #+NAME: selectEndpointsWithTestCoverage
     #+BEGIN_SRC js :tangle no
       selectEndpointsWithTestCoverage: createSelector(
         'selectEndpointsById',
         (endpointsById) => {
           var endpointsByLevel = groupBy(endpointsById, 'level')
           var coverage = calculateCoverage(endpointsById)
           return Object.assign({},{coverage}, mapValues(endpointsByLevel, endpointsInLevel => {
             var endpointsByCategory = groupBy(endpointsInLevel, 'category')
             var coverage = calculateCoverage(endpointsInLevel)
             return Object.assign({}, {coverage}, mapValues(endpointsByCategory, endpointsInCategory => {
               var endpointsByName = groupBy(endpointsInCategory, 'name')
               var coverage = calculateCoverage(endpointsInCategory)
               return Object.assign({}, {coverage}, mapValues(endpointsByName, endpointsInName => {
                 var methods = keyBy(endpointsInName, 'method')
                 return mapValues(methods, method => {
                   var coverage = method.test_tags ? method.test_tags : [] // display empty array if untested, so chart don't break.
                   return Object.assign({}, {coverage}, method)
                 })
               }))
             }))
           }))
         }
       )
     #+END_SRC
**** selectActiveEndpoint
     #+NAME: selectActiveEndpoint
     #+BEGIN_SRC js :tangle no
       selectActiveEndpoint: createSelector(
         'selectEndpointsResource',
         'selectQueryObject',
         'selectZoom',
         (endpoints, query, zoom) => {
           if (endpoints == null) return null
           if (zoom && zoom.depth === 'endpoint') {
             return endpoints.find(endpoint => {
               return (endpoint.name === zoom.name) && (endpoint.category === zoom.category) && (endpoint.level === zoom.level)
             })
           } else {
             return endpoints.find(endpoint => {
               return (endpoint.name === query.name) && (endpoint.category === query.category) && (endpoint.level === query.level)
             })
           }
         }
       )
     #+END_SRC

*** Filter
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/filter.js :noweb yes
    :END:
    This is concerned with [[https://github.com/cncf/apisnoop/issues/67][ticket #67, filtering endpoints by regex.]]    There is more info in [[*Be Able to filter all endpoints by some regular expression][Our Todos Section]] about this.  We want to apply a filter that can be set across releases, where the sunburst only displays the endpoints whose name includes the text in this filter.
****  Imports and Layout
    #+NAME: Filter Bundle
    #+BEGIN_SRC js
    import { createSelector } from 'redux-bundler'
      export default {
        name: 'filter',
        <<Filter Reducer>>,
        <<Filter Selectors>>
      }
    #+END_SRC
****  Reducer
     TODO: the filter is hard-coded, and then gets added to the query object.  This is wrong.  We want no filter by default, and then a way to carry it across different releases if it is set.  So there must be some way to determine it based on the current queryObject.
     #+NAME: Filter Reducer
     #+BEGIN_SRC js :tangle no
       getReducer: () => {
         const initialState = {
         }
         return (state=initialState, action) => {
           return state
         }
       }
     #+END_SRC
****  Selectors
     #+NAME: Filter Selectors
     #+BEGIN_SRC js :tangle no
       selectFilter: createSelector(
         'selectQueryObject',
         (query) => {
           if (query == null) return null
           if (query.filter == null | query.filter === undefined) return null
           return query.filter
         }
       )
     #+END_SRC

*** Releases Index Resource
    #+NAME: releases-index-resource.js
    #+BEGIN_SRC js :tangle ./src/bundles/releases-index-resource.js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'releasesIndex',
        getPromise: ({ client, getState }) => {
          return fetchReleasesIndex(client)
        }
      })

      bundle.reactReleasesIndexFetch = createSelector(
        'selectReleasesIndexShouldUpdate',
        (shouldUpdate) => {
          if (shouldUpdate) {
            return { actionCreator: 'doFetchReleasesIndex' }
          }
        }
      )

      export default bundle

      function fetchReleasesIndex (client) {
        return client.service('releases').find()
      }
    #+END_SRC
*** Releases

    Releases draw from our =api/v1/releases= endpoint, which holds the metadata around the release and the bucket/job it's pulling from.

    #+NAME: releases.js
    #+BEGIN_SRC js :tangle ./src/bundles/releases.js
      import { createSelector } from 'redux-bundler'
      import {
        filter,
        find,
        keyBy,
        sortBy} from 'lodash'

      export default {
        name: 'releases',
        init: (store) => {
          store.subscribeToSelectors(
            ['selectCurrentReleaseName'],
            (currentReleaseName) => {
              store.doMarkCurrentReleaseAsOutdated()
              store.doMarkEndpointsResourceAsOutdated()
              store.doMarkTestsResourceAsOutdated()
            }
          )
        },
        getReducer: () => {
          const initialState = {}

          return (state = initialState, action = {}) => {
            return state;
          }
        },
        selectMasterRelease: createSelector(
          'selectReleasesIndex',
          (releasesIndex) => {
            if (releasesIndex == null) return null
            var masterBucket = releasesIndex.filter(release => release.bucket.includes("gci-gce"))
            var masterBucketSorted = sortBy(masterBucket, (job) => parseInt(job.job))
            return masterBucketSorted[0]
          }
        ),
        selectCurrentReleaseName: createSelector(
          'selectRouteParams',
          'selectMasterRelease',
          (routeParams, masterRelease) => {
            if (masterRelease == null) return null
            return routeParams.releaseName || masterRelease.name
          }
        ),
        selectCurrentReleaseId: createSelector(
          'selectCurrentReleaseName',
          'selectReleasesIndex',
          (currentReleaseName, releasesIndex) => {
            if (releasesIndex == null) return null
            const release = releasesIndex.find(release => {
              return release.name === currentReleaseName
            })
            return release == null ? null : release._id
          }
        ),
        selectReleasesIndexByName: createSelector(
          'selectReleasesIndex',
          releasesIndex => keyBy(releasesIndex, 'name')
        ),
        selectCurrentReleaseObject: createSelector(
          'selectCurrentReleaseName',
          'selectReleasesIndexByName',
          (currentReleaseName, releasesIndex) =>  {
            if (releasesIndex == null) return null
            return find(releasesIndex, (release) => {
              return release.name  === currentReleaseName
            })
          }
        ),
        selectCurrentReleaseSpyglassLink: createSelector(
          'selectCurrentReleaseObject',
          (currentRelease) => {
            if (currentRelease == null) return null
            var bucketJobPath = currentRelease.name.replace('_', '/')
            var spyglassBase = 'https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/'
            return spyglassBase + bucketJobPath
          }
        ),
        selectCurrentReleaseAPISnoopLink: createSelector(
          'selectCurrentReleaseSpyglassLink',
          (spyglassLink) => {
            if (spyglassLink== null) return null
            var spyglassBase = 'https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/'
            var APISnoopBase = 'https://storage.googleapis.com/apisnoop/dev/'
            return spyglassLink.replace(spyglassBase, APISnoopBase) + "/apisnoop.json"
          }
        ),
        selectReleasesIndexMasterOnly: createSelector(
          'selectReleasesIndexByName',
          'selectMasterRelease',
          (releasesIndex, masterRelease) => {
            if (releasesIndex == null) return null
            return filter(releasesIndex, (release) => {
              return release.name === masterRelease.name
            })
          }
        ),
        selectReleasesIndexSansMaster: createSelector(
          'selectReleasesIndexByName',
          'selectMasterRelease',
          (releasesIndex, masterRelease) => {
            if (releasesIndex == null) return null
            return filter(releasesIndex, (release) => {
              return release.name !== masterRelease.name
            })
          }
        ),
        selectReleasesIndexSorted: createSelector(
          'selectReleasesIndexSansMaster',
          (releasesIndex) => {
            if (releasesIndex == null) return null
            return releasesIndex.sort((a, b) => {
              return a.version.localeCompare(b.version, undefined, {numeric: true})
            })
          }
        )
      }

    #+END_SRC
*** Routes
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/routes.js :noweb yes
    :END:
    #+NAME: routing
    #+BEGIN_SRC js
      import MainPage from '../pages/main-page'
      import NotFound from '../components/not-found'

      import { createRouteBundle } from 'redux-bundler'

      export default createRouteBundle({
        '/': MainPage,
        '/:releaseName': MainPage,
        '*': NotFound
      })
    #+END_SRC
*** Sunburst
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/sunburst.js :noweb yes
    :END:
****  Imports and Layout
    #+NAME: charts.js
    #+BEGIN_SRC js
      import { fadeColor } from '../lib/utils'
      import { createSelector } from 'redux-bundler'
      import {
        forEach,
        includes,
        map,
        orderBy,
        reduce,
        sortBy,
        values
      } from 'lodash'


      export default {
        name: 'charts',
        <<Sunburst Selectors>>
      }

      <<Sunburst Helper Functions>>
    #+END_SRC
****  Selectors
   #+NAME: Sunburst Selectors
   #+BEGIN_SRC js :tangle no
     selectSunburst: createSelector(
       'selectEndpointsByLevelAndCategoryAndNameAndMethod',
       'selectLevelColours',
       'selectCategoryColours',
       'selectQueryObject',
       'selectZoomedEndpoint',
       (endpointsByLevelAndCategoryAndNameAndMethod, levelColours, categoryColours, queryObject, zoomedEndpoint) => {
         return {
           name: 'root',
           children: map(endpointsByLevelAndCategoryAndNameAndMethod, (endpointsByCategoryAndNameAndMethod, level) => {
             return {
               name: level,
               color: determineLevelColours(queryObject, levelColours, level),
               children: categoriesSortedByEndpointCount(endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint)
             }
           })
         }
       }
     ),
     selectSunburstSorted: createSelector(
       'selectSunburst',
       (sunburst) => {
         var sortedLevels = orderBy(sunburst.children, 'name', 'desc')
         sunburst.children = sortedLevels
         return sunburst
       }
     ),
     selectInteriorLabel: createSelector(
       'selectQueryObject',
       'selectEndpointsWithTestCoverage',
       (query, endpoints) => {
         if(endpoints == null) return null
         var nameAndCoverageInfo = determineNameAndCoverageInfo(query, endpoints)
         return nameAndCoverageInfo
       }
     ),
     selectLabelStyle: () => {
       return {
         PERCENTAGE: {
           fontSize: '1.3em',
           textAnchor: 'middle'
         },
         FRACTION: {
           fontSize: '1.2em,',
           textAnchor: 'middle'
         },
         PATH: {
           fontSize: '1em',
           textAnchor: 'middle'
         },
         DESCRIPTION: {
           fontSize: '0.9em',
           fontFamily: 'IBM Plex Mono',
           textAnchor: 'middle',
           width: '20px'
         }
       }
     }
    #+END_SRC
***  Helper Functions
     The helper functions are grooooooss right now.  It feels far too nested, and I am passing along the query object to too many places.  I feel the color addition should e done as a selector possibly and not hae it be nested within here.-

     This is gross for how many nested functions there are, and that weird confusion between query and zoom.  Is there a better way to handle this?  Essentially, we wanna be able to zoom into a category, and still have the colors and endpoints show based on the query....but when we are zoomed into an endpoint, then there shouldn't be any query happening....it should be noted as 'locked on'.  This whole section smells awful, and would be good to have another set of javascripter eyes on it.

     #+NAME: Removed Functions
     #+BEGIN_SRC js :tangle no
       // I likely don't need these anymore, but dont' wanna fully remove them yet

       function relevantValue (value, zoom, query) {
         if (zoom[value] !== undefined) {
           return zoom[value]
         }
         return query[value]
       }

     #+END_SRC

     #+NAME: Sunburst Helper Functions
     #+BEGIN_SRC js :tangle no
       function categoriesSortedByEndpointCount (endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint) {
         var categories = categoriesWithEndpointsAsChildren(endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint)
         return orderBy(categories, (category) => category.children.length, ['desc'])
       }

       function categoriesWithEndpointsAsChildren (endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint) {
         return map(endpointsByCategoryAndNameAndMethod, (endpointsByNameAndMethod, category) => {
           return {
             name: category,
             color: determineCategoryColours(queryObject, categoryColours, category, level),
             children: endpointsSortedByConformance(endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint)
           }
         })
       }

       function endpointsSortedByConformance (endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint) {
         var endpoints = createEndpointAndMethod(endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint)
         var sortedEndpoints = sortBy(endpoints, [
           (endpoint) => endpoint.tested === 'untested', (endpoint) => endpoint.isConformance !== 'conformance',
           (endpoint) => endpoint.testTagCount
         ])
         return sortedEndpoints
       }

       function createEndpointAndMethod(endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint) {
         return values(reduce(
           endpointsByNameAndMethod,
           (sofar, endpointsByMethod, name) => {
             sofar = fillOutMethodInfo(sofar, endpointsByMethod, category, name, level, queryObject, categoryColours, zoomedEndpoint)
             return sofar
           },
           {}
         ))
       }

       function fillOutMethodInfo (sofar, endpointsByMethod, category, name, level, queryObject, categoryColours, zoomedEndpoint) {
         forEach(endpointsByMethod, (endpoint, method) => {
           var { isTested } = endpoint
           var isConformance = checkForConformance(endpoint.test_tags)
           var path = `${name}/${method}`
           var size = (sofar[path] == null) ? 1 : sofar[path].size + 1
           var initialColor = calculateInitialColor(endpoint, isConformance, categoryColours)
           sofar[path] = {
             name,
             parentName: category,
             testTagCount: endpoint.test_tags.length,
             tested: isTested ? 'tested' : 'untested',
             isConformance: isConformance ? "conformance" : "not conformance",
             size,
             color: isTested ? determineEndpointColours(queryObject, initialColor, category, level, endpoint, zoomedEndpoint) : 'rgba(244,244,244, 1)',
           }
         })
         return sofar
       }

       function checkForConformance (test_tags) {
         var tagsAsStrings = test_tags.map(tag => tag.replace(/\[|]/g,''))
         return includes(tagsAsStrings, 'Conformance')
       }

       function determineLevelColours (query, colours, level) {
         if (query.level === undefined) {
           return colours[level]
         } else if (query.level === level){
           return colours[level]
         } else {
           return fadeColor(colours[level], '0.1')
         }
       }
       function determineCategoryColours (query, categoryColours, category, level) {
         if (query.level === undefined) {
           return categoryColours[`category.${category}`]
         } else if (query.level === level && query.category === category){
           return categoryColours[`category.${category}`]
         } else {
           return fadeColor(categoryColours[`category.${category}`], '0.1')
         }
       }
       function determineEndpointColours (query, color, category, level, endpoint, zoomedEndpoint) {
         if (zoomedEndpoint != null && zoomedEndpoint !== undefined) {
           if (zoomedEndpoint.name === endpoint.name) {
             return fadeColor(color, '0.7')
           } else {
             return fadeColor(color, '0.1')
           }
         }
         else if (query.level === undefined) {
           return color
         } else if (query.level === level && query.category === category && query.name === endpoint.name){
           return color
         } else {
           return fadeColor(color, '0.1')
         }
       }
       function calculateInitialColor (endpoint, isConformance, categoryColours) {
         if (endpoint.isTested && isConformance)  {
           return categoryColours[`category.${endpoint.category}`]
         } else  if( endpoint.isTested && !isConformance) {
           var color = categoryColours[`category.${endpoint.category}`]
           var fadedColor = fadeColor(color, '0.2')
           return fadedColor
         } else {
           return 'rgba(244, 244, 244, 1)'
         }
       }

       function determineNameAndCoverageInfo (query, endpoints) {
        // check our query to see how far in the path we are.
        // If a response is null, it means its not a part of the path
        // therefore, we display the preceding level's info.
         if (endpoints == null) return null // this makes sure the endpoints have loaded.
         if (query && query.level === undefined) {
           var name = ''
           var coverage = endpoints.coverage
           var tested = false
           var endpoint = false
           var description= ''
         }else if (query.level && query.category === undefined) {
           name = query.level
           coverage = endpoints[query.level].coverage
           description= ''
         } else if (query.level && query.category && query.name === undefined) {
           name = query.category
           coverage = endpoints[query.level][query.category].coverage
           description= ''
         } else {
           var endpointInQuestion = endpoints[query.level][query.category][query.name]
           name = query.name
           description= determineDescription(endpoints[query.level][query.category][query.name])
           tested = determineTested(endpointInQuestion)
           coverage = endpointInQuestion.coverage
           endpoint = true
         }
         return {name, coverage, description, tested, endpoint}
       }

       function determineDescription (endpoint) {
         var method = Object.keys(endpoint)[0]
         return endpoint[method].description
       }
       function determineTested (endpoint) {
         var method = Object.keys(endpoint)[0]
         return endpoint[method].isTested ? 'Tested' : 'Untested'
       }

     #+END_SRC
****  Thoughts on colour
     Every node has a color that renders in our sunburst.  That color can be in two states: bright if it is focused on, and faded if it is not.  Before, we figured out this color in the d3 visualization by tracing through the keypath every time.  What I feel like we could do now is to check in the sunburst selectors whether or not that node is part of the current URL query. If it is, give it a bright color.  If it is not, give it a faded color.

This means we have to be aware of the node's parent too, because methods and categories are shared across each level.  So you ahve to do a thing of 'are you a part of the path and is your parent also a part of the path, and is your parents.parent a part of the path?  If so, do this color.

I feel this would be easiest with three functions, even though they're kinda similar.  determineLevelColor(level), determineCategoryColor(category), determineEndpointColor(endpoint).  For the level, it just checks whether there is a query and if it's a part of it.  Category checks if there's a query and if it and the level are a part of it.  endpoint the same, but level and category too.

I've now done this, but the functions feel v. fragile to me, like there's a simpler way to go about it that I am just not seeing.  I think the problem is partially that we have a hella nested function by necessity--since we are making a sunburst which is built on nesting, so things are going to feel strangely convoluted inherently?  But it would still be nice to refactor this for simplicity.
*** Summary
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/summary.js :noweb yes
    :END:
****  Imports and Layout
    #+NAME: Summary Bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'

      export default {
        name: 'summary',
        <<Summary Selector>>
      }
    #+END_SRC
k*** Selector
     #+NAME: Summary Selector
     #+BEGIN_SRC js :tangle no
       selectPath: createSelector(
         'selectActiveEndpoint',
         'selectQueryObject',
         'selectZoom',
         (endpoint, query, zoom) => {
           var path = {}
           if (zoom == null && query.level === undefined) {
             path = {
               level: '',
               category: '',
               name: ''
             }
           } else if (zoom !== null && query.level === undefined) {
             path = {
               level: zoom.level,
               category: zoom.category,
               name: zoom.name
             }
           } else {
             path = {
               level: query.level,
               category: query.category,
               name: query.name
             }
           }
           return path
         }
       )
     #+END_SRC

     With selectors, the values are given all at once as soon as  the page starts up.   Which will be before the fetch has returned for our data.  We need to make sure to not try to ask something of the data before it's returned, and so to include the 'if null return null' for both

     We are also taking just the first method in the endpoint....Which means the endpoint is also only showiung in the sunburst for it's own name, and not its methods.  For most of them they will only have a single method, but others do not.  Thed question then is whether each endpoint and method should be shown separately, or whether when you hover over it says how many methods it has and how many of them are tested....the case where an endpoint's put method is tested but its read method is not or some thing like that.  Not sure the best way to tackle this, like what the user would be expecting.

     we want to select the tests from our testsResource based on what's in our active tests

*** Tests Resource
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/tests-resource.js :noweb yes
    :END:

    #+NAME: tests resource
    #+BEGIN_SRC js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'testsResource',
        getPromise: ({ client, store }) => {
          const currentReleaseName = store.selectCurrentReleaseName()
          return fetchTestsByReleaseName(client, currentReleaseName)
        }
      })

      bundle.reactTestsResourceFetch = createSelector(
        'selectTestsResourceShouldUpdate',
        (shouldUpdate, currentReleaseId) => {
          if (!shouldUpdate) return
          return { actionCreator: 'doFetchTestsResource' }
        }
      )


      export default bundle

      function fetchTestsByReleaseName (client, releaseName) {
        return client.service('tests').find({
          query: {
            release: releaseName
          }
        })
      }

    #+END_SRC

*** Tests
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/tests.js :noweb yes
    :END:
****  Imports and Layout
    #+NAME: Tests Bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import { trim } from 'lodash'

      export default {
        name: 'tests',
        <<Tests Reducer>>,
        <<Tests Selector>>
      }
    #+END_SRC
****  Reducer
     I dont' know how much of the old code we'll really need for this now, so I'm putting just a basic amount into the reducer.
     #+NAME: Tests Reducer
     #+BEGIN_SRC js :tangle no
       getReducer: () => {
         const initialState = {
         }
         return (state=initialState, action) => {
           return state
         }
       }
     #+END_SRC
****  Selector
     #+NAME: Tests Selector
     #+BEGIN_SRC js :tangle no
       selectTestTagsIndexRaw: createSelector(
         'selectActiveEndpoint',
         (endpoint) =>{
             if (endpoint == null) return null
             return endpoint.test_tags
         }
       ),
       selectTestTagsIndex: createSelector(
         'selectTestTagsIndexRaw',
         (testTagsRaw) => {
           if (testTagsRaw == null) return null
           return testTagsRaw.map(rawTag => {
             return trim(rawTag, '[]')
           }
          )
         }
       ),
       selectActiveTestsIndex: createSelector(
         'selectActiveEndpoint',
         'selectTestsResource',
         (endpoint, testsResource) => {
           if (endpoint == null || testsResource == null) return null
           var activeTests = testsResource.filter(test => endpoint.tests.includes(test.name))
           return activeTests
         }
       ),
       selectActiveTestsNumber: createSelector(
         'selectActiveTestsIndex',
         (tests) => {
           if (tests == null) return null
           return tests.length
         }
       ),
       selectActiveTest: createSelector(
         'selectQueryObject',
         'selectTestsResource',
         (query, tests) => {
           if (tests == null) return null
           return tests.find(test => test._id === query.test)
         }
       )
     #+END_SRC

     With selectors, the values are given all at once as soon as  the page starts up.   Which will be before the fetch has returned for our data.  We need to make sure to not try to ask something of the data before it's returned, and so to include the 'if null return null' for both

     We are also taking just the first method in the endpoint....Which means the endpoint is also only showiung in the sunburst for it's own name, and not its methods.  For most of them they will only have a single method, but others do not.  Thed question then is whether each endpoint and method should be shown separately, or whether when you hover over it says how many methods it has and how many of them are tested....the case where an endpoint's put method is tested but its read method is not or some thing like that.  Not sure the best way to tackle this, like what the user would be expecting.

     we want to select the tests from our testsResource based on what's in our active tests
*** Useragents Resource
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/useragents-resource.js :noweb yes
    :END:

    This is the same pattern as endpoints, releases, and tests.  We set up an async resource bundle that has the fetching and reacting built in.  Whenever a fetch is triggered by switching to a new release, than we query our feathers for the useragents path and grab only the ones that fit this release.

    #+NAME: useragents resource
    #+BEGIN_SRC js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'useragentsResource',
        getPromise: ({ client, store }) => {
          const currentReleaseName = store.selectCurrentReleaseName()
          return fetchUseragentsByReleaseName(client, currentReleaseName)
        }
      })

      bundle.reactUseragentsResourceFetch = createSelector(
        'selectUseragentsResourceShouldUpdate',
        (shouldUpdate, currentReleaseId) => {
          if (!shouldUpdate) return
          return { actionCreator: 'doFetchUseragentsResource' }
        }
      )

      function fetchUseragentsByReleaseName (client, releaseName) {
        return client.service('useragents').find({
          query: {
            release: releaseName
          }
        })
      }

      export default bundle
    #+END_SRC
*** Useragents
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/useragents.js :noweb yes
    :END:

    Holds our filtered inputs both when the filter is just input in the search form and when it is set as a query.
    I feel these need to be two separate bundles, since one is temporary/changable and the other is the set query .
    For the one being changable, we only need the useragent names, all the other info isn't really that important.

****  Layout
    #+NAME: Useragents bundle
    #+BEGIN_SRC js
      import { filter,
               map,
               uniq } from 'lodash'
      import { createSelector } from 'redux-bundler'
      export default {
        name: 'useragents',
        <<Useragents Reducer>>,
        <<selectUseragentInput>>,
        <<selectUseragentsFilteredByInput>>,
        <<selectUseragentsFilteredByQuery>>,
        <<selectEndpointsHitByFilteredUseragents>>,
        <<doUpdateUseragentsInput>>
      }
    #+END_SRC

****  Tests Layout
     #+NAME: Useragents Tests Setup
     #+BEGIN_SRC js :tangle ./src/bundles/useragents.test.js
       import { Reducer, Selector } from 'redux-testkit'
       import { map } from 'lodash'
       import {composeBundlesRaw} from 'redux-bundler'
       import createStore from './index.js'
       import useragents from './useragents.js'
       import useragentsResource from './useragents-resource.js'
       import useragentsSample from '../test_resources/useragents.json'
       <<useragentsNamesSample>>

       var store = createStore()
       var state = store.getState()

       const initialState = {
         filterInput: ''
       }

       describe('Useragents Reducer', () => {
         <<Useragents Reducer Test>>
       })

       describe('Useragents Selectors', () => {
         <<selectUseragentInput Test>>
         <<selectUseragentsFilteredByInput Test>>
         <<selectUseragentsFilteredByQuery Test>>
       })

     #+END_SRC

****  Useragents Reducer

     **Action -> UseragentState**
     Received action and its payload and returns the new Useragentstate(containing changes based on payload).
     If no action is given, returns the initial state.

     #+NAME: Useragents Reducer Test
     #+BEGIN_SRC js :tangle no
       it('should have initial state', () => {
         expect(state.useragents).toEqual(initialState)
       })
       it('should handle USERAGENT_INPUT_UPDATED', () => {
         const payload = 'k^sjdj'
         const action = {type: 'USERAGENT_INPUT_UPDATED', payload}
         const result = {filterInput: payload}
         Reducer(useragents.getReducer()).expect(action).toReturnState(result)
       })
     #+END_SRC

     #+NAME: Useragents Reducer
     #+BEGIN_SRC js :tangle no
       getReducer: () => {
         const initialState = {
           filterInput: ''
         }
         return (state=initialState, {type, payload}) => {
           if (type  === 'USERAGENT_INPUT_UPDATED') {
             return {...state, filterInput: payload}
           }
           return state
         }
       }
     #+END_SRC

**** selectUseragentInput
     **UseragentState -> String**
     _selects the input state from useragent_
     #+NAME: selectUseragentInput Test
     #+BEGIN_SRC js :tangle no
       it('should return a string for selectUseragentInput', () => {
         const stateA = {useragents: {filterInput: ''}}
         const stateB = {useragents: {filterInput: 'r^eg&x'}}
         var selectInput = useragents.selectUseragentsInput

         expect(selectInput(stateA)).toEqual(stateA.useragents.filterInput)
         expect(selectInput(stateB)).toEqual(stateB.useragents.filterInput)
       })

     #+END_SRC
     #+NAME: selectUseragentInput
     #+BEGIN_SRC js :tangle no
       selectUseragentsInput: (state) => state.useragents.filterInput
     #+END_SRC

**** selectUseragentsFilteredByInput
     **Regex -> ◊UseragentsNames**
     _Given a regex filter, return an array of names that match this regex_
     #+NAME: useragentsNamesSample
     #+BEGIN_SRC js :tangle no
       var useragentsNamesSample  = [
         "kubectl/v1.13.3",
         "kube-apiserver/v1.15.0",
         "kube-proxy/v1.13.5",
         "node-problem-detector/v0.5.0-49-gfb81368",
         "nfs-provisioner/v0.0.0"
       ]
     #+END_SRC

     #+NAME: selectUseragentsFilteredByInput Test
     #+BEGIN_SRC js :tangle no
       it('should return all useragent names if no filter is set', () => {
           <<useragentsNamesSample>>
           var filter = ''
           var filterB = 'kube'
           var filteredSample = ["kubectl/v1.13.3", "kube-apiserver/v1.15.0", "kube-proxy/v1.13.5"]

           var selectUseragents = useragents.selectUseragentsFilteredByInput.resultFunc

            expect(selectUseragents(useragentsSample, filter)).toEqual(useragentsNamesSample)
            expect(selectUseragents(useragentsSample, filterB)).toEqual(filteredSample)

       })

     #+END_SRC

     #+NAME: selectUseragentsFilteredByInput
     #+BEGIN_SRC js :tangle no
       selectUseragentsFilteredByInput: createSelector(
         'selectUseragentsResource',
         'selectUseragentsInput',
         (useragents, input) => {
           var useragentsNames = map(useragents, 'name')
           if (input === '') return []

           return useragentsNames.filter(ua => {
             var inputAsRegex = new RegExp(input)
             return inputAsRegex.test(ua)
           })
         }
       )

     #+END_SRC

**** selectUseragentsFilteredByQuery
     **◊Useragents ◊Query -> ◊Useragents**
     _Return a filtered Useragents based on query.useragent_
     #+BEGIN_SRC shell :dir ./src/test_resources :results output :tangle no
       cat useragents.json | jq 'map(.name)'
     #+END_SRC


     #+NAME: selectUseragentsFilteredByQuery Test
     #+BEGIN_SRC js :tangle no
       it('should return useragents whose name matches query', () => {
         var noFilter = {useragent: ''}
         var expectedResult = [
           "kubectl/v1.13.3",
           "kube-apiserver/v1.15.0",
           "kube-proxy/v1.13.5",
           "node-problem-detector/v0.5.0-49-gfb81368",
           "nfs-provisioner/v0.0.0"
         ]

         var filter = {useragent: 'kube'}
         var expectedFilteredResult = [
           "kubectl/v1.13.3",
           "kube-apiserver/v1.15.0",
           "kube-proxy/v1.13.5"
         ]

         var selectQueryFilter = useragents.selectUseragentsFilteredByQuery.resultFunc
         var unFilteredResult = map(selectQueryFilter(useragentsSample, noFilter), 'name')
         var filteredResult = map(selectQueryFilter(useragentsSample, filter), 'name')
         expect(filteredResult).toEqual(expectedFilteredResult)
         expect(unFilteredResult).toEqual(expectedResult)
       })
     #+END_SRC

      #+NAME: selectUseragentsFilteredByQuery
      #+BEGIN_SRC js :tangle no
        selectUseragentsFilteredByQuery: createSelector(
          'selectUseragentsResource',
          'selectQueryObject',
          (useragents, query) => {
            if (useragents == null || !query) return []
            if (query.useragents && query.useragents.length) {
              return filter(useragents, (ua) => {
                var inputAsRegex = new RegExp(query.useragents)
                return inputAsRegex.test(ua.name)
              })
            } else {
              return []
            }
          }
        )
      #+END_SRC

**** selectEndpointsHitByFilteredUseragents
     **◊Useragents -> ◊Endpoints**
     _Given a set of useragents that contain endpoints, return an array of just the unique endpoints._
     This won't be the ultimate filter.  Rather, we wanna setup a nice selection to use in our endpoint bundle as a filter.  So the key here is to make an array of endpoints that is useful for future filtering.
     Our useragents contains endpoints, which themselves contains keys matching their method.
     #+BEGIN_EXAMPLE json
       {
         "name": "kube-apiserver/v1.15.0",
         "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable2-default",
         "job": "1961",
         "release": "ci-kubernetes-e2e-gce-cos-k8sstable2-default_1961",
         "_id": "2Jm2UxZMaAZ3i2NI"
         "endpoints": {
           "listCoreV1LimitRangeForAllNamespaces": {
             "watch": {
               "counter": 7
             },
             "get": {
               "counter": 1
             }
           }
         }
       }
     #+END_EXAMPLE
     But what we want is for the method to be a key to the endpoint.
     #+BEGIN_EXAMPLE json
       {
         "listCoreV1LimitRangeForAllNamespaces": {
           "method": "watch",
           "counter": 7,
           "name": "kube-apiserver/v1.15.0",
           "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable2-default",
           "job": "1961",
           "release": "ci-kubernetes-e2e-gce-cos-k8sstable2-default_1961"
         },
         "listCoreV1LimitRangeForAllNamespaces": {
           "method": "get",
           "counter": 1
           "name": "kube-apiserver/v1.15.0",
           "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable2-default",
           "job": "1961",
           "release": "ci-kubernetes-e2e-gce-cos-k8sstable2-default_1961"
         }
       }
     #+END_EXAMPLE

     In this way, we can just match our endpoints resource to this list, based on method, bucket, job, release.  That should be specific enough to be unique.

    #+NAME: selectEndpointsHitByFilteredUseragents
    #+BEGIN_SRC js :tangle no
      selectEndpointsHitByFilteredUseragents: createSelector(
        'selectUseragentsFilteredByQuery',
        (useragents) => {
          if (useragents == null) return null
          var endpointsHit = []
          var uaEndpointsOnly = map(useragents, "endpoints")
          for (var uaEntry of uaEndpointsOnly) {
            var endpointNames = Object.keys(uaEntry)
            for (var endpoint of endpointNames) {
              var methods = Object.keys(uaEntry[endpoint])
              for (var method of methods) {
                var useragent = useragents[uaEndpointsOnly.indexOf(uaEntry)]
                var endpointEntry = {
                  name: endpoint,
                  method: method,
                  release: useragent.release,
                  bucket: useragent.bucket,
                  job: useragent.job
                }
                endpointsHit.push(endpointEntry)
              }
            }
          }
          return uniq(endpointsHit)
        }
      )
    #+END_SRC

   NOTE this kinda works now, but I'm realizing that we don't need bucket,job,release...since we are only pulling ua's from a single release at the page load.  What we really need is to match on level, category, name, method...but the level and category are not a part of this.  Is it possible for an endoint to exist in beta/stable or in multiple categories?  If so, this would be inaccurate.

**** doUpdateUseragentInput
     **String -> Action**
     _Returns an action for our reducer with type "USERAGENT_INPUT_UPDATED' and String as payload_

     #+NAME: doUpdateUseragentsInput
     #+BEGIN_SRC js :tangle no
       doUpdateUseragentsInput: (payload) => ({dispatch}) => {
         dispatch({
           type: 'USERAGENT_INPUT_UPDATED',
           payload
         })
       }

     #+END_SRC

*** Config
    :PROPERTIES:
   :header-args: :tangle ./src/bundles/config.js :noweb yes
    :END:
    #+NAME: config.js
    #+BEGIN_SRC js
      import feathers from '@feathersjs/feathers'
      import RestClient from '@feathersjs/rest-client'
      import axios from 'axios'

      // TODO add envify as browserify transform
      const config = {
        backendUrl: process.env.REACT_APP_BACKEND_URL || '/api/v1'
      }

      export default {
        name: 'config',
        reducer: (state = config) => state,
        getExtraArgs: store => {
          return {
            config,
            client: createClient(config)
          }
        }
      }

      function createClient (config) {
        const restClient = RestClient(config.backendUrl)

        return feathers()
          .configure(restClient.axios(axios))
      }
    #+END_SRC
*** Zoom
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/zoom.js :noweb yes
    :END:
****  Imports and Layout
    #+NAME: Zoom Bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import { split } from 'lodash'

      import { propertiesWithValue } from '../lib/utils'

      export default {
        name: 'zoom',
        <<Zoom Selector>>
      }
    #+END_SRC
****  Selector
     #+NAME: Zoom Selector
     #+BEGIN_SRC js :tangle no
       selectZoomArray: createSelector(
         'selectQueryObject',
         (query) => {
           if (query == null) return null
           if (query.zoomed === undefined) return null
           return split(query.zoomed, '-')
         }
       ),
       selectZoom: createSelector(
         'selectZoomArray',
         (zoomArray) => {
           if  (zoomArray == null) return null
           var zoomRaw = {
             depth: zoomArray[0],
             level: zoomArray[1],
             category: zoomArray[2],
             name: zoomArray[3]
           }
           var zoom = propertiesWithValue(zoomRaw)
           return zoom
         }
       )
     #+END_SRC

     With selectors, the values are given all at once as soon as  the page starts up.   Which will be before the fetch has returned for our data.  We need to make sure to not try to ask something of the data before it's returned, and so to include the 'if null return null' for both

     We are also taking just the first method in the endpoint....Which means the endpoint is also only showiung in the sunburst for it's own name, and not its methods.  For most of them they will only have a single method, but others do not.  Thed question then is whether each endpoint and method should be shown separately, or whether when you hover over it says how many methods it has and how many of them are tested....the case where an endpoint's put method is tested but its read method is not or some thing like that.  Not sure the best way to tackle this, like what the user would be expecting.

     we want to select the tests from our testsResource based on what's in our active tests

** Components
*** App
    :PROPERTIES:
    :header-args: :tangle ./src/components/app.js
    :END:
    the initiatory component.  This is sort of the standard layout in which all other views are placed within.
    #+Name: App.js
    #+BEGIN_SRC js
      import React from 'react'
      import navHelper from 'internal-nav-helper'
      import { connect } from 'redux-bundler-react'

      import Header from './header'
      import Footer from './footer'

      export default connect(
        'doUpdateUrl',
        'selectRoute',
        ({ doUpdateUrl, route }) => {
          const CurrentPage = route
          return (
              <div onClick={navHelper(doUpdateUrl)}>
              <Header />
              <CurrentPage />
              <Footer />
              </div>
          )
        }
      )
    #+END_SRC

    If you compare this to the original app, you can see it is far less duplicated or strange code.  Everything is just held in the connect function, where we bring in our selectors and actions, and then reference them directly in our presentational component.
    #+NAME: original app
    #+BEGIN_SRC js :tangle no
      import React, { Component } from 'react'
      import { connect } from 'react-redux'
      import { createStructuredSelector } from 'reselect'


      import { selectReleaseNamesFromEndpoints, selectIsEndpointsReady, selectPage } from '../selectors'
      import { fetchEndpoints } from '../actions/endpoints'
      import { doFetchTests } from '../actions/tests'

      import Header from './header'
      import Footer from './footer'
      import ReleasesList from './releases-list.js'

      class App extends Component {

        componentDidMount(){
          this.props.fetchEndpoints()
          this.props.fetchTests()
        }

        render(){
          const {
            Page,
            releaseNames,
            endpointsReady
          } = this.props

          return (
            <div id='app'>
              <Header />
              {endpointsReady &&
               <div>
               <ReleasesList
                 releases={releaseNames}
               />
              <Page />
              </div>
              }
              {!endpointsReady &&
              <div className='min-vh-80'>
              <h3>Loading...</h3>
              </div>
              }
              <Footer />
            </div>
          )
        }
      }

      export default connect(
        createStructuredSelector({
          releaseNames: selectReleaseNamesFromEndpoints,
          endpointsReady: selectIsEndpointsReady,
          Page: selectPage
        }),
        {fetchEndpoints,
         fetchTests: doFetchTests
        })(App)
    #+END_SRC
*** Footer
    :PROPERTIES:
    :header-args: :tangle ./src/components/footer.js
    :END:
   #+NAME: Footer
   #+BEGIN_SRC js
     import React from 'react'

     export default () => (
         <footer className='w-100 flex flex-column flex-row-ns pt2 pb2 h3 pl4 pr4 items-center justify-between bg-black black shadow-3'>
         <div id='logo' className= 'flex flex-wrap items-center justify-center'>
         <a className='contain bg-cncf bg-center h-100 w4' href='https://cncf.io' title='leads to external cncf homepage'>
         <span className='o-0'>cncf</span>
         </a>
         <a className='contain bg-packet bg-center h-100 w4' href='https://packet.net' title='leads to external packet homepage'>
         <span className='o-0'>packet</span>
         </a>
         <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
         </div>
         <div id='source-code' className='flex items-center'>
         <a href='http://binder.hub.cncf.ci/v2/gh/cncf/apisnoop/master' target='_blank noopener noreferrer' title='external jupyter notebook' className='link f5 pl1 white'>See Data in Jupyter</a>
         </div>
         </footer>
     )
   #+END_SRC
*** Filter Container
    :PROPERTIES:
    :header-args: :tangle ./src/components/filter-container.js
    :END:
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   import FilterTag from './filter-tag'
   import FilterForm from './filter-form'

   function FilterContainer (props) {
     const {
       queryObject
     } = props

     return(
         <section id="filter-container" className="mb3">
         {queryObject.filter && <FilterTag filter={queryObject.filter}/>}
         {!queryObject.filter && <FilterForm />}
         </section>
     )
   }
   export default connect(
     "selectQueryObject",
     FilterContainer
   )

 #+END_SRC
*** Filter Tag
    :PROPERTIES:
    :header-args: :tangle ./src/components/filter-tag.js
    :END:
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   function FilterTag (props) {
     const {
       doUpdateQuery,
       filter
     } = props

     return(
         <div id='filter-tag'>
         <p>Filtered By:
          <span className="no-underline near-black bg-light-green inline-flex items-center ma2 tc br2 ph2">
          <span className="f6 ml3 pr2">{filter}</span>
          <button className="but-no-style dib moon-gray" onClick={handleClick}>x</button>
          </span>
          </p>
       </div>
     )
     function handleClick () {
       doUpdateQuery({})
     }
   }
   export default connect(
     "doUpdateQuery",
     FilterTag
   )

 #+END_SRC
*** FilterForm
    :PROPERTIES:
    :header-args: :tangle ./src/components/filter-form.js
    :END:
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   function FilterForm (props) {
     const {
       doUpdateQuery
     } = props

     return(
         <form onSubmit={handleSubmit} className='h2'>
         <label>Filter By:</label>
         <input type="text" name="search" />
         <button type="submit">Search</button>
         </form>
     )

     function handleSubmit (e) {
       e.preventDefault()
       const filterQuery = e.target[0].value
       e.target[0].value = ""
       doUpdateQuery({filter: filterQuery})
     }
   }
   export default connect(
     "doUpdateQuery",
     FilterForm
   )

 #+END_SRC
*** Releases Container
    :PROPERTIES:
    :header-args: :tangle ./src/components/releases-container.js
    :END:

    We originally had the releases split by 'Master', 'Sig Release', and 'Conformance Release'.  This was based off the file names.  These file names are not accurate for what the releases really are, and will be constricting in the future.  We are now settiung it to just be 'Master' and 'Releases'.

The 'Releases' section are still all titled with a sig prefix, so our sigReleases selector still holds.  We will need to revisit this later though when we update our files.

 #+NAME: Releases Container
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   import ReleasesList from './releases-list'

   function ReleasesContainer (props) {
     const {
       releasesIndexMasterOnly,
       releasesIndexSorted
     } = props

     return(
       <section id="releases-container" className="">
         <div className='flex items-start justify-start'>
         <ReleasesList grouping={"Master"} releases={releasesIndexMasterOnly} />
         <ReleasesList grouping={"Releases"} releases={releasesIndexSorted} />
         </div>
       </section>
     )
   }

   export default connect(
     "selectReleasesIndexMasterOnly",
     "selectReleasesIndexSorted",
     ReleasesContainer
   )

 #+END_SRC

*** Releases List
    :PROPERTIES:
    :header-args: :tangle ./src/components/releases-list.js
    :END:
We are being passed a big chunk of data for releases, drawing from the metadata and finished JSON's generated in the apisnoop.sh script.

#+EXAMPLE: Sample Releases info
#+BEGIN_EXAMPLE
  name	"ci-kubernetes-e2e-gce-cos-k8sstable2-default_1814"
  job-version	"v1.11.8-beta.0.8+7ee1441c1ed1de"
  master_os_image	"cos-stable-65-10323-64-0"
  node_os_image	"cos-stable-65-10323-64-0"
  revision	"v1.11.8-beta.0.8+7ee1441c1ed1de"
  timestamp	1549341765
  version	"v1.11.8-beta.0.8+7ee1441c1ed1de"
  result	"SUCCESS"
  passed	true
  metadata
  node_os_image	"cos-stable-65-10323-64-0"
  infra-commit	"6fe6319c1"
  master_os_image	"cos-stable-65-10323-64-0"
  job-version	"v1.11.8-beta.0.8+7ee1441c1ed1de"
  pod	"8edf9e3d-28fa-11e9-9ab9-0a580a6c025d"
  revision	"v1.11.8-beta.0.8+7ee1441c1ed1de"
  bucket	"ci-kubernetes-e2e-gce-cos-k8sstable2-default"
  job	"1814"
  release	"ci-kubernetes-e2e-gce-cos-k8sstable2-default_1814"
  release_short	"v1.11.8-beta.0.8"
  gathered_datetime	"2019-02-05, 04:42:45"
  _id	"SW3EHQPZpeVw3WUv"
#+END_EXAMPLE


#+NAME: releases-list
#+BEGIN_SRC js
  import React from 'react'
  import { connect } from 'redux-bundler-react'


  var ReleasesList = (props) => {
    const {
      releases,
      queryObject,
      grouping,
      releasesIndexShouldUpdate,
      urlObject
    } = props

    if (grouping == null) return null

    if (releasesIndexShouldUpdate) return null

    return (
        <div className="mr4">
        <h3 className="f3 mt0 ttsc tracked"> { grouping }</h3>
        <ul className='pl0 ml0'>
        {releases.map(releaseItem => {
          return <ReleaseItem release={ releaseItem } key={releaseItem._id} queryObject={queryObject}/>
        })}
      </ul>
      </div>
    )

    function ReleaseItem (props) {
      const { release } = props
      var releaseUrl = getReleaseUrl(release.url)
      var classes="f6 link dim br1 ba ph3 pv2 mb2 mr2 dib mid-gray"
      if (releaseUrl === urlObject.pathname) {
        classes = classes + " bg-washed-red"
      }
      return (
          <li className='dib'>
          <a
            className={ classes }
            href={getReleaseUrl(release.release, queryObject)}
            title={release.version}
          >
          {release.version}
        </a>
          </li>
      )
    }
  }

  function getReleaseUrl (release, queryObject) {
    if (queryObject == null || queryObject.filter === undefined) {
      return `/${release}`
    }
    return `/${release}?filter=${queryObject.filter}`
  }

  export default connect(
    'selectQueryObject',
    'selectUrlObject',
    'selectReleasesIndexShouldUpdate',
    ReleasesList
  )
#+END_SRC
*** Sunburst And Summary
    :PROPERTIES:
    :header-args: :tangle ./src/components/sunburst-and-summary.js
    :END:
    #+NAME: sunburst-and-summary
    #+BEGIN_SRC js :tangle ./src/components/sunburst-and-summary.js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      import SunburstContainer from './sunburst-container'
      import SummaryContainer from './summary-container'

      const SunburstAndSummary = (props) => {
        return (
            <section
              id='summary-and-sunburst'
              className='flex mb4 mt4'
            >
            <SunburstContainer />
            <SummaryContainer />
          </section>
        )
      }

      export default connect(
        SunburstAndSummary
      )

    #+END_SRC
*** Sunburst Container
    #+NAME: sunburst-container
    #+BEGIN_SRC js :tangle ./src/components/sunburst-container.js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      import Sunburst from './sunburst'
      import SunburstHeader from './sunburst-header'

      const SunburstContainer = (props) => {
        return (
            <div id='sunburst-container' className='flex flex-column mr4'>
            <SunburstHeader />
            <Sunburst />
            </div>
        )
      }

      export default connect(
        SunburstContainer
      )

    #+END_SRC
*** Sunburst Header
    :PROPERTIES:
    :header-args: :tangle ./src/components/sunburst-header.js
    :END:
    #+NAME: sunburst-header
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      const SunburstHeader = (props) => {
        const {
          currentReleaseObject,
          currentReleaseIsLoading,
          currentReleaseShouldUpdate,
          currentReleaseAPISnoopLink,
          currentReleaseSpyglassLink
        } = props
        var release = currentReleaseObject

        if (release == null) return null

        return (
            <div id='sunburst-header' className='relative'>
            {(currentReleaseShouldUpdate || currentReleaseIsLoading) &&
              <p className='i fw2 absolute top-0'>Switching To...</p>}
            <h2 className='mb1 mt1 pt4 f1'>
            {release.release_short }
            </h2>
            <p className='ibm-plex-mono f6 mt0 pt0 pl2'> from job {release.job} in&nbsp;
              <a
                href={currentReleaseSpyglassLink}
                title='job information on spyglass'
                target='_blank'
                rel='noopener noreferrer'
              >{release.bucket}</a>
          </p>
            <a className='ibm-plex-mono f6 mt0 mb1  pt0 pl2'
              href={currentReleaseAPISnoopLink}
              title='Processed Data in Apisnoop gcs bucket'
              target='_blank'
              rel='noopener noreferrer'
            >See processed audit of {release.bucket}</a>
            <p className='ibm-plex-mono f6 mb1 pt0 pl2'>Data Gathered on {release.gathered_datetime}</p>
            </div>
        )
      }

      export default connect(
        'selectCurrentReleaseObject',
        'selectCurrentReleaseIsLoading',
        'selectCurrentReleaseShouldUpdate',
        'selectCurrentReleaseAPISnoopLink',
        'selectCurrentReleaseSpyglassLink',
        SunburstHeader
      )

    #+END_SRC
*** Sunburst
    :PROPERTIES:
    :header-args: :tangle ./src/components/sunburst.js
    :END:
    #+NAME: Sunburst
    #+BEGIN_SRC js
      import React from 'react'
      import { Sunburst, LabelSeries } from 'react-vis'
      import { connect } from 'redux-bundler-react'
      import {
        get,
        join,
        sortBy } from 'lodash'

      import { propertiesWithValue } from '../lib/utils'

      const SunburstChart = (props) => {
        const {
          interiorLabel,
          labelStyle,
          sunburstSorted,
          queryObject,
          doUpdateQuery
        } = props

        return (
            <div id='sunburst'>
            <Sunburst
          hideRootNode
          colorType="literal"
          data={sunburstSorted}
          height={600}
          width={600}
          getColor={node => node.color}
          onValueClick={handleMouseClick}
          onValueMouseOver={handleMouseOver}
          onValueMouseOut={handleMouseOut}
            >
          {(interiorLabel && interiorLabel.endpoint) &&
           <LabelSeries
           data={[
             {x: 0, y: 0, label: interiorLabel.tested, style: labelStyle.PERCENTAGE},
           ]} />}
           {(interiorLabel && interiorLabel.coverage) &&
             <LabelSeries
             data={[{x: 0, y: 60, label: interiorLabel.coverage.percentage, style: labelStyle.PERCENTAGE},
                    {x: 0, y: 0, label: interiorLabel.coverage.ratio, style: labelStyle.FRACTION},
                    {x: 0, y: -20, label: 'total tested', style: labelStyle.PATH}
                   ]} />}
            </Sunburst>
            <button className='ttsc' onClick={handleReset}>Reset</button>
            </div>
        )
        function handleMouseOver (node, event) {
          var path = getKeyPath(node)
          var rawQuery = {
            level: path[1],
            category: path[2],
            name: path[3]
          }
          var query = propertiesWithValue(rawQuery)
          if (queryObject.zoomed) {
            query.zoomed = queryObject.zoomed
          }
          if (queryObject.filter) {
            query.filter = queryObject.filter
          }
          if (queryObject.useragents) {
            query.useragents = queryObject.useragents
          }
          doUpdateQuery(query)
        }

        function handleMouseOut () {
          var query = {}
          if (queryObject.filter) {
            query.filter = queryObject.filter
          }
          if (queryObject.zoomed) {
            query.zoomed = queryObject.zoomed
          }
          if (queryObject.useragents) {
            query.useragents = queryObject.useragents
          }
          doUpdateQuery(query)
        }

        function handleMouseClick (node, event) {
          var depth = ['root', 'level', 'category', 'endpoint']
          var path = getKeyPath(node)
          var rawQuery = {
            level: path[1],
            category: path[2],
            name: path[3],
            filter: queryObject.filter
          }
          var query = propertiesWithValue(rawQuery)
          var queryAsArray = sortBy(query, ['level','category','name'])
          query.zoomed = `${depth[node.depth]}-${join(queryAsArray,'-')}`
          if (queryObject.filter) {
            query.filter = queryObject.filter
          }
          if (queryObject.useragents) {
            query.useragents = queryObject.useragents
          }

          doUpdateQuery(query)
        }

        function handleReset () {
          var query = {}
          if (queryObject.filter) {
            query.filter = queryObject.filter
          }
          if (queryObject.useragents) {
            query.useragents =queryObject.useragents
          }
          doUpdateQuery(query)
        }

        function getKeyPath (node) {
          if (!node.parent) {
            return ['root'];
          }
          var nodeKey = get(node, 'data.name') || get(node, 'name')
          var parentKeyPath = getKeyPath(node.parent)
          return [...parentKeyPath, nodeKey]
        }
      }

      export default connect(
        'selectInteriorLabel',
        'selectLabelStyle',
        'selectQueryObject',
        'selectSunburstSorted',
        'doUpdateQuery',
        SunburstChart
      )
    #+END_SRC

    For our mouse over we'll use the url bundle, which gives us 'doUpdateQuery'.  We can give it an object and it'l add each part to the query string.  So we'll just iterate over the keypath and assign as needed.

The keypath will have at minimum 2 and at most 4 nodes [root, level, category, method].  So we need to take that array and for each index, if there's something there, add it to an object.  Then we pass that object as our query, which updates the url.  This lets us do a thing where we determine the color of a node based on whether it's path is in the query string. our updateQuery makes an object for us, so we then just check whether the aspects of the node's path matches values in the queryObject, and then color it appropriately.

I'm changing it up now to now have a click to lock.  I would rather have it be super easy to navigate through and share, and then you only click to reset.  This feels closer to what people would want.

I do this by also just updating the url.  We are trying to maintain a dumb component, who handles no real logic, it just updates the url which drives the new logic which is then represented fresh in the component.

The interior label was a bit tricky to do, and it has some logic put in that i don't fully like.  It's not fully dumb.  This is a thing to revisit later though.

*** Summary Container
    :PROPERTIES:
    :header-args: :tangle ./src/components/summary-container.js
    :END:

    This will hold the right-hand side of ourr sunburst and summary page, detailing the current path we are on and any relevant information about it.

    #+NAME: Summary Container
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      import TestsSummary from './tests-summary'

      const SummaryContainer = (props) => {
        const {
          currentReleaseShouldUpdate,
          activeEndpoint,
          categoryColours,
          levelColours,
          queryObject
        } = props

        const level = queryObject.level || ''
        const category = queryObject.category || ''
        const name = queryObject.name || ''
        const description = (activeEndpoint == null) ? '' : activeEndpoint.description

        if (currentReleaseShouldUpdate == null || currentReleaseShouldUpdate === true) return null
        return(
            <div id='summary-container' className=''>
            <p className='f2 mt1 pt4 mb3 fw3'>
            <span style={{color: levelColours[level]}}>{ level }</span>
            <span style={{color: categoryColours['category.' + category]}}>{ category }</span>
            </p>
            <p className='f3 mt0 mb3 ttsc'>{ name }</p>
            <p className='f4 mt0 mb3 i fw2'>{ description }</p>
            <TestsSummary />
            </div>
        )
      }
      export default connect(
        'selectActiveEndpoint',
        'selectCurrentReleaseShouldUpdate',
        'selectCategoryColours',
        'selectLevelColours',
        'selectPath',
        'selectQueryObject',
        SummaryContainer
      )


    #+END_SRC

*** Tests Summary
    :PROPERTIES:
    :header-args: :tangle ./src/components/tests-summary.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'
      import TestTagsList from './test-tags-list'

      const TestsSummary = (props) => {
        const {
          activeEndpoint,
          activeTestsNumber
        } = props

        if (activeTestsNumber == null || activeTestsNumber === 0) return null
        if (activeEndpoint == null) return null
        if (!activeEndpoint.isTested) {
          return(<p>Untested.</p>)
        } else {
          return(
              <div id='tests-summary'>
              <p>Covered by <span className="green b">{activeTestsNumber}</span> tests.</p>
              <TestTagsList />
              <button onClick={handleClick} className='but-no-style link magic-pointer blue'>Go To Tests</button>
              </div>
          )
        }
        function handleClick () {
          var tests = document.querySelector('.tests-section')
          if (tests == null) return null
          tests.scrollIntoView()
        }
      }

      export default connect(
        'selectActiveEndpoint',
        'selectActiveTestsNumber',
        TestsSummary
      )

    #+END_SRC

*** Test Tags List
    :PROPERTIES:
    :header-args: :tangle ./src/components/test-tags-list.js
    :END:
    this lists all the test tags that are under an endpoint (or more spefifically, for right now, the first method of that endpoint).
    #+NAME: test-tags-list
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      function TestTag (props) {
        const { testTag } = props
        return (
          <li className='dib tal ttsc mr2 mb2 ph2 pv1 mid-gray'>
            { testTag }
          </li>
        )
      }

      function TestTagsList (props) {
        const { testTagsIndex } = props

        if (testTagsIndex == null) return null
        if (testTagsIndex.length === 0) return null

        return (
          <div className="mt4 pl0">
            <p>Tests are coming from:</p>
            <div className="scrollbox">
            <ul className='list pl0 ml0'>
            {testTagsIndex.map(testTag => {
                return <TestTag testTag={ testTag } />
              })}
            </ul>
          </div>
          </div>
        )
      }

      export default connect(
        'selectTestTagsIndex',
        TestTagsList
      )
    #+END_SRC

*** Active Tests list
    :PROPERTIES:
    :header-args: :tangle ./src/components/active-tests-list.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'
      import { map } from 'lodash'

      function TestItem (props) {
        const {
          testItem,
          queryObject,
          doUpdateQuery } = props

        return (
            <li className='mb3 dim'key='test_{ testItem._id }'>
            <button className='but-no-style link mid-gray magic-pointer' onClick={()=> handleClick(queryObject, testItem._id)} title={'info for ' + testItem.name}>{ testItem.name }</button>
            </li>
        )

        function handleClick (query, id) {
          doUpdateQuery({
            ...query,
            test: id
          })
        }
      }

      function TestList (props) {
        const {
          activeTest,
          activeTestsIndex,
          queryObject,
          path,
          doUpdateQuery,
        } = props

        if (activeTestsIndex == null) return null
        if (activeTest !== undefined) return null
        return (
            <div id='tests-list' className='tests-section min-vh-100 mt4'>
            <h2 className='f1'>Tests for <span className='fw2'>{path.level} / {path.category} / {path.name} </span></h2>
            <ul className='list pl0'>
            {map(activeTestsIndex, (testItem) => {
              return <TestItem testItem={ testItem } doUpdateQuery={ doUpdateQuery } queryObject={ queryObject } />
            })}
          </ul>
            </div>
        )
      }



      export default connect(
        'selectActiveTest',
        'selectActiveTestsIndex',
        'selectPath',
        'selectQueryObject',
        'doUpdateQuery',
        TestList
      )
    #+END_SRC

    Since we loading just the info for a particular release, it's far less overhead, so we can do things like add _all_ the tests to our reducer, and then just select the ones that matter to us...but their entire object.   Since this is just a basic filter, it still ends up fast.  Neat!

    When you click on a test it should add it to our query.   Then, the query learns to look for whether there is a Test showing and if so, to display the active test detail.
*** Active Test Sequence List
    :PROPERTIES:
    :header-args: :tangle ./src/components/active-test-sequence.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'
      import { map, omit } from 'lodash'
      import dayjs from 'dayjs'

      function ActiveTestSequence (props) {
        const {
          activeTest,
          categoryColours,
          levelColours,
          queryObject,
          doUpdateQuery
        } = props

        if (activeTest== null) return null

        return (
            <div id='test-sequence' className="mt4 tests-section">
            <h2>Sequence For <span className='fw2'>{ activeTest.name }</span></h2>
            <button onClick={handleClick}>Back</button>
            <ul className='list'>
            {map(activeTest.sequence, (step) => {
              return <SequenceStep rawStep={ step } levelColours={levelColours} categoryColours={categoryColours}  />
            })}
          </ul>
            </div>
        )

        function handleClick () {
          var queryWithoutTest = omit(queryObject, 'test')
          doUpdateQuery(queryWithoutTest)
        }
      }

      function SequenceStep (props) {
        const {
          categoryColours,
          levelColours,
          rawStep
        } = props

        var step = {
          timestamp: dayjs(rawStep[0]).format('mm:ss'),
          level: rawStep[1],
          category: rawStep[2],
          method: rawStep[3],
          endpoint: rawStep[4]
        }

        return (
            <li className='' key='test_{ testItem._id }'>
            <span className='fw2 i mid-gray mr2'>{ step.timestamp}</span>
            <span className='mr1 ml1 fw2' style={{color: levelColours[step.level]}}>{step.level}</span>
            <span className='mr1 ml1 fw2' style={{color: categoryColours['category.' + step.category] }}>{step.category}</span>
            <span className='mr1 ml1 fw3 ttsc'> {step.endpoint}</span>
            </li>
        )
      }

      export default connect(
        'selectActiveTest',
        'selectCategoryColours',
        'selectLevelColours',
        'selectQueryObject',
        'doUpdateQuery',
        ActiveTestSequence
      )
    #+END_SRC

    Since we loading just the info for a particular release, it's far less overhead, so we can do things like add _all_ the tests to our reducer, and then just select the ones that matter to us...but their entire object.   Since this is just a basic filter, it still ends up fast.  Neat!

    When you click on a test it should add it to our query.   Then, the query learns to look for whether there is a Test showing and if so, to display the active test detail.
*** Useragent Search Container
    :PROPERTIES:
    :header-args: :tangle ./src/components/useragent-search-container.js
    :END:

     A container, that sits below our releases and has a search bar displayed.  When you type into it, it shows the result of yoru regex filter below, by displaying the useragents that fit that filter

    #+NAME: Useragent Search Container
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'
      import UseragentSearchBar from './useragent-search-bar'
      import UseragentSearchResults from './useragent-search-results'
      import UseragentsActiveFilter from './useragents-active-filter'

      function UseragentSearchContainer (props) {
        return (
          <div id='useragent-search'>
            <UseragentSearchBar />
            <UseragentSearchResults />
            <UseragentsActiveFilter />
          </div>
        )
      }
      export default connect(
        UseragentSearchContainer
      )
    #+END_SRC
*** Useragent Search Bar
    :PROPERTIES:
    :header-args: :tangle ./src/components/useragent-search-bar.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import {connect} from 'redux-bundler-react'

      function UseragentSearchBar (props) {
        const {
          doUpdateUseragentsInput,
          doUpdateQuery,
          useragentsInput
         } = props

        return (
            <form onSubmit={handleSubmit}>
            <input name='ua-filter' type='text' value={useragentsInput} onChange={handleInput}/>
            <input type='submit' value='submit' />
            </form>
            )

        function handleInput (e) {
          doUpdateUseragentsInput(e.target.value)
        }
        function handleSubmit (e) {
          e.preventDefault()
          doUpdateQuery({
            useragents: e.target[0].value
          })
          doUpdateUseragentsInput('')
        }
      }

      export default connect(
        'doUpdateUseragentsInput',
        'doUpdateQuery',
        'selectUseragentsInput',
        UseragentSearchBar
      )



    #+END_SRC
*** Useragent Search Results
    :PROPERTIES:
    :header-args: :tangle ./src/components/useragent-search-results.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import {connect} from 'redux-bundler-react'

      function UseragentSearchResults (props) {
        const useragents = props.useragentsFilteredByInput
        if(useragents == null || useragents.length <= 0) return null
        return (
          <div id='useragent-search-results' className='mt2 mb0'>
            <strong className='f5'>Useragents covered by this regex</strong>
            <ul className="list ph0">
              {useragents.map(useragent => <li key={useragent} className="f6 dib mr2 pa2 mid-gray">{ useragent }</li>)}
            </ul>
          </div>
        )
      }

      export default connect(
        'selectUseragentsFilteredByInput',
        UseragentSearchResults
      )
    #+END_SRC
*** Useragents Filter Selection
    :PROPERTIES:
    :header-args: :tangle ./src/components/useragents-active-filter.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import {connect} from 'redux-bundler-react'

      function UseragentsActiveFilter (props) {
        const useragents = props.useragentsFilteredByQuery
        if(useragents == null || useragents.length <= 0) return null
        return (
            <div className='ma3'>
            <strong>Currently Filtered To:</strong>
            <ul>
              {useragents.map(useragent => <li key={useragent.name + "_ua-filter"}>{ useragent.name }</li>)}
            </ul>
            </div>
        )
      }

      export default connect(
        'selectUseragentsFilteredByQuery',
        UseragentsActiveFilter
      )
    #+END_SRC
*** End


** Pages
*** Main Page
   :PROPERTIES:
   :header-args: :tangle ./src/pages/main-page.js
   :END:
   #+NAME: Main Page
   #+BEGIN_SRC js
     import React from 'react'
     import { connect } from 'redux-bundler-react'

     // import FilterContainer from '../components/filter-container' # a regex filter for endpoints.
     import ReleasesContainer from '../components/releases-container'
     import UseragentSearchContainer from '../components/useragent-search-container'
     import SunburstAndSummary from '../components/sunburst-and-summary'
     import ActiveTestsList from '../components/active-tests-list'
     import ActiveTestSequence from '../components/active-test-sequence'

     function MainPage () {
         return (
           <main id='main-splash' className='min-vh-80 pa4 ma4 flex flex-column'>
           {/*<FilterContainer />*/}
           <ReleasesContainer />
           <UseragentSearchContainer />
           <SunburstAndSummary />
           <ActiveTestsList />
           <ActiveTestSequence />
           </main>
         )
     }

     export default connect(
         MainPage
     )
   #+END_SRC

** Utils
   recurring helper functions
  #+NAME: Utils
  #+BEGIN_SRC js :tangle ./src/lib/utils.js
        import {
          filter,
          isUndefined,
          size,
          words,
          pickBy } from 'lodash'

        export function calculateCoverage (endpoints) {
          var total = size(endpoints)
          var tested = size(filter(endpoints, ['isTested', true]))
          var percentage = (total, tested) => {
            if (!tested && !total) return 'No Endpoints'
            var percentageNumber = (100 * tested /total).toPrecision(3)
            return `${percentageNumber}%`
            }

          return {
            tested,
            total,
            percentage: percentage(total, tested),
            ratio: `${tested}/${total}`
          }
        }

        export function fadeColor (rgba, desiredOpacity) {
          var rgbaParts = words(rgba, /[^,|^(|^)]+/g)
          rgbaParts.pop()
          rgbaParts.push(desiredOpacity)
          var newRgbaString = rgbaParts.join(',')
          var newRgba = newRgbaString.replace(/,/,'(') + ')'
          return newRgba
        }

        export function propertiesWithValue (obj) {
          return pickBy(obj, (val) => !isUndefined(val))
        }
  #+END_SRC
* Glossary
** Bundle (<<<bundles>>> | <<<bundle>>>)
   a collection of redux code all organized by some concern or idea.  It's a marked difference from the typical organizing style, where you organize files by what they are (reducers, selectors, etc.).  This, instead, organizes files by their topic.
** Component (<<<Component>>> | <<<Components>>>)
Self-contained, presentational parts of our front-end site.  It is what people actually see and interact with on our site.  What is unique is how specific and reusable components are.  Every singular bit of the api should essentially be a component.  We do this because it is easier to build upon, to collaborate with others, to maintain, and to share components across other projects.
** Pages (<<<page>>> | <<<pages>>>)
    A collection of components.  Can be thought as the overall layout for a particular subject within our app.  Basically a 'webpage', but that has built-in headers/footers/navigation and so on.
** Dynamic Web App (<<<dynamic web app>>>)
A site whose content and presentation is determined by code that is run when the site is first loaded.  As opposed to a static web site, where the content is already generated and delivered to you from the server when you log on.  The upside is that it allows for a robust site that is tailored to individual visitors, who can navigate around the area quickly and easily.  The downside is that they can be resource heavy, and do not work on browsers that have disabled javascript.
** Client-Side (<<<client-side>>>)
Refers to  code that is run on the client (as opposed to on the server).  The client is most often the web browser.  So a client-side app, if done well, allows for a quick data fetch from the server and then a snappy full-powered web app since all the functionality is being handled by the browser itself
** Static Web Site (<<<static web site>>>)
A site whose content is pre-set, and not made based on the actions of the site visitor or their browser.  Original html sites are static (coolguy.website being an example).  Apisnoop is dynamic.  You can see the differenve by viewikng the source code of their index.html files.  coolguy has all the code written directly in the file.  apisnoop has nothing except a javascript file waiting to be run.
** Immutable State( <<<immutable state>>> )
In our context, state refers to the state of the app.  Immutable means that it cannot be changed. So this means, whenever there is any action that should change the state we replace the entire state.  For example: the current state might hold values like the current URL, and that we are currently fetching data and it's pending.  When the data fetch is accomplished, we want to update the state.  We do this not by looking for our 'DATA' value and adjusting it.  Instead, we replace the state entirely, with our new state being the same url but now 'data fetch fulfilled'.

Doing it in this way means we can have a snapshot of the state for every update to it.  If we wanna see what the app looked like before the data was fetched, we can simply go back to the state when it was still pending.  This makes the site easier to debug and easier to maintain.

It is a core principle or [[#arch-redux][redux]], and brought up often when discussing redux apps and functional programming.
** Selectors (<<<selector>>> | <<<selectors>>>)
a concept within [[#arch-redux][redux]].  A selector will 'select' data in our redux store, potentially make changes to it, and then give it to our components.  It is a [[arch-redux-bundle][redux bundle]] best practice to never have the componets draw from the redux store directly, and instead always get it from selectors.  This sets up a pattern where the store remains 'dumb', which makes it easier to debug.

 For example, let's say in our app we fetch release names from a server and they come to us like this:
- release_1.12.3
- release_2.4
- release_1.3.1

We want to take these names and display them on the frontpage of the site, but we want them to be sorted, and cleaned up to not have underscores and have relase be capitalized.  We _could_ adjust them as they get added to our store, by doing some quick sort and replace functions in our reducer.  But this will make it harder to reason about later, or compare it to the equivalent files in our server.  Instead, we just want to have raw data in our redux store, have a selector select it, and have the selector do the sorting and cleanup.  This way, if there's an issue with the basic data we check redux.  If there's an issue with sorting or capitalization, we check the selector.  We don't ahve to check some helper function nested inside a reducer store or some other hard to debug thang.
** Reducers ( <<<Reducer>>> | <<<Reducers>>>)
An immutable object containing the current state of the app.  Driving principle of [[#arch-redux][redux]].  Called a reducer because it takes a number of objects given to it and reduces it down to a single thing.  By object, we mean it in the literal javascript sense...and so the entire state of a complex app can be represented as:

#+BEGIN_EXAMPLE
{ name: 'something',
  users: ['list', 'of', 'users'],
  current_path: '/@timothee/profile'
}
#+END_EXAMPLE

In other words, we take a lot of complexity and reduce it down to a text object that can be easily updated or replaced. This brings us closer to designing an app as a spreadhseet, where the frontend is just displaying the data in pleasing way, and the backend has a consistent and logical way to add and amend the data.
** Actions ( <<<action>>> | <<<actions>>>)
  In our context, an object that announces a change in state, along with a payload of data for that change.  Actions are represented as so:

#+NAME: example action
#+BEGIN_EXAMPLE
{
  type: 'NEW_USER_ADDED',
  payload: userData
}
#+END_EXAMPLE

So actions always have a type and a payload.  The type is written like a news headline, and the payload can be anything (a string, an object, an array, an integer, etc).  For more info, check out our conventions section.
** <<<action creator>>>
A function that creates an action.  They are written as 'doThisAction', so in the example above, we might have a function called 'doAddNewUser', and running the function results in the action object above.
** <<<reactor>>> | <<<Reactors>>>
 A special type of selector, that is set up to listen to conditions that should prompt an action.  An example might be if you wanted your app to attempt another data fetch if the first one failed.  You'd have a reactor that was waiting for a 'DATA_FETCH_FAILED' action, and when that came it would trigger a 'DATA_FETCH_STARTED' action in response.  Reactors bring us closer to a clearly separated app, where the reducer just holds data, the components just display the data given, and selectors and reactors handle the rest.
** Store (-<<<store>>>)
Kinda used interchangable with state, and short for redux store.  It refers to the big object containing the entire state of the app.
** State (<<<State>>>)
  All the data, properties, truths, and so on of the app at this moment in time.  Similar to your emotional, personal, physical state.
* Data Definitions
** LevelCololurs (<<<◊LevelColours>>>)
   LevelColours is an Object.
   It is the base colours attached to the four levels of our sunburst: Alpha, Beta, Stable, and Unused.
   #+NAME: LevelColours Example
   #+BEGIN_EXAMPLE js
     {
       alpha: 'rgba(230, 25, 75, 1)',
       beta: 'rgba(0, 130, 200, 1)',
       stable: 'rgba(60, 180, 75, 1)',
       unused: 'rgba(255, 255, 255, 1)'
     }
   #+END_EXAMPLE
** ColourState (<<<◊ColourState>>>)

   Colourstate is an Object, consisting of colours, moreColours, and categories.
   It is used to set the colours of the various levels, categories, and endpoints throughout the site.

     #+NAME: ColourState Example
     #+BEGIN_Example
       const initialState = {
         colours: {
           'alpha': 'rgba(230, 25, 75, 1)',
           'beta': 'rgba(0, 130, 200, 1)',
           'stable': 'rgba(60, 180, 75, 1)',
           'unused': 'rgba(255, 255, 255, 1)'
         },
         moreColours: [
           'rgba(183, 28, 28, 1)',
           'rgba(136, 14, 79, 1)',
           'rgba(74, 20, 140, 1)',
           'rgba(49, 27, 146, 1)',
           'rgba(26, 35, 126, 1)',
           'rgba(13, 71, 161, 1)',
           'rgba(1, 87, 155, 1)',
           'rgba(0, 96, 100, 1)',
           'rgba(0, 77, 64, 1)',
           'rgba(27, 94, 32, 1)',
           'rgba(51, 105, 30, 1)',
           'rgba(130, 119, 23, 1)',
           'rgba(245, 127, 23, 1)',
           'rgba(255, 111, 0, 1)',
           'rgba(230, 81, 0, 1)',
           'rgba(191, 54, 12, 1)',
           'rgba(244, 67, 54, 1)',
           'rgba(233, 30, 99, 1)',
           'rgba(156, 39, 176, 1)',
           'rgba(103, 58, 183, 1)',
           'rgba(63, 81, 181, 1)',
           'rgba(33, 150, 243, 1)',
           'rgba(3, 169, 244, 1)',
           'rgba(0, 188, 212, 1)',
           'rgba(0, 150, 136, 1)',
           'rgba(76, 175, 80, 1)',
           'rgba(139, 195, 74, 1)',
           'rgba(205, 220, 57, 1)',
           'rgba(255, 235, 59, 1)',
           'rgba(255, 193, 7, 1)',
           'rgba(255, 152, 0, 1)',
           'rgba(255, 87, 34, 1)'

         ],
         categories: [
           "admissionregistration",
           "apiextensions",
           "apiregistration",
           "apis",
           "apps",
           "authentication",
           "authorization",
           "autoscaling",
           "batch",
           "certificates",
           "core",
           "events",
           "extensions",
           "logs",
           "networking",
           "policy",
           "rbacAuthorization",
           "scheduling",
           "settings",
           "storage",
           "version",
           "auditregistration",
           "coordination"
         ]
       }
     #+END_EXAMPLE
** CategoryColours (<<<◊CategoryColours>>>)
   CategoryColours is an object, holding all categories mapped to moreColours from our ColourState

   #+NAME: CategoryColours Example
   #+BEGIN_SRC js
     {
       'category.admissionregistration': 'rgba(183, 28, 28, 1)',
       'category.apiextensions': 'rgba(49, 27, 146, 1)',
       'category.apiregistration': 'rgba(1, 87, 155, 1)',
       'category.apis': 'rgba(27, 94, 32, 1)',
       'category.apps': 'rgba(245, 127, 23, 1)',
       'category.authentication': 'rgba(191, 54, 12, 1)',
       'category.authorization': 'rgba(156, 39, 176, 1)',
       'category.autoscaling': 'rgba(33, 150, 243, 1)',
       'category.batch': 'rgba(0, 150, 136, 1)',
       'category.certificates': 'rgba(205, 220, 57, 1)',
       'category.core': 'rgba(255, 152, 0, 1)',
       'category.events': 'rgba(136, 14, 79, 1)',
       'category.extensions': 'rgba(26, 35, 126, 1)',
       'category.logs': 'rgba(0, 96, 100, 1)',
       'category.networking': 'rgba(51, 105, 30, 1)',
       'category.policy': 'rgba(255, 111, 0, 1)',
       'category.rbacAuthorization': 'rgba(244, 67, 54, 1)',
       'category.scheduling': 'rgba(103, 58, 183, 1)',
       'category.settings': 'rgba(3, 169, 244, 1)',
       'category.storage': 'rgba(76, 175, 80, 1)',
       'category.version': 'rgba(255, 235, 59, 1)',
       'category.auditregistration': 'rgba(255, 87, 34, 1)',
       'category.coordination': 'rgba(74, 20, 140, 1)'
     }
   #+END_SRC
** EndpointsFilter (<<<◊EndpointsFilter>>>)
   EndpointsFilter is a Regular Expression.
   It is a segment of text that we test to see whether it is present in an Endpoints' name.
** Endpoints (<<<◊Endpoints>>>)
   Endpoints is an array, consisting of multiple ◊Endpoint objects

   #+NAME: Endpoints Definition Example
   #+BEGIN_SRC js :var name="var sample =" :tangle no
     [
          {
            "name": "readCoreV1NamespaceStatus",
            "method": "get",
            "level": "stable",
            "test_tags": [],
            "tests": [],
            "description": "read status of the specified Namespace",
            "path": "/api/v1/namespaces/{name}/status",
            "category": "core",
            "isTested": false,
            "bucket": "9058",
            "job": "apisnoop.json",
            "release": "9058_apisnoop.json",
            "_id": "6OBwAVYGdU2tOKE8"
          },
          {
            "name": "readCoreV1NamespacedPersistentVolumeClaimStatus",
            "method": "get",
            "level": "stable",
            "test_tags": [],
            "tests": [],
            "description": "read status of the specified PersistentVolumeClaim",
            "path": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
            "category": "core",
            "isTested": false,
            "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable3-default",
            "job": "460",
            "release": "ci-kubernetes-e2e-gce-cos-k8sstable3-default_460",
            "_id": "6P78EQLmPvD27Ls7"
          },
          {
            "name": "listCoreV1NamespacedEvent",
            "method": "watch",
            "level": "stable",
            "test_tags": [],
            "tests": [],
            "description": "list or watch objects of kind Event",
            "path": "/api/v1/namespaces/{namespace}/events",
            "category": "core",
            "isTested": false,
            "bucket": "34681",
            "job": "apisnoop.json",
            "release": "34681_apisnoop.json",
            "_id": "6PGRw4iDxJrA4QaS"
          },
          {
            "name": "listSettingsV1alpha1NamespacedPodPreset",
            "method": "get",
            "level": "alpha",
            "test_tags": [],
            "tests": [],
            "description": "list or watch objects of kind PodPreset",
            "path": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets",
            "category": "settings",
            "isTested": true,
            "bucket": "1814",
            "job": "apisnoop.json",
            "release": "1814_apisnoop.json",
            "_id": "6PxTDVRO9ZhOsmXz"
          }
        ]
   #+END_SRC

** Endpoint (<<<◊Endpoint>>>)
   An endpoint is an object, representing a single entry from the =/endpoints= path of our API
   #+NAME: Endpoint Definition Example
   #+BEGIN_EXAMPLE
     {
       "name": "readCoreV1NamespacedPersistentVolumeClaimStatus",
       "method": "get",
       "level": "stable",
       "test_tags": [],
       "tests": [],
       "description": "read status of the specified PersistentVolumeClaim",
       "path": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
       "category": "core",
       "isTested": false,
       "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable3-default",
       "job": "460",
       "release": "ci-kubernetes-e2e-gce-cos-k8sstable3-default_460",
       "_id": "6P78EQLmPvD27Ls7"
     }
   #+END_EXAMPLE
** EndpointsObject (<<<◊EndpointsObject>>>)
   EndpointsObject is an object whose keys are ◊Endpoint id's, and whose value is the ◊Endpoint that matdches that id
   #+NAME: EndpointsObject Definition Example
   #+BEGIN_EXAMPLE js
     var example = {
         "6OBwAVYGdU2tOKE8": {
           "name": "readCoreV1NamespaceStatus",
           "method": "get",
           "level": "stable",
           "test_tags": [],
           "tests": [],
           "description": "read status of the specified Namespace",
           "path": "/api/v1/namespaces/{name}/status",
           "category": "core",
           "isTested": false,
           "bucket": "9058",
           "job": "apisnoop.json",
           "release": "9058_apisnoop.json",
           "_id": "6OBwAVYGdU2tOKE8"
         },
         "6P78EQLmPvD27Ls7": {
           "name": "readCoreV1NamespacedPersistentVolumeClaimStatus",
           "method": "get",
           "level": "stable",
           "test_tags": [],
           "tests": [],
           "description": "read status of the specified PersistentVolumeClaim",
           "path": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
           "category": "core",
           "isTested": false,
           "bucket": "ci-kubernetes-e2e-gce-cos-k8sstable3-default",
           "job": "460",
           "release": "ci-kubernetes-e2e-gce-cos-k8sstable3-default_460",
           "_id": "6P78EQLmPvD27Ls7"
         },
         "6PGRw4iDxJrA4QaS": {
           "name": "listCoreV1NamespacedEvent",
           "method": "watch",
           "level": "stable",
           "test_tags": [],
           "tests": [],
           "description": "list or watch objects of kind Event",
           "path": "/api/v1/namespaces/{namespace}/events",
           "category": "core",
           "isTested": false,
           "bucket": "34681",
           "job": "apisnoop.json",
           "release": "34681_apisnoop.json",
           "_id": "6PGRw4iDxJrA4QaS"
         },
         "6PxTDVRO9ZhOsmXz": {
           "name": "listSettingsV1alpha1NamespacedPodPreset",
           "method": "get",
           "level": "alpha",
           "test_tags": [],
           "tests": [],
           "description": "list or watch objects of kind PodPreset",
           "path": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets",
           "category": "settings",
           "isTested": true,
           "bucket": "1814",
           "job": "apisnoop.json",
           "release": "1814_apisnoop.json",
           "_id": "6PxTDVRO9ZhOsmXz"
       }
     }
   #+END_EXAMPLE
** Query(<<<◊Query>>>)
   Query is an object representing the url query parameters of apisnoop.
   It is used to filter which endpoints are seen in the sunburst and what tests are retrieved
   #+NAME: Query Definition Example
   #+BEGIN_SRC js :tangle no
     {
       test: "04xuKGPMwdRSUPGk",
       useragent: "k*",
       zoomed: "endpoint-stable-core-listCoreV1NamespacedLimitRange"
    }
   #+END_SRC
** Useragents (<<<◊Useragents>>>)
   Useragents is an array of multiple ◊Useragent objects.
   For an example, check out [[file:src/test_resources/useragents.json][src/test_resources/useragents.json]]
** Useragent (<<<◊Useragent>>>)
   Useragents is an object representing a single entry from our =/useragents= api path.

   #+NAME: Useragent Definition Example
   #+BEGIN_SRC js :tangle no
     {
         "name": "kube-apiserver/v1.15.0",
         "endpoints": {
             "listCoreV1LimitRangeForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "createApiregistrationV1APIService": {
                 "post": {
                     "counter": 51
                 }
             },
             "listApiextensionsV1beta1CustomResourceDefinition": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listStorageV1VolumeAttachment": {
                 "watch": {
                     "counter": 9
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listPolicyV1beta1PodSecurityPolicy": {
                 "watch": {
                     "counter": 9
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listSchedulingV1beta1PriorityClass": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "readRbacAuthorizationV1NamespacedRoleBinding": {
                 "get": {
                     "counter": 7
                 }
             },
             "createRbacAuthorizationV1ClusterRoleBinding": {
                 "post": {
                     "counter": 37
                 }
             },
             "listCoreV1Namespace": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listRbacAuthorizationV1RoleBindingForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "createCoreV1NamespacedConfigMap": {
                 "post": {
                     "counter": 1
                 }
             },
             "readCoreV1NamespacedService": {
                 "get": {
                     "counter": 174
                 }
             },
             "listPolicyV1beta1NamespacedPodDisruptionBudget": {
                 "get": {
                     "counter": 7
                 }
             },
             "replaceCoreV1NamespacedResourceQuotaStatus": {
                 "put": {
                     "counter": 16
                 }
             },
             "listAdmissionregistrationV1beta1MutatingWebhookConfiguration": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listCoreV1PodForAllNamespaces": {
                 "watch": {
                     "counter": 9
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listCoreV1NamespacedLimitRange": {
                 "get": {
                     "counter": 774
                 }
             },
             "createRbacAuthorizationV1NamespacedRole": {
                 "post": {
                     "counter": 7
                 }
             },
             "replaceApiregistrationV1APIServiceStatus": {
                 "put": {
                     "counter": 9
                 }
             },
             "listRbacAuthorizationV1ClusterRole": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 2
                 }
             },
             "createCoreV1NamespacedEndpoints": {
                 "post": {
                     "counter": 1
                 }
             },
             "listRbacAuthorizationV1ClusterRoleBinding": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 2
                 }
             },
             "listCoreV1PersistentVolume": {
                 "watch": {
                     "counter": 9
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "createRbacAuthorizationV1ClusterRole": {
                 "post": {
                     "counter": 54
                 }
             },
             "listCoreV1EndpointsForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listApiregistrationV1APIService": {
                 "watch": {
                     "counter": 9
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listStorageV1StorageClass": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "createCoreV1Namespace": {
                 "post": {
                     "counter": 4
                 }
             },
             "readRbacAuthorizationV1ClusterRole": {
                 "get": {
                     "counter": 60
                 }
             },
             "replaceApiextensionsV1beta1CustomResourceDefinitionStatus": {
                 "put": {
                     "counter": 52
                 }
             },
             "createSchedulingV1beta1PriorityClass": {
                 "post": {
                     "counter": 2
                 }
             },
             "deleteApiextensionsV1beta1CustomResourceDefinition": {
                 "delete": {
                     "counter": 11
                 }
             },
             "readCoreV1NamespacedEndpoints": {
                 "get": {
                     "counter": 174
                 }
             },
             "readCoreV1NamespacedServiceAccount": {
                 "get": {
                     "counter": 20
                 }
             },
             "listAdmissionregistrationV1beta1ValidatingWebhookConfiguration": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listCoreV1NamespacedResourceQuota": {
                 "get": {
                     "counter": 1114
                 }
             },
             "listCoreV1ResourceQuotaForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listCoreV1Node": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listCoreV1ServiceForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 23
                 }
             },
             "replacePolicyV1beta1NamespacedPodDisruptionBudgetStatus": {
                 "put": {
                     "counter": 3
                 }
             },
             "createRbacAuthorizationV1NamespacedRoleBinding": {
                 "post": {
                     "counter": 7
                 }
             },
             "listRbacAuthorizationV1RoleForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "readSchedulingV1beta1PriorityClass": {
                 "get": {
                     "counter": 2
                 }
             },
             "readCoreV1NamespacedSecret": {
                 "get": {
                     "counter": 2
                 }
             },
             "listCoreV1SecretForAllNamespaces": {
                 "watch": {
                     "counter": 9
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "deleteApiregistrationV1APIService": {
                 "delete": {
                     "counter": 12
                 }
             },
             "readRbacAuthorizationV1ClusterRoleBinding": {
                 "get": {
                     "counter": 38
                 }
             },
             "readRbacAuthorizationV1NamespacedRole": {
                 "get": {
                     "counter": 7
                 }
             },
             "listCoreV1ServiceAccountForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "listSettingsV1alpha1PodPresetForAllNamespaces": {
                 "watch": {
                     "counter": 7
                 },
                 "get": {
                     "counter": 1
                 }
             },
             "createCoreV1NamespacedService": {
                 "post": {
                     "counter": 1
                 }
             },
             "readCoreV1NamespacedConfigMap": {
                 "get": {
                     "counter": 1
                 }
             }
         },
         "bucket": "ci-kubernetes-e2e-gci-gce",
         "job": "35717",
         "release": "ci-kubernetes-e2e-gci-gce_35717",
         "_id": "0uR9zRuFjYOPIdbF"
     }
   #+END_SRC
** UseragentNames(<<<◊UseragentsNames>>>)
   UseragentNames is an array of names pulled from ◊Useragents

   #+NAME: UseragentNames Definition Example
   #+BEGIN_EXAMPLE
     [
       "kubectl/v1.13.3",
       "kube-apiserver/v1.15.0",
       "kube-proxy/v1.13.5",
       "node-problem-detector/v0.5.0-49-gfb81368",
       "nfs-provisioner/v0.0.0"
     ]
   #+END_EXAMPLE

** UseragentInput(<<<◊UseragentInput>>>)
   UseragentInput is a string representing the current value of our useragent filter form.  It is converted into regex for the purpose of filtering.
   When someone inputs the search form, the UseragentInput gets added to our QueryObject as the value for =useragent=

** Zoom(<<<◊Zoom>>>)
     Zoom is an object derived from a mouseclick on our sunburst.
     It may consist of:
     - level :: the first ring of the sunburst
     - category :: an item from the second ring of the sunburst, but whose parent ring is the set level.
     - endpoint :: an item from the third ring, whose parent ring is the set category.
     - depth :: the ring in which the mouse was clicked.

 You can determine the zoom location by seeing the depth and section clicked and tracing the parents of that selection.  And so clicking on a category will give you {category, level, depth} and clicking on level would only give you {level, depth}.

#+Name: Zoom Definition Example
#+BEGIN_EXAMPLE
  {
    level: "stable",
    category: "core",
    endpoint: "deleteCoreV1Namespace",
    depth: "endpoint"
  }
#+END_EXAMPLE

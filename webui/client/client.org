#+NAME: APISnoop WebUI Client
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+TODO: IDEA(i) TODO(t) NEXT(n) IN-PROGRESS(p) BLOCKED(b) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+XPROPERTY: header-args:shell :results silent
#+XPROPERTY: header-args:shell :exports code
#+XPROPERTY: header-args:shell :wrap "SRC text"
#+PROPERTY: header-args:js :results silent

* Understanding our Webui
  This is a web-based visual interface to the data curation and manipulation we are doing as the APISnoop project.  The purpose is to display previously unseen connections between the testing coverage of kubernetes, and the people and communities these various parts of kubernetes matter to.
* The Code
** File Structure
   #+NAME: File Structure
   #+BEGIN_SRC sh
  tree ./
   #+END_SRC
** Initiatory Code
*** index.js
    :PROPERTIES:
    :header-args: :tangle ./src/index.js
    :END:
    #+NAME: index.js
    #+BEGIN_SRC js
       import React from 'react'
       import { render } from 'react-dom'
       import './index.css'

       import { Provider } from 'redux-bundler-react'

       import App from './components/app'
       import createStore from './bundles'

       var store = createStore()

       document.title = 'APISnoop | ' // + store.getState().routing.release

       render(
           <Provider store={store}>
            <App />
            </Provider>,
          document.getElementById('root')
       )
    #+END_SRC
*** _redirects
    :PROPERTIES:
    :header-args: :tangle ./public/_redirects
    :END:
    This will live in our public folder, and makes it so that when the site is deployed on netlify, all url's given will work--as they'll point back to our index.html page which will dynamically route them.
    #+NAME: _redirects
    #+BEGIN_SRC yaml
      /*    /index.html   200
    #+END_SRC
** Bundles
*** Understanding Bundles
   Another way of thinking of these are 'concerns'.  As we add functionality, it will come in the form of a bundle.  This bundle will define:
 - the state as related to this concern (reducers),
 - How we manipulate and then give the data in the state to our components (the selectors),
 - How we listen for conditions in the state that would trigger actions to happen (the reactors),
 - The actions that change the state (Actions)
*** Index
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/index.js
    :END:
    This is the root bundler, that takes all the other individual ones and composes a single super bundle.
**** Import modules and bundles
     We import all the various bundles we make here.  The only module we need is redux-bundle's compose bundle function.
     #+NAME: bundle index: Import modules and bundles
     #+BEGIN_SRC js
       import { composeBundles } from 'redux-bundler'

       import colours from './colours'
       import config from './config'
       import currentReleaseResource from './current-release-resource'
       import endpointsResource from './endpoints-resource'
       import endpoints from './endpoints'
       import filter from './filter'
       import releases from './releases'
       import releasesIndexResource from './releases-index-resource'
       import routes from './routes'
       import sunburst from './sunburst'
       import summary from './summary'
       import testsResource from './tests-resource'
       import tests from './tests'
       import zoom from './zoom'

     #+END_SRC
**** Compose Bundle
     Then, we compose the bundles into a single store, listing all the ones we imported above.
     #+NAME: bundle index: compose bundle
     #+BEGIN_SRC js
       export default composeBundles(
         colours,
         config,
         currentReleaseResource,
         endpointsResource,
         endpoints,
         filter,
         releases,
         releasesIndexResource,
         routes,
         sunburst,
         summary,
         testsResource,
         tests,
         zoom
       )
     #+END_SRC
*** Colours
    These were locked away inside the sunburst chart, which didn't seem the best, because they were hard to reason about.  I want to make it it's own bundle, that we can then select the final calculations from and use that to set the color for each endpoint.
    #+NAME: Colors bundle
    #+BEGIN_SRC js :tangle ./src/bundles/colours.js
      export default {
        name: 'colours',
        getReducer: () => {
          const initialState = {
            colours: {
              'alpha': 'rgba(230, 25, 75, 1)',
              'beta': 'rgba(0, 130, 200, 1)',
              'stable': 'rgba(60, 180, 75, 1)',
              'unused': 'rgba(255, 255, 255, 1)'
            },
            moreColours: [
              'rgba(183, 28, 28, 1)',
              'rgba(136, 14, 79, 1)',
              'rgba(74, 20, 140, 1)',
              'rgba(49, 27, 146, 1)',
              'rgba(26, 35, 126, 1)',
              'rgba(13, 71, 161, 1)',
              'rgba(1, 87, 155, 1)',
              'rgba(0, 96, 100, 1)',
              'rgba(0, 77, 64, 1)',
              'rgba(27, 94, 32, 1)',
              'rgba(51, 105, 30, 1)',
              'rgba(130, 119, 23, 1)',
              'rgba(245, 127, 23, 1)',
              'rgba(255, 111, 0, 1)',
              'rgba(230, 81, 0, 1)',
              'rgba(191, 54, 12, 1)',
              'rgba(244, 67, 54, 1)',
              'rgba(233, 30, 99, 1)',
              'rgba(156, 39, 176, 1)',
              'rgba(103, 58, 183, 1)',
              'rgba(63, 81, 181, 1)',
              'rgba(33, 150, 243, 1)',
              'rgba(3, 169, 244, 1)',
              'rgba(0, 188, 212, 1)',
              'rgba(0, 150, 136, 1)',
              'rgba(76, 175, 80, 1)',
              'rgba(139, 195, 74, 1)',
              'rgba(205, 220, 57, 1)',
              'rgba(255, 235, 59, 1)',
              'rgba(255, 193, 7, 1)',
              'rgba(255, 152, 0, 1)',
              'rgba(255, 87, 34, 1)'

            ],
            categories: [
              "admissionregistration",
              "apiextensions",
              "apiregistration",
              "apis",
              "apps",
              "authentication",
              "authorization",
              "autoscaling",
              "batch",
              "certificates",
              "core",
              "events",
              "extensions",
              "logs",
              "networking",
              "policy",
              "rbacAuthorization",
              "scheduling",
              "settings",
              "storage",
              "version",
              "auditregistration",
              "coordination"
            ]
          }
          return (state=initialState, action) => {
            return state
          }
        },
        selectLevelColours: (state) => state.colours.colours,
        selectCategoryColours: (state) => {
          var colours = {}
          for (var catidx = 0; catidx < state.colours.categories.length; catidx++) {
            var category = state.colours.categories[catidx]
            colours['category.' + category] = state.colours.moreColours[(catidx * 3) % state.colours.moreColours.length]
          }
          return colours
        }
      }
    #+END_SRC
*** Endpoints Resource
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints-resource.js :noweb yes
    :END:
    #+NAME: endpoints-resource.js
    #+BEGIN_SRC js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'endpointsResource',
        getPromise: ({ client, store }) => {
          const currentReleaseName = store.selectCurrentReleaseName()
          return fetchEndpointsByReleaseName(client, currentReleaseName)
        }
      })

      bundle.reactEndpointsFetch = createSelector(
        'selectEndpointsResourceShouldUpdate',
        (shouldUpdate, currentReleaseId) => {
          if (!shouldUpdate) return
          return { actionCreator: 'doFetchEndpointsResource' }
        }
      )


      export default bundle

      function fetchEndpointsByReleaseName (client, releaseName) {
        return client.service('endpoints').find({
          query: {
            release: releaseName
          }
        })
      }
    #+END_SRC
*** Endpoints
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints.js :noweb yes
    :END:
**** Imports and Layout
    #+NAME: endpoints bundle layout
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import {
          groupBy,
          includes,
          keyBy,
          mapValues,
          toLower} from 'lodash'

      import { calculateCoverage } from '../lib/utils.js'

      export default {
        name: 'endpoints',
          <<Endpoints Reducers>>,
          <<Endpoints Selectors>>
      }
    #+END_SRC
**** Reducers
     #+NAME: Endpoints Reducers
     #+BEGIN_SRC js :tangle no
       getReducer: () => {
         const initialState = {
           activeEndpoint: ''
         }
         return (state=initialState, action) => {
           if (action.type === 'TESTS_REQUESTED_FOR_ENDPOINT') {
             return {
               ...state,
               activeEndpoint: action.payload
             }
           }
           return state
         }
       }
     #+END_SRC
**** Selectors
    We are making it now so that the endpoints filter on the query at the start.   The key thing is whether or not a zoom is part of the query.  If it is, we filter by whatever depth the zoom is at.
    I am not sure where the zoom object should go.  It's an aspect of our url, but we don't really have a url bundle....maaaaaybe we should?  It would only have a single  item in it though....so that might be premature optimization.  We'll include it here and maybe move it later.
     #+NAME: Endpoints Selectors
     #+BEGIN_SRC js :tangle no
       selectFilteredEndpoints: createSelector(
         'selectEndpointsResource',
         'selectFilter',
         (endpoints, filter) => {
           if (endpoints == null) return null
           if (filter) {
             endpoints = endpoints.filter(endpoint => includes(toLower(endpoint.name), toLower(filter)))
           }
           return endpoints
         }
       ),
       selectFilteredAndZoomedEndpoints: createSelector(
           'selectFilteredEndpoints',
           'selectZoom',
           (endpoints, zoom) => {
               if (endpoints == null) return null
               if (zoom) {
                 if (zoom.depth === 'endpoint') {
                   endpoints = endpoints.filter(endpoint => endpoint.level === zoom.level && endpoint.category === zoom.category)
                 } else if (zoom.depth === 'category') {
                   endpoints = endpoints.filter(endpoint => endpoint.level === zoom.level && endpoint.category === zoom.category)
                 } else if (zoom.depth === 'level') {
                   endpoints = endpoints.filter(endpoint => endpoint.level === zoom.level)
                 }
               }
               return endpoints
           }
       ),
       selectZoomedEndpoint: createSelector(
           'selectEndpointsResource',
           'selectZoom',
           (endpoints,zoom) => {
               if (endpoints == null) return null
               if (zoom == null | zoom === undefined) return null
               if (zoom.depth === 'endpoint') {
                   var zoomedEndpoint = endpoints.find(endpoint => endpoint.name === zoom.name)
                   return zoomedEndpoint
               }
           }
       ),
       selectEndpointsById: createSelector(
           'selectFilteredAndZoomedEndpoints',
           (endpoints) => {
               if (endpoints == null) return null
               return keyBy(endpoints, '_id')
           }
       ),
       selectEndpointsByLevelAndCategoryAndNameAndMethod: createSelector(
           'selectEndpointsById',
           (endpointsById) => {
               var endpointsByLevel = groupBy(endpointsById, 'level')
               return mapValues(endpointsByLevel, endpointsInLevel => {
                   var endpointsByCategory = groupBy(endpointsInLevel, 'category')
                   return mapValues(endpointsByCategory, endpointsInCategory => {
                       var endpointsByName = groupBy(endpointsInCategory, 'name')
                       return mapValues(endpointsByName, endpointsInName => {
                           return keyBy(endpointsInName, 'method')
                       })
                   })
               })
           }
       ),
       selectEndpointsWithTestCoverage: createSelector(
           'selectEndpointsById',
           (endpointsById) => {
               var endpointsByLevel = groupBy(endpointsById, 'level')
               var coverage = calculateCoverage(endpointsById)
               return Object.assign({},{coverage}, mapValues(endpointsByLevel, endpointsInLevel => {
                   var endpointsByCategory = groupBy(endpointsInLevel, 'category')
                   var coverage = calculateCoverage(endpointsInLevel)
                   return Object.assign({}, {coverage}, mapValues(endpointsByCategory, endpointsInCategory => {
                       var endpointsByName = groupBy(endpointsInCategory, 'name')
                       var coverage = calculateCoverage(endpointsInCategory)
                       return Object.assign({}, {coverage}, mapValues(endpointsByName, endpointsInName => {
                           var methods = keyBy(endpointsInName, 'method')
                           return mapValues(methods, method => {
                               var coverage = method.test_tags ? method.test_tags : [] // display empty array if untested, so chart don't break.
                               return Object.assign({}, {coverage}, method)
                           })
                       }))
                   }))
               }))
           }
       ),
       selectActiveEndpointName: (state) => state.tests.activeEndpoint,
       selectActiveEndpoint: createSelector(
           'selectEndpointsResource',
           'selectQueryObject',
           'selectZoom',
           (endpoints, query, zoom) => {
               if (endpoints == null) return null
               if (zoom && zoom.depth === 'endpoint') {
                   return endpoints.find(endpoint => {
                       return (endpoint.name === zoom.name) && (endpoint.category === zoom.category) && (endpoint.level === zoom.level)
                   })
               } else {
                   return endpoints.find(endpoint => {
                       return (endpoint.name === query.name) && (endpoint.category === query.category) && (endpoint.level === query.level)
                   })
               }
           }
       )
     #+END_SRC
*** Filter
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/filter.js :noweb yes
    :END:
    This is concerned with [[https://github.com/cncf/apisnoop/issues/67][ticket #67, filtering endpoints by regex.]]    There is more info in [[*Be Able to filter all endpoints by some regular expression][Our Todos Section]] about this.  We want to apply a filter that can be set across releases, where the sunburst only displays the endpoints whose name includes the text in this filter.
**** Imports and Layout
    #+NAME: Filter Bundle
    #+BEGIN_SRC js
    import { createSelector } from 'redux-bundler'
      export default {
        name: 'filter',
        <<Filter Reducer>>,
        <<Filter Selectors>>
      }
    #+END_SRC
**** Reducer
     TODO: the filter is hard-coded, and then gets added to the query object.  This is wrong.  We want no filter by default, and then a way to carry it across different releases if it is set.  So there must be some way to determine it based on the current queryObject.
     #+NAME: Filter Reducer
     #+BEGIN_SRC js :tangle no
       getReducer: () => {
         const initialState = {
         }
         return (state=initialState, action) => {
           return state
         }
       }
     #+END_SRC
**** Selectors
     #+NAME: Filter Selectors
     #+BEGIN_SRC js :tangle no
       selectFilter: createSelector(
         'selectQueryObject',
         (query) => {
           if (query == null) return null
           if (query.filter == null | query.filter === undefined) return null
           return query.filter
         }
       )
     #+END_SRC

*** Releases Index Resource
    #+NAME: releases-index-resource.js
    #+BEGIN_SRC js :tangle ./src/bundles/releases-index-resource.js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'releasesIndex',
        getPromise: ({ client, getState }) => {
          return fetchReleasesIndex(client)
        }
      })

      bundle.reactReleasesIndexFetch = createSelector(
        'selectReleasesIndexShouldUpdate',
        (shouldUpdate) => {
          if (shouldUpdate) {
            return { actionCreator: 'doFetchReleasesIndex' }
          }
        }
      )

      export default bundle

      function fetchReleasesIndex (client) {
        return client.service('releases').find({
          query: {
            $select: [
              'name',
              '_id'
            ]
          }
        })
      }
    #+END_SRC
*** Releases

    We have three types of releases: master, sig-release, and conformance.  There are the same versions often within like 1.9 and 1.12 and such.  I want to clearly differentiate them, as before they were all in just one big list.  I am choosing to diff on sig, conformance, master as that seemed the most inherent separator.

    #+NAME: releases.js
    #+BEGIN_SRC js :tangle ./src/bundles/releases.js
      import { createSelector } from 'redux-bundler'
      import {
        filter,
        find,
        includes,
        keyBy,
        map,
        reject,
        split,
        trim,
        isUndefined
      } from 'lodash'

      export default {
        name: 'releases',
        init: (store) => {
          store.subscribeToSelectors(
            ['selectCurrentReleaseName'],
            (currentReleaseName) => {
              store.doMarkCurrentReleaseAsOutdated()
              store.doMarkEndpointsResourceAsOutdated()
              store.doMarkTestsResourceAsOutdated()
            }
          )
        },
        getReducer: () => {
          const initialState = {}

          return (state = initialState, action = {}) => {
            return state;
          }
        },
        selectCurrentReleaseName: createSelector(
          'selectRouteParams',
          (routeParams) => {
            return routeParams.releaseName || 'master'
          }
        ),
        selectCurrentReleaseId: createSelector(
          'selectCurrentReleaseName',
          'selectReleasesIndex',
          (currentReleaseName, releasesIndex) => {
            if (releasesIndex == null) return null
            const release = releasesIndex.find(release => {
              return release.name === currentReleaseName
            })
            return release == null ? null : release._id
          }
        ),
        selectReleasesIndexByName: createSelector(
          'selectReleasesIndex',
          releasesIndex => keyBy(releasesIndex, 'name')
        ),
        selectCurrentReleaseObjectRaw: createSelector(
          'selectCurrentReleaseName',
          'selectReleasesIndexByName',
          (currentRelease, releasesIndex) =>  {
            if (releasesIndex == null) return null
            return find(releasesIndex, (release) => {
              return includes(release.name.toLowerCase(), currentRelease.toLowerCase())
            })
          }
        ),
        selectCurrentReleaseObject: createSelector(
          'selectCurrentReleaseObjectRaw',
          (rawRelease) => {
            if (rawRelease == null) return null
            var nameArr = split(rawRelease.name, '_')
            if (nameArr.length === 1) {
              return {
                version: '',
                release: nameArr[0],
                date: ''
              }
            }
            return {
              version: nameArr[0],
              release: nameArr[1],
              date: nameArr[2],
              e2eOnly: !isUndefined(nameArr[3])
            }
          }
        ),
        selectReleasesSigOnly: createSelector(
          'selectReleasesIndexByName',
          (releasesIndex) => {
            if (releasesIndex == null) return null
            return filter(releasesIndex, (o) => {
              return includes(o.name.toLowerCase(), 'sig')
            })
          }
        ),
        selectReleasesConformanceOnly: createSelector(
          'selectReleasesIndexByName',
          (releasesIndex) => {
            if (releasesIndex == null) return null
            return filter(releasesIndex, (o) => {
              return includes(o.name.toLowerCase(), 'conformance')
            })
          }
        ),
        selectReleasesMasterOnly: createSelector(
          'selectReleasesIndexByName',
          (releasesIndex) => {
            if (releasesIndex == null) return null
            return filter(releasesIndex, (o) => {
              return includes(o.name.toLowerCase(), 'master')
            })
          }
        ),
        selectReleasesSigIndexE2E: createSelector(
          'selectReleasesSigOnly',
          (sigReleases) => {
            var e2eOnly = filter(sigReleases, (o) => {
              return includes(o.name.toLowerCase(), 'e2e')
            })
            return map(e2eOnly, (sigRelease) => {
              var nameWithoutSig = trim(sigRelease.name, 'sig-release_')
              var shortName = split(nameWithoutSig, '_')[0]
              return {
                name: shortName,
                url:sigRelease.name,
                _id: sigRelease._id
              }
            })
          }
        ),
        selectReleasesSigIndexNoE2E: createSelector(
          'selectReleasesSigOnly',
          (sigReleases) => {
            var noE2E = reject(sigReleases, (o) => {
              return includes(o.name.toLowerCase(), 'e2e')
            })
            return map(noE2E, (sigRelease) => {
              var nameWithoutSig = trim(sigRelease.name, 'sig-release_')
              var shortName = split(nameWithoutSig, '_')[0]
              return {
                name: shortName,
                url:sigRelease.name,
                _id: sigRelease._id
              }
            })
          }
        ),
        selectReleasesConformanceIndexNoE2E: createSelector(
          'selectReleasesConformanceOnly',
          (conReleases) => {
            var noE2E = reject(conReleases, (o) => {
              return includes(o.name.toLowerCase(), 'e2e')
            })
            return map(noE2E, (conRelease) => {
              var nameWithoutCon = trim(conRelease.name, 'conformance_')
              var shortName = split(nameWithoutCon, '_')[0]
              return {
                name: shortName,
                url: conRelease.name,
                _id: conRelease._id
              }
            })
          }
        ),
        selectReleasesConformanceIndexE2E: createSelector(
          'selectReleasesConformanceOnly',
          (conReleases) => {
            var e2eOnly = filter(conReleases, (o) => {
              return includes(o.name.toLowerCase(), 'e2e')
            })
            return map(e2eOnly, (conRelease) => {
              var nameWithoutCon = trim(conRelease.name, 'conformance_')
              var shortName = split(nameWithoutCon, '_')[0]
              return {
                name: shortName,
                url: conRelease.name,
                _id: conRelease._id
              }
            })
          }
        ),
        selectReleasesMasterIndex: createSelector(
          'selectReleasesMasterOnly',
          (masterReleases) => {
            return map(masterReleases, (masterRelease) => {
              return {
                name: masterRelease.name,
                url: masterRelease.name,
                _id: masterRelease._id
              }
            })
          }
        )
      }
    #+END_SRC
*** Routes
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/routes.js :noweb yes
    :END:
    #+NAME: routing
    #+BEGIN_SRC js
      import MainPage from '../pages/main-page'
      import NotFound from '../components/not-found'

      import { createRouteBundle } from 'redux-bundler'

      export default createRouteBundle({
        '/': MainPage,
        '/:releaseName': MainPage,
        '*': NotFound
      })
    #+END_SRC
*** Sunburst
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/sunburst.js :noweb yes
    :END:
**** Imports and Layout
    #+NAME: charts.js
    #+BEGIN_SRC js
      import { fadeColor, propertiesWithValue } from '../lib/utils'
      import { createSelector } from 'redux-bundler'
      import {
        forEach,
        includes,
        flatMap,
        join,
        map,
        orderBy,
        reduce,
        sortBy,
        values
      } from 'lodash'


      export default {
        name: 'charts',
        <<Sunburst Reducer>>,
        <<Sunburst Selectors>>,
        <<Sunburst Action Creators>>
      }

      <<Sunburst Helper Functions>>
    #+END_SRC
**** Reducer
   #+NAME: Sunburst Reducer
   #+BEGIN_SRC js :tangle no
     getReducer: () => {
       const initialState = {
       }
       return (state = initialState, action = {}) => {
         return state;
       }
     }
   #+END_SRC
**** Selectors
   #+NAME: Sunburst Selectors
   #+BEGIN_SRC js :tangle no
     selectSunburst: createSelector(
       'selectEndpointsByLevelAndCategoryAndNameAndMethod',
       'selectLevelColours',
       'selectCategoryColours',
       'selectQueryObject',
       'selectZoomedEndpoint',
       (endpointsByLevelAndCategoryAndNameAndMethod, levelColours, categoryColours, queryObject, zoomedEndpoint) => {
         return {
           name: 'root',
           children: map(endpointsByLevelAndCategoryAndNameAndMethod, (endpointsByCategoryAndNameAndMethod, level) => {
             return {
               name: level,
               color: determineLevelColours(queryObject, levelColours, level),
               children: categoriesSortedByEndpointCount(endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint)
             }
           })
         }
       }
     ),
     selectSunburstSorted: createSelector(
       'selectSunburst',
       (sunburst) => {
         var sortedLevels = orderBy(sunburst.children, 'name', 'desc')
         sunburst.children = sortedLevels
         return sunburst
       }
     ),
     selectInteriorLabel: createSelector(
       'selectQueryObject',
       'selectEndpointsWithTestCoverage',
       (query, endpoints) => {
         var nameAndCoverageInfo = determineNameAndCoverageInfo(query, endpoints)
         return nameAndCoverageInfo
       }
     ),
     selectFocusedPath: createSelector(
       'selectQueryObject',
       'selectZoom',
       (query, zoom) => {
         if (query == null | zoom == null) return null
         var pathObjectRaw = {
           level: relevantValue('level', zoom, query),
           category: relevantValue('category', zoom, query),
           name: relevantValue('name', zoom, query),
         }
         var pathObject = propertiesWithValue(pathObjectRaw)
         var pathValues = flatMap(pathObject)
         var focusedPath = join(pathValues, ' / ')
         return focusedPath
       }
     ),
     selectLabelStyle: () => {
       return {
         PERCENTAGE: {
           fontSize: '1.3em',
           textAnchor: 'middle'
         },
         FRACTION: {
           fontSize: '1.2em,',
           textAnchor: 'middle'
         },
         PATH: {
           fontSize: '1em',
           textAnchor: 'middle'
         },
         DESCRIPTION: {
           fontSize: '0.9em',
           fontFamily: 'IBM Plex Mono',
           textAnchor: 'middle',
           width: '20px'
         }
       }
     }
    #+END_SRC
**** Action Creators
   #+NAME: Sunburst Action Creators
   #+BEGIN_SRC js :tangle no
     doLockChart: () => {
       return {
         type: 'CHART_LOCKED'
       }
     },
     doUnlockChart: () => {
       return {
         type: 'CHART_UNLOCKED'
       }
     }
   #+END_SRC
**** Helper Functions
     The helper functions are grooooooss right now.  It feels far too nested, and I am passing along the query object to too many places.  I feel the color addition should e done as a selector possibly and not hae it be nested within here.-

     This is gross for how many nested functions there are, and that weird confusion between query and zoom.  Is there a better way to handle this?  Essentially, we wanna be able to zoom into a category, and still have the colors and endpoints show based on the query....but when we are zoomed into an endpoint, then there shouldn't be any query happening....it should be noted as 'locked on'.  This whole section smells awful, and would be good to have another set of javascripter eyes on it.

     #+NAME: Sunburst Helper Functions
     #+BEGIN_SRC js :tangle no
       function relevantValue (value, zoom, query) {
         if (zoom[value] !== undefined) {
           return zoom[value]
         }
         return query[value]
       }

       function categoriesSortedByEndpointCount (endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint) {
         var categories = categoriesWithEndpointsAsChildren(endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint)
         return orderBy(categories, (category) => category.children.length, ['desc'])
       }

       function categoriesWithEndpointsAsChildren (endpointsByCategoryAndNameAndMethod, level, categoryColours, queryObject, zoomedEndpoint) {
         return map(endpointsByCategoryAndNameAndMethod, (endpointsByNameAndMethod, category) => {
           return {
             name: category,
             color: determineCategoryColours(queryObject, categoryColours, category, level),
             children: endpointsSortedByConformance(endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint)
           }
         })
       }

       function endpointsSortedByConformance (endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint) {
         var endpoints = createEndpointAndMethod(endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint)
         var sortedEndpoints = sortBy(endpoints, [
           (endpoint) => endpoint.tested === 'untested', (endpoint) => endpoint.isConformance !== 'conformance',
           (endpoint) => endpoint.testTagCount
         ])
         return sortedEndpoints
       }

       function createEndpointAndMethod(endpointsByNameAndMethod, category, level, queryObject, categoryColours, zoomedEndpoint) {
         return values(reduce(
           endpointsByNameAndMethod,
           (sofar, endpointsByMethod, name) => {
             sofar = fillOutMethodInfo(sofar, endpointsByMethod, category, name, level, queryObject, categoryColours, zoomedEndpoint)
             return sofar
           },
           {}
         ))
       }

       function fillOutMethodInfo (sofar, endpointsByMethod, category, name, level, queryObject, categoryColours, zoomedEndpoint) {
         forEach(endpointsByMethod, (endpoint, method) => {
           var { isTested } = endpoint
           var isConformance = checkForConformance(endpoint.test_tags)
           var path = `${name}/${method}`
           var size = (sofar[path] == null) ? 1 : sofar[path].size + 1
           var initialColor = calculateInitialColor(endpoint, isConformance, categoryColours)
           sofar[path] = {
             name,
             parentName: category,
             testTagCount: endpoint.test_tags.length,
             tested: isTested ? 'tested' : 'untested',
             isConformance: isConformance ? "conformance" : "not conformance",
             size,
             color: isTested ? determineEndpointColours(queryObject, initialColor, category, level, endpoint, zoomedEndpoint) : 'rgba(244,244,244, 1)',
           }
         })
         return sofar
       }

       function checkForConformance (test_tags) {
         var tagsAsStrings = test_tags.map(tag => tag.replace(/\[|]/g,''))
         return includes(tagsAsStrings, 'Conformance')
       }

       function determineLevelColours (query, colours, level) {
         if (query.level === undefined) {
           return colours[level]
         } else if (query.level === level){
           return colours[level]
         } else {
           return fadeColor(colours[level], '0.1')
         }
       }
       function determineCategoryColours (query, categoryColours, category, level) {
         if (query.level === undefined) {
           return categoryColours[`category.${category}`]
         } else if (query.level === level && query.category === category){
           return categoryColours[`category.${category}`]
         } else {
           return fadeColor(categoryColours[`category.${category}`], '0.1')
         }
       }
       function determineEndpointColours (query, color, category, level, endpoint, zoomedEndpoint) {
         if (zoomedEndpoint != null && zoomedEndpoint !== undefined) {
           if (zoomedEndpoint.name === endpoint.name) {
             return fadeColor(color, '0.7')
           } else {
             return fadeColor(color, '0.1')
           }
         }
         else if (query.level === undefined) {
           return color
         } else if (query.level === level && query.category === category && query.name === endpoint.name){
           return color
         } else {
           return fadeColor(color, '0.1')
         }
       }
       function calculateInitialColor (endpoint, isConformance, categoryColours) {
         if (endpoint.isTested && isConformance)  {
           return categoryColours[`category.${endpoint.category}`]
         } else  if( endpoint.isTested && !isConformance) {
           var color = categoryColours[`category.${endpoint.category}`]
           var fadedColor = fadeColor(color, '0.2')
           return fadedColor
         } else {
           return 'rgba(244, 244, 244, 1)'
         }
       }

       function determineNameAndCoverageInfo (query, endpoints) {
        // check our query to see how far in the path we are.
        // If a response is null, it means its not a part of the path
        // therefore, we display the preceding level's info.
         if (endpoints == null) return null // this makes sure the endpoints have loaded.
         if (query && query.level === undefined) {
           var name = ''
           var coverage = endpoints.coverage
           var tested = false
           var endpoint = false
           var description= ''
         }else if (query.level && query.category === undefined) {
           name = query.level
           coverage = endpoints[query.level].coverage
           description= ''
         } else if (query.level && query.category && query.name === undefined) {
           name = query.category
           coverage = endpoints[query.level][query.category].coverage
           description= ''
         } else {
           var endpointInQuestion = endpoints[query.level][query.category][query.name]
           name = query.name
           description= determineDescription(endpoints[query.level][query.category][query.name])
           tested = determineTested(endpointInQuestion)
           coverage = endpointInQuestion.coverage
           endpoint = true
         }
         return {name, coverage, description, tested, endpoint}
       }

       function determineDescription (endpoint) {
         var method = Object.keys(endpoint)[0]
         return endpoint[method].description
       }
       function determineTested (endpoint) {
         var method = Object.keys(endpoint)[0]
         return endpoint[method].isTested ? 'Tested' : 'Untested'
       }

     #+END_SRC
**** Thoughts on colour
     Every node has a color that renders in our sunburst.  That color can be in two states: bright if it is focused on, and faded if it is not.  Before, we figured out this color in the d3 visualization by tracing through the keypath every time.  What I feel like we could do now is to check in the sunburst selectors whether or not that node is part of the current URL query. If it is, give it a bright color.  If it is not, give it a faded color.

This means we have to be aware of the node's parent too, because methods and categories are shared across each level.  So you ahve to do a thing of 'are you a part of the path and is your parent also a part of the path, and is your parents.parent a part of the path?  If so, do this color.

I feel this would be easiest with three functions, even though they're kinda similar.  determineLevelColor(level), determineCategoryColor(category), determineEndpointColor(endpoint).  For the level, it just checks whether there is a query and if it's a part of it.  Category checks if there's a query and if it and the level are a part of it.  endpoint the same, but level and category too.

I've now done this, but the functions feel v. fragile to me, like there's a simpler way to go about it that I am just not seeing.  I think the problem is partially that we have a hella nested function by necessity--since we are making a sunburst which is built on nesting, so things are going to feel strangely convoluted inherently?  But it would still be nice to refactor this for simplicity.
*** Summary
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/summary.js :noweb yes
    :END:
**** Imports and Layout
    #+NAME: Summary Bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'

      export default {
        name: 'summary',
        <<Summary Selector>>
      }
    #+END_SRC
k*** Selector
     #+NAME: Summary Selector
     #+BEGIN_SRC js :tangle no
       selectPath: createSelector(
         'selectActiveEndpoint',
         'selectQueryObject',
         'selectZoom',
         (endpoint, query, zoom) => {
           var path = {}
           if (zoom == null && query.level === undefined) {
             path = {
               level: '',
               category: '',
               name: ''
             }
           } else if (zoom !== null && query.level === undefined) {
             path = {
               level: zoom.level,
               category: zoom.category,
               name: zoom.name
             }
           } else {
             path = {
               level: query.level,
               category: query.category,
               name: query.name
             }
           }
           return path
         }
       )
     #+END_SRC

     With selectors, the values are given all at once as soon as  the page starts up.   Which will be before the fetch has returned for our data.  We need to make sure to not try to ask something of the data before it's returned, and so to include the 'if null return null' for both

     We are also taking just the first method in the endpoint....Which means the endpoint is also only showiung in the sunburst for it's own name, and not its methods.  For most of them they will only have a single method, but others do not.  Thed question then is whether each endpoint and method should be shown separately, or whether when you hover over it says how many methods it has and how many of them are tested....the case where an endpoint's put method is tested but its read method is not or some thing like that.  Not sure the best way to tackle this, like what the user would be expecting.

     we want to select the tests from our testsResource based on what's in our active tests

*** Tests Resource
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/tests-resource.js :noweb yes
    :END:

    #+NAME: tests resource
    #+BEGIN_SRC js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'testsResource',
        getPromise: ({ client, store }) => {
          const currentReleaseName = store.selectCurrentReleaseName()
          return fetchTestsByReleaseName(client, currentReleaseName)
        }
      })

      bundle.reactTestsResourceFetch = createSelector(
        'selectTestsResourceShouldUpdate',
        (shouldUpdate, currentReleaseId) => {
          if (!shouldUpdate) return
          return { actionCreator: 'doFetchTestsResource' }
        }
      )


      export default bundle

      function fetchTestsByReleaseName (client, releaseName) {
        return client.service('tests').find({
          query: {
            release: releaseName
          }
        })
      }

    #+END_SRC

*** Tests
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/tests.js :noweb yes
    :END:
**** Imports and Layout
    #+NAME: Tests Bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import { trim } from 'lodash'

      export default {
        name: 'tests',
        <<Tests Reducer>>,
        <<Tests Selector>>,
        <<Tests Action Creators>>
      }
    #+END_SRC
**** Reducer
     I dont' know how much of the old code we'll really need for this now, so I'm putting just a basic amount into the reducer.
     #+NAME: Tests Reducer
     #+BEGIN_SRC js :tangle no
       getReducer: () => {
         const initialState = {
         }
         return (state=initialState, action) => {
           return state
         }
       }
     #+END_SRC
**** Selector
     #+NAME: Tests Selector
     #+BEGIN_SRC js :tangle no
       selectTestTagsIndexRaw: createSelector(
         'selectActiveEndpoint',
         (endpoint) =>{
             if (endpoint == null) return null
             return endpoint.test_tags
         }
       ),
       selectTestTagsIndex: createSelector(
         'selectTestTagsIndexRaw',
         (testTagsRaw) => {
           if (testTagsRaw == null) return null
           return testTagsRaw.map(rawTag => {
             return trim(rawTag, '[]')
           }
          )
         }
       ),
       selectActiveTestsIndex: createSelector(
         'selectActiveEndpoint',
         'selectTestsResource',
         (endpoint, testsResource) => {
           if (endpoint == null || testsResource == null) return null
           var activeTests = testsResource.filter(test => endpoint.tests.includes(test.name))
           return activeTests
         }
       ),
       selectActiveTestsNumber: createSelector(
         'selectActiveTestsIndex',
         (tests) => {
           if (tests == null) return null
           return tests.length
         }
       ),
       selectActiveTest: createSelector(
         'selectQueryObject',
         'selectTestsResource',
         (query, tests) => {
           if (tests == null) return null
           return tests.find(test => test._id === query.test)
         }
       )
     #+END_SRC

     With selectors, the values are given all at once as soon as  the page starts up.   Which will be before the fetch has returned for our data.  We need to make sure to not try to ask something of the data before it's returned, and so to include the 'if null return null' for both

     We are also taking just the first method in the endpoint....Which means the endpoint is also only showiung in the sunburst for it's own name, and not its methods.  For most of them they will only have a single method, but others do not.  Thed question then is whether each endpoint and method should be shown separately, or whether when you hover over it says how many methods it has and how many of them are tested....the case where an endpoint's put method is tested but its read method is not or some thing like that.  Not sure the best way to tackle this, like what the user would be expecting.

     we want to select the tests from our testsResource based on what's in our active tests

**** Action Creators
     #+NAME: Tests Action Creators
     #+BEGIN_SRC js :tangle no
       doDisplayEndpointTests: (payload) => ({dispatch}) => {
         dispatch({
           type: 'TESTS_REQUESTED_FOR_ENDPOINT',
           payload: payload
         })
       }

     #+END_SRC
*** Zoom
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/zoom.js :noweb yes
    :END:
**** Imports and Layout
    #+NAME: Zoom Bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import { split } from 'lodash'

      import { propertiesWithValue } from '../lib/utils'

      export default {
        name: 'zoom',
        <<Zoom Selector>>
      }
    #+END_SRC
**** Selector
     #+NAME: Zoom Selector
     #+BEGIN_SRC js :tangle no
       selectZoomArray: createSelector(
         'selectQueryObject',
         (query) => {
           if (query == null) return null
           if (query.zoomed === undefined) return null
           return split(query.zoomed, '-')
         }
       ),
       selectZoom: createSelector(
         'selectZoomArray',
         (zoomArray) => {
           if  (zoomArray == null) return null
           var zoomRaw = {
             depth: zoomArray[0],
             level: zoomArray[1],
             category: zoomArray[2],
             name: zoomArray[3]
           }
           var zoom = propertiesWithValue(zoomRaw)
           return zoom
         }
       )
     #+END_SRC

     With selectors, the values are given all at once as soon as  the page starts up.   Which will be before the fetch has returned for our data.  We need to make sure to not try to ask something of the data before it's returned, and so to include the 'if null return null' for both

     We are also taking just the first method in the endpoint....Which means the endpoint is also only showiung in the sunburst for it's own name, and not its methods.  For most of them they will only have a single method, but others do not.  Thed question then is whether each endpoint and method should be shown separately, or whether when you hover over it says how many methods it has and how many of them are tested....the case where an endpoint's put method is tested but its read method is not or some thing like that.  Not sure the best way to tackle this, like what the user would be expecting.

     we want to select the tests from our testsResource based on what's in our active tests

*** Config
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/config.js :noweb yes
    :END:
    #+NAME: config.js
    #+BEGIN_SRC js
      import feathers from '@feathersjs/feathers'
      import RestClient from '@feathersjs/rest-client'
      import axios from 'axios'

      // TODO add envify as browserify transform
      const config = {
        backendUrl: process.env.REACT_APP_BACKEND_URL || 'http://localhost:8000/api/v1'
      }

      export default {
        name: 'config',
        reducer: (state = config) => state,
        getExtraArgs: store => {
          return {
            config,
            client: createClient(config)
          }
        }
      }

      function createClient (config) {
        const restClient = RestClient(config.backendUrl)

        return feathers()
          .configure(restClient.axios(axios))
      }
    #+END_SRC
** Components
*** App
    :PROPERTIES:
    :header-args: :tangle ./src/components/app.js
    :END:
    the initiatory component.  This is sort of the standard layout in which all other views are placed within.
    #+Name: App.js
    #+BEGIN_SRC js
      import React from 'react'
      import navHelper from 'internal-nav-helper'
      import { connect } from 'redux-bundler-react'

      import Header from './header'
      import Footer from './footer'

      export default connect(
        'doUpdateUrl',
        'selectRoute',
        ({ doUpdateUrl, route }) => {
          const CurrentPage = route
          return (
              <div onClick={navHelper(doUpdateUrl)}>
              <Header />
              <CurrentPage />
              <Footer />
              </div>
          )
        }
      )
    #+END_SRC

    If you compare this to the original app, you can see it is far less duplicated or strange code.  Everything is just held in the connect function, where we bring in our selectors and actions, and then reference them directly in our presentational component.
    #+NAME: original app
    #+BEGIN_SRC js :tangle no
      import React, { Component } from 'react'
      import { connect } from 'react-redux'
      import { createStructuredSelector } from 'reselect'


      import { selectReleaseNamesFromEndpoints, selectIsEndpointsReady, selectPage } from '../selectors'
      import { fetchEndpoints } from '../actions/endpoints'
      import { doFetchTests } from '../actions/tests'

      import Header from './header'
      import Footer from './footer'
      import ReleasesList from './releases-list.js'

      class App extends Component {

        componentDidMount(){
          this.props.fetchEndpoints()
          this.props.fetchTests()
        }

        render(){
          const {
            Page,
            releaseNames,
            endpointsReady
          } = this.props

          return (
            <div id='app'>
              <Header />
              {endpointsReady &&
               <div>
               <ReleasesList
                 releases={releaseNames}
               />
              <Page />
              </div>
              }
              {!endpointsReady &&
              <div className='min-vh-80'>
              <h3>Loading...</h3>
              </div>
              }
              <Footer />
            </div>
          )
        }
      }

      export default connect(
        createStructuredSelector({
          releaseNames: selectReleaseNamesFromEndpoints,
          endpointsReady: selectIsEndpointsReady,
          Page: selectPage
        }),
        {fetchEndpoints,
         fetchTests: doFetchTests
        })(App)
    #+END_SRC
*** Footer
    :PROPERTIES:
    :header-args: :tangle ./src/components/footer.js
    :END:
   #+NAME: Footer
   #+BEGIN_SRC js
     import React from 'react'

     export default () => (
         <footer className='w-100 flex flex-column flex-row-ns pt2 pb2 h3 pl4 pr4 items-center justify-between bg-black black shadow-3'>
         <div id='logo' className= 'flex flex-wrap items-center justify-center'>
         <a className='contain bg-cncf bg-center h-100 w4' href='https://cncf.io' title='leads to external cncf homepage'>
         <span className='o-0'>cncf</span>
         </a>
         <a className='contain bg-packet bg-center h-100 w4' href='https://packet.net' title='leads to external packet homepage'>
         <span className='o-0'>packet</span>
         </a>
         <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
         </div>
         <div id='source-code' className='flex items-center'>
         <a href='http://binder.hub.cncf.ci/v2/gh/cncf/apisnoop/master' target='_blank noopener noreferrer' title='external jupyter notebook' className='link f5 pl1 white'>See Data in Jupyter</a>
         </div>
         </footer>
     )
   #+END_SRC
*** Filter Container
    :PROPERTIES:
    :header-args: :tangle ./src/components/filter-container.js
    :END:
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   import FilterTag from './filter-tag'
   import FilterForm from './filter-form'

   function FilterContainer (props) {
     const {
       queryObject
     } = props

     return(
         <section id="filter-container" className="mb3">
         {queryObject.filter && <FilterTag filter={queryObject.filter}/>}
         {!queryObject.filter && <FilterForm />}
         </section>
     )
   }
   export default connect(
     "selectQueryObject",
     FilterContainer
   )

 #+END_SRC
*** Filter Tag
    :PROPERTIES:
    :header-args: :tangle ./src/components/filter-tag.js
    :END:
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   function FilterTag (props) {
     const {
       doUpdateQuery,
       filter
     } = props

     return(
         <div id='filter-tag'>
         <p>Filtered By:
          <span className="no-underline near-black bg-light-green inline-flex items-center ma2 tc br2 ph2">
          <span className="f6 ml3 pr2">{filter}</span>
          <button className="but-no-style dib moon-gray" onClick={handleClick}>x</button>
          </span>
          </p>
       </div>
     )
     function handleClick () {
       doUpdateQuery({})
     }
   }
   export default connect(
     "doUpdateQuery",
     FilterTag
   )

 #+END_SRC
*** FilterForm
    :PROPERTIES:
    :header-args: :tangle ./src/components/filter-form.js
    :END:
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   function FilterForm (props) {
     const {
       doUpdateQuery
     } = props

     return(
         <form onSubmit={handleSubmit} className='h2'>
         <label>Filter By:</label>
         <input type="text" name="search" />
         <button type="submit">Search</button>
         </form>
     )

     function handleSubmit (e) {
       e.preventDefault()
       const filterQuery = e.target[0].value
       e.target[0].value = ""
       doUpdateQuery({filter: filterQuery})
     }
   }
   export default connect(
     "doUpdateQuery",
     FilterForm
   )

 #+END_SRC
*** Releases Container
    :PROPERTIES:
    :header-args: :tangle ./src/components/releases-container.js
    :END:
    We currently have it set to only show sig releases.  This is just to check that my filter selection worked.  What we can now do is setup some filters for releases....or even just a better header organization...so it shows 'Releases / Sig / Conformance / Mastr' and within each heading is the releases link.  And maybe ones that have e2eOnly could show up below.   That would end up with like 6 lines, but it would be clear enough to start with.

    So what we wanna do is have releaseList be a component, and we pass it along a property for whether we doing sig or what have you.  -
 #+NAME: Releases Container
 #+BEGIN_SRC js
   import React from 'react'
   import { connect } from 'redux-bundler-react'

   import ReleasesList from './releases-list'

   function ReleasesContainer (props) {
     const {
       releasesConformanceIndexE2E,
       releasesConformanceIndexNoE2E,
       releasesSigIndexE2E,
       releasesSigIndexNoE2E,
       releasesMasterIndex
     } = props

     return(
       <section id="releases-container" className="">
         <div className='flex items-start justify-start'>
         <ReleasesList release={"Master"} all={releasesMasterIndex} />
         <ReleasesList release={"Sig Release"} all={releasesSigIndexNoE2E} e2eOnly={releasesSigIndexE2E} />
         <ReleasesList release={"Conformance"} all={releasesConformanceIndexNoE2E} e2eOnly={releasesConformanceIndexE2E} />
         </div>
       </section>
     )
   }

   export default connect(
   "selectReleasesConformanceIndexE2E",
     "selectReleasesConformanceIndexNoE2E",
     "selectReleasesSigIndexE2E",
     "selectReleasesSigIndexNoE2E",
     "selectReleasesMasterIndex",
     ReleasesContainer
   )

 #+END_SRC

*** Releases List
    :PROPERTIES:
    :header-args: :tangle ./src/components/releases-list.js
    :END:
We are being passed three arguments:
- release :: the Name of the release type, which we use for a header.  A string.

- all :: all the releases that are not e2eOnly.  For Master this will be the only one given.  An Object

- e2eOnly :: Releases filtered to just show e2e tests.  Master won't have this.  This should also be a subset within.  So we need something like "if (e2eOnly && E2EList". An Object

The Release is an Object structured like so:
#+NAME: Example Release
#+BEGIN_EXAMPLE js
{
  name: '1.13.0',
  url: 'conformance_1.13.0_2018-11-02_e2e-only',
  _id: 'AI82329231671'
}
#+END_EXAMPLE

  #+NAME: releases-list
    #+BEGIN_SRC js
    import React from 'react'
    import { connect } from 'redux-bundler-react'


    var ReleasesList = (props) => {
      const {
        all,
        e2eOnly,
        queryObject,
        release,
        releasesIndexShouldUpdate,
        urlObject
      } = props

      if (release == null) return null

      if (releasesIndexShouldUpdate) return null

      return (
          <div className="mr4">
          <h3 className="f3 mt0 ttsc tracked"> { release }</h3>
          <ul className='pl0 ml0'>
          {all.map(releaseItem => {
            return <ReleaseItem release={ releaseItem } queryObject={queryObject}/>
          })}
        </ul>
          {e2eOnly && <E2EList release={ e2eOnly } />}
        </div>
      )

      function E2EList (props) {
        const { release } = props
        return (
            <div>
            <ul className="pl0 ml0"><span className="ttl f4 i mr2">E2E Only</span>
            {release.map(releaseItem => <ReleaseItem release={ releaseItem}/>)}
          </ul>
            </div>
        )
      }

      function ReleaseItem (props) {
        const { release } = props
        var releaseUrl = getReleaseUrl(release.url)
        var classes="f6 link dim br1 ba ph3 pv2 mb2 mr2 dib mid-gray"
        if (releaseUrl === urlObject.pathname) {
          classes = classes + " bg-washed-red"
        }
        return (
            <li className='dib'>
            <a
          className={ classes }
          href={getReleaseUrl(release.url, queryObject)}
          key={release._id}
            >
            {release.name}
          </a>
            </li>
        )
      }
    }

    function getReleaseUrl (release, queryObject) {
      if (queryObject == null || queryObject.filter === undefined) {
        return `/${release}`
      }
      return `/${release}?filter=${queryObject.filter}`
    }

    export default connect(
      'selectQueryObject',
      'selectUrlObject',
      'selectReleasesIndexShouldUpdate',
      ReleasesList
    )





    #+END_SRC
*** Sunburst And Summary
    :PROPERTIES:
    :header-args: :tangle ./src/components/sunburst-and-summary.js
    :END:
    #+NAME: sunburst-and-summary
    #+BEGIN_SRC js :tangle ./src/components/sunburst-and-summary.js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      import SunburstContainer from './sunburst-container'
      import SummaryContainer from './summary-container'

      const SunburstAndSummary = (props) => {
        return (
            <section
              id='summary-and-sunburst'
              className='flex mb4 mt4'
            >
            <SunburstContainer />
            <SummaryContainer />
          </section>
        )
      }

      export default connect(
        SunburstAndSummary
      )

    #+END_SRC
*** Sunburst Container
    #+NAME: sunburst-container
    #+BEGIN_SRC js :tangle ./src/components/sunburst-container.js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      import Sunburst from './sunburst'
      import SunburstHeader from './sunburst-header'

      const SunburstContainer = (props) => {
        return (
            <div id='sunburst-container' className='flex flex-column mr4'>
            <SunburstHeader />
            <Sunburst />
            </div>
        )
      }

      export default connect(
        SunburstContainer
      )

    #+END_SRC
*** Sunburst Header
    :PROPERTIES:
    :header-args: :tangle ./src/components/sunburst-header.js
    :END:
    #+NAME: sunburst-header
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      const SunburstHeader = (props) => {
        const {
          currentReleaseObject,
          currentReleaseIsLoading,
          currentReleaseShouldUpdate
        } = props
        var release = currentReleaseObject

        if (release == null) return null

        return (
            <div id='sunburst-header' className='relative'>
            {(currentReleaseShouldUpdate || currentReleaseIsLoading) && <p className='i fw2 absolute top-0'>Switching To...</p>}
            <h2 className='mb1 mt1 pt4 f1'>
              <VersionTag version={release.version}/>
              {release.release }
              <E2ETag e2eOnly={release.e2eOnly}/>
            </h2>
            {(release.release !== 'master') &&
            <p className='ibm-plex-mono f6 mt0 pt0 pl2'>Data Gathered on { release.date}</p>
            }
            </div>
        )

        function VersionTag (version) {
          version = version.version
          if (version === 'master' || version == null) return null
          if (version === 'sig-release') {
            return <span className='light-red mr2'>Sig Release</span>
          }
          if (version === 'conformance') {
            return <span className='light-blue mr2'>Conformance</span>
          }
          return null
        }

        function E2ETag (e2eOnly) {
          e2eOnly = e2eOnly.e2eOnly
          if (e2eOnly === true) return <span className='f6 i ml1'>e2e only</span>
          return null
        }
      }

      export default connect(
        'selectCurrentReleaseObject',
        'selectCurrentReleaseIsLoading',
        'selectCurrentReleaseShouldUpdate',
        SunburstHeader
      )

    #+END_SRC
*** Sunburst
    :PROPERTIES:
    :header-args: :tangle ./src/components/sunburst.js
    :END:
    #+NAME: Sunburst
    #+BEGIN_SRC js
      import React from 'react'
      import { Sunburst, LabelSeries } from 'react-vis'
      import { connect } from 'redux-bundler-react'
      import {
        get,
        join,
        sortBy } from 'lodash'

      import { propertiesWithValue } from '../lib/utils'

      const SunburstChart = (props) => {
        const {
          interiorLabel,
          labelStyle,
          sunburstSorted,
          queryObject,
          doUpdateQuery
        } = props


        return (
            <div id='sunburst'>
            <Sunburst
          hideRootNode
          colorType="literal"
          data={sunburstSorted}
          height={600}
          width={600}
          getColor={node => node.color}
          onValueClick={handleMouseClick}
          onValueMouseOver={handleMouseOver}
          onValueMouseOut={handleMouseOut}
            >
            {(interiorLabel && interiorLabel.coverage) &&
             <LabelSeries
             data={[{x: 0, y: 60, label: interiorLabel.coverage.percentage, style: labelStyle.PERCENTAGE},
                    {x: 0, y: 0, label: interiorLabel.coverage.ratio, style: labelStyle.FRACTION},
                    {x: 0, y: -20, label: 'total tested', style: labelStyle.PATH}
                   ]} />}
          {(interiorLabel && interiorLabel.endpoint) &&
           <LabelSeries
           data={[
             {x: 0, y: 0, label: interiorLabel.tested, style: labelStyle.PERCENTAGE},
           ]} />}
            <button className='ttsc' onClick={handleReset}>Reset</button>
            </Sunburst>
            </div>
        )
        function handleMouseOver (node, event) {
          var path = getKeyPath(node)
          var rawQuery = {
            level: path[1],
            category: path[2],
            name: path[3],
          }
          var query = propertiesWithValue(rawQuery)
          if (queryObject.zoomed) {
            query.zoomed = queryObject.zoomed
          }
          if (queryObject.filter) {
            query.filter = queryObject.filter
          }
          doUpdateQuery(query)
        }

        function handleMouseOut () {
          var query = {}
          if (queryObject.filter) {
            query.filter = queryObject.filter
          }
          if (queryObject.zoomed) {
            query.zoomed = queryObject.zoomed
          }
          doUpdateQuery(query)
        }

        function handleMouseClick (node, event) {
          var depth = ['root', 'level', 'category', 'endpoint']
          var path = getKeyPath(node)
          var rawQuery = {
            level: path[1],
            category: path[2],
            name: path[3],
            filter: queryObject.filter
          }
          var query = propertiesWithValue(rawQuery)
          var queryAsArray = sortBy(query, ['level','category','name'])
          query.zoomed = `${depth[node.depth]}-${join(queryAsArray,'-')}`
          if (queryObject.filter) {
            query.filter = queryObject.filter
          }
          doUpdateQuery(query)
        }

        function handleReset () {
          if (queryObject.filter) {
            doUpdateQuery({filter: queryObject.filter})
          } else {
            doUpdateQuery({})
          }
        }

        function getKeyPath (node) {
          if (!node.parent) {
            return ['root'];
          }
          var nodeKey = get(node, 'data.name') || get(node, 'name')
          var parentKeyPath = getKeyPath(node.parent)
          return [...parentKeyPath, nodeKey]
        }
      }

      export default connect(
        'selectInteriorLabel',
        'selectLabelStyle',
        'selectQueryObject',
        'selectSunburstSorted',
        'doUpdateQuery',
        SunburstChart
      )
    #+END_SRC

    For our mouse over we'll use the url bundle, which gives us 'doUpdateQuery'.  We can give it an object and it'l add each part to the query string.  So we'll just iterate over the keypath and assign as needed.

The keypath will have at minimum 2 and at most 4 nodes [root, level, category, method].  So we need to take that array and for each index, if there's something there, add it to an object.  Then we pass that object as our query, which updates the url.  This lets us do a thing where we determine the color of a node based on whether it's path is in the query string. our updateQuery makes an object for us, so we then just check whether the aspects of the node's path matches values in the queryObject, and then color it appropriately.

I'm changing it up now to now have a click to lock.  I would rather have it be super easy to navigate through and share, and then you only click to reset.  This feels closer to what people would want.

I do this by also just updating the url.  We are trying to maintain a dumb component, who handles no real logic, it just updates the url which drives the new logic which is then represented fresh in the component.

The interior label was a bit tricky to do, and it has some logic put in that i don't fully like.  It's not fully dumb.  This is a thing to revisit later though.

*** Summary Container
    :PROPERTIES:
    :header-args: :tangle ./src/components/summary-container.js
    :END:

    This will hold the right-hand side of ourr sunburst and summary page, detailing the current path we are on and any relevant information about it.

    #+NAME: Summary Container
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      import TestsSummary from './tests-summary'

      const SummaryContainer = (props) => {
        const {
          currentReleaseShouldUpdate,
          activeEndpoint,
          categoryColours,
          levelColours,
          path,
        } = props

        const level = path.level
        const category = path.category
        const name = path.name
        const description = (activeEndpoint == null) ? '' : activeEndpoint.description

        if (currentReleaseShouldUpdate == null || currentReleaseShouldUpdate === true) return null
        return(
            <div id='summary-container' className=''>
            <p className='f2 mt1 pt4 mb3 fw3'>
            <span style={{color: levelColours[level]}}>{ level }</span>
            <span style={{color: categoryColours['category.' + category]}}>{ category }</span>
            </p>
            <p className='f3 mt0 mb3 ttsc'>{ name }</p>
            <p className='f4 mt0 mb3 i fw2'>{ description }</p>
            <TestsSummary />
            </div>
        )
      }
      export default connect(
        'selectActiveEndpoint',
        'selectCurrentReleaseShouldUpdate',
        'selectCategoryColours',
        'selectLevelColours',
        'selectPath',
        SummaryContainer
      )


    #+END_SRC

*** Tests Summary
    :PROPERTIES:
    :header-args: :tangle ./src/components/tests-summary.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'
      import TestTagsList from './test-tags-list'

      const TestsSummary = (props) => {
        const {
          activeEndpoint,
          activeTestsNumber
        } = props

        if (activeTestsNumber == null || activeTestsNumber === 0) return null
        if (activeEndpoint == null) return null
        if (!activeEndpoint.isTested) {
          return(<p>Untested.</p>)
        } else {
          return(
              <div id='tests-summary'>
              <p>Covered by <span className="green b">{activeTestsNumber}</span> tests.</p>
              <TestTagsList />
              <button onClick={handleClick} className='but-no-style link magic-pointer blue'>Go To Tests</button>
              </div>
          )
        }
        function handleClick () {
          var tests = document.querySelector('.tests-section')
          if (tests == null) return null
          tests.scrollIntoView()
        }
      }

      export default connect(
        'selectActiveEndpoint',
        'selectActiveTestsNumber',
        TestsSummary
      )

    #+END_SRC

*** Test Tags List
    :PROPERTIES:
    :header-args: :tangle ./src/components/test-tags-list.js
    :END:
    this lists all the test tags that are under an endpoint (or more spefifically, for right now, the first method of that endpoint).
    #+NAME: test-tags-list
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      function TestTag (props) {
        const { testTag } = props
        return (
          <li className='dib tal ttsc mr2 mb2 ph2 pv1 mid-gray'>
            { testTag }
          </li>
        )
      }

      function TestTagsList (props) {
        const { testTagsIndex } = props

        if (testTagsIndex == null) return null
        if (testTagsIndex.length === 0) return null

        return (
          <div className="mt4 pl0">
            <p>Tests are coming from:</p>
            <div className="scrollbox">
            <ul className='list pl0 ml0'>
            {testTagsIndex.map(testTag => {
                return <TestTag testTag={ testTag } />
              })}
            </ul>
          </div>
          </div>
        )
      }

      export default connect(
        'selectTestTagsIndex',
        TestTagsList
      )
    #+END_SRC

*** Active Tests list
    :PROPERTIES:
    :header-args: :tangle ./src/components/active-tests-list.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'
      import { map } from 'lodash'

      function TestItem (props) {
        const {
          testItem,
          queryObject,
          doUpdateQuery } = props

        return (
            <li className='mb3 dim'key='test_{ testItem._id }'>
            <button className='but-no-style link mid-gray magic-pointer' onClick={()=> handleClick(queryObject, testItem._id)} title={'info for ' + testItem.name}>{ testItem.name }</button>
            </li>
        )

        function handleClick (query, id) {
          doUpdateQuery({
            ...query,
            test: id
          })
        }
      }

      function TestList (props) {
        const {
          activeTest,
          activeTestsIndex,
          queryObject,
          path,
          doUpdateQuery,
        } = props

        if (activeTestsIndex == null) return null
        if (activeTest !== undefined) return null
        return (
            <div id='tests-list' className='tests-section min-vh-100 mt4'>
            <h2 className='f1'>Tests for <span className='fw2'>{path.level} / {path.category} / {path.name} </span></h2>
            <ul className='list pl0'>
            {map(activeTestsIndex, (testItem) => {
              return <TestItem testItem={ testItem } doUpdateQuery={ doUpdateQuery } queryObject={ queryObject } />
            })}
          </ul>
            </div>
        )
      }



      export default connect(
        'selectActiveTest',
        'selectActiveTestsIndex',
        'selectPath',
        'selectQueryObject',
        'doUpdateQuery',
        TestList
      )
    #+END_SRC

    Since we loading just the info for a particular release, it's far less overhead, so we can do things like add _all_ the tests to our reducer, and then just select the ones that matter to us...but their entire object.   Since this is just a basic filter, it still ends up fast.  Neat!

    When you click on a test it should add it to our query.   Then, the query learns to look for whether there is a Test showing and if so, to display the active test detail.
*** Active Test Sequence List
    :PROPERTIES:
    :header-args: :tangle ./src/components/active-test-sequence.js
    :END:
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'
      import { map, omit } from 'lodash'
      import dayjs from 'dayjs'

      function ActiveTestSequence (props) {
        const {
          activeTest,
          categoryColours,
          levelColours,
          queryObject,
          doUpdateQuery
        } = props

        if (activeTest== null) return null

        return (
            <div id='test-sequence' className="mt4 tests-section">
            <h2>Sequence For <span className='fw2'>{ activeTest.name }</span></h2>
            <button onClick={handleClick}>Back</button>
            <ul className='list'>
            {map(activeTest.sequence, (step) => {
              return <SequenceStep rawStep={ step } levelColours={levelColours} categoryColours={categoryColours}  />
            })}
          </ul>
            </div>
        )

        function handleClick () {
          var queryWithoutTest = omit(queryObject, 'test')
          doUpdateQuery(queryWithoutTest)
        }
      }

      function SequenceStep (props) {
        const {
          categoryColours,
          levelColours,
          rawStep
        } = props

        var step = {
          timestamp: dayjs(rawStep[0]).format('mm:ss'),
          level: rawStep[1],
          category: rawStep[2],
          method: rawStep[3],
          endpoint: rawStep[4]
        }

        return (
            <li className='' key='test_{ testItem._id }'>
            <span className='fw2 i mid-gray mr2'>{ step.timestamp}</span>
            <span className='mr1 ml1 fw2' style={{color: levelColours[step.level]}}>{step.level}</span>
            <span className='mr1 ml1 fw2' style={{color: categoryColours['category.' + step.category] }}>{step.category}</span>
            <span className='mr1 ml1 fw3 ttsc'> {step.endpoint}</span>
            </li>
        )
      }

      export default connect(
        'selectActiveTest',
        'selectCategoryColours',
        'selectLevelColours',
        'selectQueryObject',
        'doUpdateQuery',
        ActiveTestSequence
      )
    #+END_SRC

    Since we loading just the info for a particular release, it's far less overhead, so we can do things like add _all_ the tests to our reducer, and then just select the ones that matter to us...but their entire object.   Since this is just a basic filter, it still ends up fast.  Neat!

    When you click on a test it should add it to our query.   Then, the query learns to look for whether there is a Test showing and if so, to display the active test detail.
** Pages
*** Main Page
   :PROPERTIES:
   :header-args: :tangle ./src/pages/main-page.js
   :END:
   #+NAME: Main Page
   #+BEGIN_SRC js
     import React from 'react'
     import { connect } from 'redux-bundler-react'

     import FilterContainer from '../components/filter-container'
     import ReleasesContainer from '../components/releases-container'
     import SunburstAndSummary from '../components/sunburst-and-summary'
     import ActiveTestsList from '../components/active-tests-list'
     import ActiveTestSequence from '../components/active-test-sequence'

     function MainPage () {
       return (
           <main id='main-splash' className='min-vh-80 pa4 ma4 flex flex-column'>
           <FilterContainer />
           <ReleasesContainer />
           <SunburstAndSummary />
           <ActiveTestsList />
           <ActiveTestSequence />
           </main>
       )
     }

     export default connect(
       MainPage
     )
   #+END_SRC

** Utils
   recurring helper functions
  #+NAME: Utils
  #+BEGIN_SRC js :tangle ./src/lib/utils.js
    import {
      filter,
      isUndefined,
      size,
      words,
      pickBy } from 'lodash'

    export function calculateCoverage (endpoints) {
      var total = size(endpoints)
      var tested = size(filter(endpoints, ['isTested', true]))
      var percentage = (100 * tested /total).toPrecision(3)

      return {
        tested,
        total,
        percentage: `${percentage}%`,
        ratio: `${tested}/${total}`
      }
    }

    export function fadeColor (rgba, desiredOpacity) {
      var rgbaParts = words(rgba, /[^,|^(|^)]+/g)
      rgbaParts.pop()
      rgbaParts.push(desiredOpacity)
      var newRgbaString = rgbaParts.join(',')
      var newRgba = newRgbaString.replace(/,/,'(') + ')'
      return newRgba
    }

    export function propertiesWithValue (obj) {
      return pickBy(obj, (val) => !isUndefined(val))
    }
  #+END_SRC
* Glossary
** Bundle (<<<bundles>>> | <<<bundle>>>)
   a collection of redux code all organized by some concern or idea.  It's a marked difference from the typical organizing style, where you organize files by what they are (reducers, selectors, etc.).  This, instead, organizes files by their topic.
** Component (<<<Component>>> | <<<Components>>>)
Self-contained, presentational parts of our front-end site.  It is what people actually see and interact with on our site.  What is unique is how specific and reusable components are.  Every singular bit of the api should essentially be a component.  We do this because it is easier to build upon, to collaborate with others, to maintain, and to share components across other projects.
** Pages (<<<page>>> | <<<pages>>>)
    A collection of components.  Can be thought as the overall layout for a particular subject within our app.  Basically a 'webpage', but that has built-in headers/footers/navigation and so on.
** Dynamic Web App (<<<dynamic web app>>>)
A site whose content and presentation is determined by code that is run when the site is first loaded.  As opposed to a static web site, where the content is already generated and delivered to you from the server when you log on.  The upside is that it allows for a robust site that is tailored to individual visitors, who can navigate around the area quickly and easily.  The downside is that they can be resource heavy, and do not work on browsers that have disabled javascript.
** Client-Side (<<<client-side>>>)
Refers to  code that is run on the client (as opposed to on the server).  The client is most often the web browser.  So a client-side app, if done well, allows for a quick data fetch from the server and then a snappy full-powered web app since all the functionality is being handled by the browser itself
** Static Web Site (<<<static web site>>>)
A site whose content is pre-set, and not made based on the actions of the site visitor or their browser.  Original html sites are static (coolguy.website being an example).  Apisnoop is dynamic.  You can see the differenve by viewikng the source code of their index.html files.  coolguy has all the code written directly in the file.  apisnoop has nothing except a javascript file waiting to be run.
** Immutable State( <<<immutable state>>> )
In our context, state refers to the state of the app.  Immutable means that it cannot be changed. So this means, whenever there is any action that should change the state we replace the entire state.  For example: the current state might hold values like the current URL, and that we are currently fetching data and it's pending.  When the data fetch is accomplished, we want to update the state.  We do this not by looking for our 'DATA' value and adjusting it.  Instead, we replace the state entirely, with our new state being the same url but now 'data fetch fulfilled'.

Doing it in this way means we can have a snapshot of the state for every update to it.  If we wanna see what the app looked like before the data was fetched, we can simply go back to the state when it was still pending.  This makes the site easier to debug and easier to maintain.

It is a core principle or [[#arch-redux][redux]], and brought up often when discussing redux apps and functional programming.
** Selectors (<<<selector>>> | <<<selectors>>>)
a concept within [[#arch-redux][redux]].  A selector will 'select' data in our redux store, potentially make changes to it, and then give it to our components.  It is a [[arch-redux-bundle][redux bundle]] best practice to never have the componets draw from the redux store directly, and instead always get it from selectors.  This sets up a pattern where the store remains 'dumb', which makes it easier to debug.

 For example, let's say in our app we fetch release names from a server and they come to us like this:
- release_1.12.3
- release_2.4
- release_1.3.1

We want to take these names and display them on the frontpage of the site, but we want them to be sorted, and cleaned up to not have underscores and have relase be capitalized.  We _could_ adjust them as they get added to our store, by doing some quick sort and replace functions in our reducer.  But this will make it harder to reason about later, or compare it to the equivalent files in our server.  Instead, we just want to have raw data in our redux store, have a selector select it, and have the selector do the sorting and cleanup.  This way, if there's an issue with the basic data we check redux.  If there's an issue with sorting or capitalization, we check the selector.  We don't ahve to check some helper function nested inside a reducer store or some other hard to debug thang.
** Reducers ( <<<Reducer>>> | <<<Reducers>>>)
An immutable object containing the current state of the app.  Driving principle of [[#arch-redux][redux]].  Called a reducer because it takes a number of objects given to it and reduces it down to a single thing.  By object, we mean it in the literal javascript sense...and so the entire state of a complex app can be represented as:

#+BEGIN_EXAMPLE
{ name: 'something',
  users: ['list', 'of', 'users'],
  current_path: '/@timothee/profile'
}
#+END_EXAMPLE

In other words, we take a lot of complexity and reduce it down to a text object that can be easily updated or replaced. This brings us closer to designing an app as a spreadhseet, where the frontend is just displaying the data in pleasing way, and the backend has a consistent and logical way to add and amend the data.
** Actions ( <<<action>>> | <<<actions>>>)
  In our context, an object that announces a change in state, along with a payload of data for that change.  Actions are represented as so:

#+NAME: example action
#+BEGIN_EXAMPLE
{
  type: 'NEW_USER_ADDED',
  payload: userData
}
#+END_EXAMPLE

So actions always have a type and a payload.  The type is written like a news headline, and the payload can be anything (a string, an object, an array, an integer, etc).  For more info, check out our conventions section.
** <<<action creator>>>
A function that creates an action.  They are written as 'doThisAction', so in the example above, we might have a function called 'doAddNewUser', and running the function results in the action object above.
** <<<reactor>>> | <<<Reactors>>>
 A special type of selector, that is set up to listen to conditions that should prompt an action.  An example might be if you wanted your app to attempt another data fetch if the first one failed.  You'd have a reactor that was waiting for a 'DATA_FETCH_FAILED' action, and when that came it would trigger a 'DATA_FETCH_STARTED' action in response.  Reactors bring us closer to a clearly separated app, where the reducer just holds data, the components just display the data given, and selectors and reactors handle the rest.
** Store (-<<<store>>>)
Kinda used interchangable with state, and short for redux store.  It refers to the big object containing the entire state of the app.
** State (<<<State>>>)
  All the data, properties, truths, and so on of the app at this moment in time.  Similar to your emotional, personal, physical state.

* Tasks                                                            :apisnoop:
** NEXT Be Able to filter all endpoints by some regular expression
  [[https://github.com/cncf/apisnoop/issues/67][github link]]
  When talking to Chris, I got a bit more context.  Right now, we can filter by whether an endpoint is part of the selected level,category, endpoint name.  We can also select endpoints by release.  There may be a time when you want to see all of a certain kind of endpoint, but they don't fit neatly into one of these.  For example, maybe you want to see all endpoints that have to do with namespace, or disk, or storage.  Regardless of what release they are in, or whether they're tested or not, all that matters is that they are part of storage.  One way we could do this is by checking the endpoint's name to see if it includes storage, or namespace, or disk.  This would at least be clear enough to the user that we are filtering by whatever text they've entered.

I feel like this filter should be added before we get to the releases.  The use case I am imagining is that a member of the 'Disk' storage group wants to use APISnoop, and see how their covedrage has increased over releases.  So they filter everything to 'disk', then check 1.9, 1.10, 1.11, etc.  It would be annoying to switch release and hit the filter everytime.  If there's a filter added, it should show until someone has x'ed out the filter.

- [5/5] Method To Explore and Build This:
  - [X] Add a new bundle for filter
  - [X] Set a reducer for this filter that has some hardcoded name in by default.  Let's not do regex yet, just letters.
  - [X] Add that reducer value to our url.
  - [X] Show that url value no matter what release they are on.
  - [X] filter the endpoints by this filter.

So the first exploration works, but we need to make it actually usable:
- [0/4] Steps towards actual usability:
  - [ ] The filter can be set from the front-end.
  - [ ] You can type whatever you want, press enter, and see that as the set filter.
  - [ ] You can remove the filter you've set.
  - [ ] Typing in a new filter replaces the one you've set.
- [0/3] Steps towards sharability:
  - [ ] you can set multiple filters.
  - [ ] You can add and remove individual filters

** TODO [0/0] Incoporate 'App Usage' into,  our  visualization
There will be a new piece of data, provided by yaml, that says 'here are endpoints, and the number of applications that hit those endpoints.
   So what we want to be able to see is some sort of flare that shows the number of applications using this endpoint, and also whether that endpoint is tested.  This would let us see 'what is next', by focusing on the endpoints with the most app dependencies that are not yet tested.  So for this we would need to move through the yaml file to get that uinformation and know it's available within the app, and then to find a way to visualize it clearly, so the shape of the sunburst itself helps people figure out how to focus on the next part.
*** [ ] TODO Parse the yaml file to get the relevant app usage data
*** [ ] TODO Add this parsed info as an endpoint in our backend database.
*** [ ] TODO Make the info avaialble to the site, so we can show that each endpoint has information about it's app usage
   AT the start this could just be a number and a list in the summary.  Like, when you click on an endpoint it says "used by 10 apps" .  This is a minimum example that we have that data corresponding to each endpoint
*** [ ] TODO Incorporate that information into the shape of the sunburst
    Similar to how it's tested value determines the endpoints color, to see whether it's application count can determine it's size.  So the highter the numbedr, the longer that endpoint node is.
*** [ ] TODO Sort the sunburst by App count, in addition to it's current sorting.
We are currently sortiung by tested/untested, tested by conformance/tested but not by conformance.  We want to keep this, and then also add appcount, so the largedr number of aps show on the left.  This would cause a swooping affect, and so the 'next mission' would be the next highest part of the swoop.
** IDEA [12/14] Future Tasks
   - [ ]  Integrate user interaction with sunburst (filter by UserAgent).  This'll test our hypothesis that we can manipulate the data far quicker than before.
   - [X] Hover over Part of Sunburst shows relevant rays highlighted.
   - [X] Hover over Sunburst, see testing percentage update in center.
   - [ ] Click on Useragent, sunburst zooms onto that subset of data.
   - [X] Refactor Chart Selector to not be heavily nested..
   - [X] Move colors calculation out of sunburst selector into its own thing.
   - [X] Separate sunburst selector thangs from chart interaction thangs (maybe?  may be premature optimization).
   - [X] Remove unused props from app.js
   - [X] Improve performance of page load, by only calling a test when needed.
   - [X] Refactor tests so the entire object isn't being loaded in the client.  That feels way too heavy, and instead you should only load up the testInfo (all the api endpoints being accessed) when there is an active_test, and you display that only on that active test.
   - [X] When you click on an endpoint, it adds to the URL so that you can share the URL and have be right on the hovered sunburst with the filtered tests and such.
   - [X] add queryString to our arsenal, so you can do a direct url to an endpoint
   - [X] Add logic to API to filter endpoints to only those touched by e2e. We are showing all.  It'll be faster, and simpler to only be ones whose useragents includes the regex string 'e2e.test'
   - [X] add correct a href for each test to work properly.
** IDEA Add a test-tag filter for entire sunburst.  So instead of percentage tested, it is percentage tested _by that test_tag_.
** IDEA refactor helper functions for clarity and to not have them be deeeeeply nested
   [2018-12-12 Wed]
   [[file:~/ii/apisnoop/webui/client/client.org::Sunburst%20Helper%20Functions][Sunburst Helper Functions]]
** IDEA document our bundles better within the org file, separate each function into clear and testable things maybe?
** TODO The test tags box is a fixed height, with indication that there's more test tags to see if the content overflows
   I wanna try to do it based with pure css and this now 7 year old blog post [[https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing][so: check if an elmeent's content is overflowing]]
   So i'ma add the following code to the test tags box and just see how it looks
   #+BEGIN_EXAMPLE css
       .scrollbox {
       overflow: auto;
       width: 200px;
       max-height: 200px;
       margin: 50px auto;

       background:
         /* Shadow covers */
         linear-gradient(white 30%, rgba(255,255,255,0)),
         linear-gradient(rgba(255,255,255,0), white 70%) 0 100%,

         /* Shadows */
         radial-gradient(50% 0, farthest-side, rgba(0,0,0,.2), rgba(0,0,0,0)),
         radial-gradient(50% 100%,farthest-side, rgba(0,0,0,.2), rgba(0,0,0,0)) 0 100%;
       background:
         /* Shadow covers */
         linear-gradient(white 30%, rgba(255,255,255,0)),
         linear-gradient(rgba(255,255,255,0), white 70%) 0 100%,

         /* Shadows */
         radial-gradient(farthest-side at 50% 0, rgba(0,0,0,.2), rgba(0,0,0,0)),
         radial-gradient(farthest-side at 50% 100%, rgba(0,0,0,.2), rgba(0,0,0,0)) 0 100%;
       background-repeat: no-repeat;
       background-color: white;
       background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px;

       /* Opera doesn't support this in the shorthand */
       background-attachment: local, local, scroll, scroll;
     }
   #+END_EXAMPLE
* Progress
** DONE Click on test, show test sequence below
   CLOSED: [2018-12-17 Mon 12:42]
** DONE add back functionality for test,to clear out test query.
   CLOSED: [2018-12-17 Mon 12:43]
** DONE pass along a query when you click, that includes zoom depth and an array of the current node path.
   CLOSED: [2018-12-19 Wed 11:17]
    I now have it so when you mouseClick, it saves the level in whikch you clicked and the full path to get you there.  We will then use the zoomed queryObject to act as our filter.  We want to have the filtering of the endpoints be separate from whether or not they are hovered upon.  This will let us share a zoomed in sunburst with highlights.

    The zoom queryObject will be a string we need to break apart.  It will be ~depth-level-category-name~.  if the depth is level, we know there'll only be a single item in the array.  If it's name, we'll know there are three.
    We did this by making it a query string like ~depth-level-category(maybe)-endpoint(maybe)~
** DONE add Zoom function to the sunburst.
   CLOSED: [2018-12-19 Wed 11:17]
   The idea is you can cluick on a level or category and the sunburst makes it so the  root is now that partticular level or category.
   o
   IK want this to still be sharable, so I thinkj that means this needs to be added to the url too.   Otherwise, you'd share and have to remember to click on one of the right endpoints or go through the same sequence again, which is silly.

   We don't want to zoom in on an endpoint.  If you click on an endpoint,it really doens't do much else, which i think is good.  So then someone could only be zoomed on level or category.

   So we could have a url with something like:
apisnoop/?level=alpha&category=apps&zoom=level

What we need to do, then, it take in the zoom query and if it is null then root is root.  Otherwise, root is whatevever is that focus.

The other thing we need to do is indicate what that foucus is somehow.  Like....there are multiple app categories, one for each level.  If we are focused to a category, how do we visually know which level we are in?  We could indicate it with text saying 'zoomed to stable'.  But it would be nicer to have it be color somehow....

What happens if we just remove the other options?  What does that look like?  so we don't change the root, we just filter out the tree.  So we make it so there are no other levels.....So there'd be a hard green ring if you clicked on stable, and then a full on orange ring if you clicked on apps.  I like this.

So now we need a 'doUpdateZoom' that takes in the node you clicked on.  Then, update our sunburst selection....or even just our endpoints...yah, filter out the endpoints to just the ones that fit the zoomed click.  If it's a

We can filter the initial endpoints based on the query.  For example, here is a hard-coded version:

So we now have it when you click it records the depth in whioch you clicked and then updates the endpoints to filter dcown to that.  I am doing this by the query, to have evbertyhign happen by the url.  But this sin't actually sueful now, because as soon as yolu8 move the entire filtering vvhagnes andc things go wrong.
o
I think we need to do somethiong now where we update our url to show it is zoomed, but we also filter the endpoints as a separate action.  If the endpoints are added to our reducer, then wse just need to change what those are there.  So then when you click on an action, it would filter the endpoints given to us by that action.....Though i kinda wanna not mess those up too much.  I like that it's just a static resource...

But essentiallywe'd have 'doZoomEndpoints' which looks at the depth you're at and the node information (taking the keypath and such) and then filters accordingly (so we are alooking at the right endpoint or category, not all endpoints and categories regardless of level).  Then, when you click clear it clears it out.

The big info we need is the depth of zoom and the
keypath of the zoom.  Both of these could be added to the reducer.  Then, our selector takes all endpoiunts and looks at store.zoomed and if it is set to anything takes a look at store.zoompath and filters accordingly.  This is the way to do it, I think.  It is not messing with our endpoints...it's only filtering the display of them, based on a click status.

This also allows us to pass along info that wouldn't look good uin the url.  The url can just keep the zoom information.  naaaaah, this doesn't work either, though.  Because it means if we want to share the zoomed in url we wouldn't be able to.  We need to have the current query, plus the zoom, plus the zoom path (for the times when you aren't hovered over a section, but still filtered in)

So it's really zoom filter and the question is...can you pass along an array in yr url query?  let's find out tomorrow!

#+BEGIN_EXAMPLE js

       selectEndpointsById: createSelector(
         'selectEndpointsResource',
         (endpoints) => {
           if (endpoints == null) return null
           endpoints = endpoints.filter(endpoint => endpoint.level === 'stable' && endpoint.category === 'core')
           return keyBy(endpoints, '_id')
         }
       )
#+END_EXAMPLE

When you click on a node in the sunburst, it includes the depth of the node, which maps to whether it's a level, category, or endpoint.  When you click, you likely don't want that one part highlighted too....it should _just_ be the zoom until yolu hover over again.  So we can update the query to just 'zoom: depth'
** DONE Separate our releases into sig, conformance, master.
   CLOSED: [2018-12-20 Thu 14:25]
   if you click on sig or conformance, you get the release numbers.  Then, you can choose an 'e2e' only tag too.
   this is to help with the styling later on. The majority of the functionality is here, now we just gotta make it look pretty.  The releases seems like the best way to do that.
   We can separate based on whether the release name includes any of these keywords.  AS long as we keep our naming standard, this will be fine.  I also added a shortName that was just the release.  The problem this poses is when something is e2ed only because it will have the same release name but have the e2ed part tthat is unclear....so i gotta seperate to _just e2e_ or _without e2e_ before i do the naming stuff.

   What it will look like is:
   - all Releases
   - only sig releases
   - sig releases not e2e,
   - sig releases e2e only
   - only conformance releases
   - conformance releases not e2e,
   - conformance releases e2e only
   - master release
** DONE Change our font to IBM Plex Sans
   CLOSED: [2018-12-21 Fri 11:44]
** DONE Add More Info to our Sunburst Heading
   CLOSED: [2018-12-21 Fri 11:44]
   We could add Refined Name and Date of Pull.  That would look nice!
** DONE Share a link to a build and the build loads quickly
   CLOSED: [2018-12-11 Tue 09:38]
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/15][issue link]]
** DONE consolidate notes from last mikey pair (the note left about the role of the url)
   CLOSED: [2018-12-11 Tue 09:30] SCHEDULED: <2018-12-06 Thu>
  it is in patchwork .  Find it and add it after!

** DONE [11/11] Tasks For Refactoring our Data and understanding of it.
   CLOSED: [2018-11-07 Wed 21:01]
   - [X]  Convert JSON dump to New Flat Database
   - [X] Hookup react/redux to query endpoints.
   - [X] Integrate Reselect to computed data views (instead of getting data, withoutm assaging, and trying to fit it into the sunburst.)
   - [X] Practice Converting flat database to Sunburst Data structure.
   - [X] Sort Level so it is Stable, Beta, Alpha
   - [X] pass down chart selector data to main page props, pass down focused key path to render label within sunburst
   - [X] Add Percentage Calculation to center label.
     - I think I would want to do a data transformation, that counts the isTested for each of the child nodes, and piles that into an equation in the parent node.
     - How much of the existing work can I use with this?
     - STRATEGY: we've added the coverage to our endpoints information.  So we could now have a 'coverage' selector that listens to the full path array and finds the coverage information in the endpoints for it.  We don't need to do any extra action, we just need to work off our existing stuff.
     - If nothing is set, then we are going to want to know the coverage by release.  So the first step, then, would be: 'Without Focus Path selectInteriorLabel = endpoints[release][coverage]' with focus path it would be endpoints[release][fp1][fp2][coverage]...i guess based on the full apth length (it could be up to 3, level, category, endpoint).
   - [X] Fix routing so activeRoute isn't hard-coded.
   - [X] re-hook up routing to route by release name
   - [X] Query endpoints by Release.
   - [X] remove dependency on releaseStore reducer.
** DONE [10/10] Achievements To Unlock to match and surpass old webui
   CLOSED: [2018-11-06 Tue 13:49]
   - [X] Mikey has a functional understanding of what we're trying to do.
   - [X] It generally feels better
   - [X] Sunburst Changes Based on Route
   - [X] It loads faster
   - [X] When you click on a test, it lists the endpoints sequence.
   - [X] Add testTags to our endpoint api
   - [X] When you hover on an endpoint, it shows the test tags.
   - [X] When you click on an endpoint, it locks the chart in place.
     - [X] Add 'clicked' as state in sunburstChart, following the same logic in the [[https://github.com/uber/react-vis/blob/master/showcase/sunbursts/basic-sunburst.js][react-vis tutorial]]
     - [X] When you mouseOut, if clicked isn't true //then// send out the clearing of focusPath.  Otherwise, keep it.
   - [X] When you click on an endpoint, it filters the list of tests to just the ones that touch that endpoint.
     - [X] Devise strategy: when you click on a node you have the focus path as an array, which would end with an endpoint (if we are on an endpoint, otherwise it'd show the category or level). We have tests who each have an endpoint listed within them.  Maybe we query our db at that point for tests?endpointsIncludeEndpointName, or something similar to that.  Then, we change the logic beneath to only show tests once an endpoint is clicked, and it's based on the tests we retrieve...
     - [X] Doublecheck our releases for tests, to see how it be structured:  it goes release.data.tests.count.endpoints.  These endpoints //look// to correspond with our endpoint names pretty nicely.  But I think this means we'll have to separate out the tests into their own endoint too. It'd be best if it was just called 'tests', but we already ahve that for test_sequence.  how hard is it to switch that over?
   - [X] When you view the endpoint sequence, it is single line with a timestamp of HH:MM:SS:ss and then the rest of the info.
** DONE Change front-end logic so it only pulls data from the necessary sunburst.
   CLOSED: [2018-11-04 Sun 22:29]
   Right now the we have an endpoint called /Releases, organized by Build name.  These correspond to the sunbursts.  We are pulling in the entire api, we should only do buildname.data.sunburst
*** [3/4] Subtasks
    - [X] Remove excess noise from front-end for right now--the filters essentially.
    - [X] Add URL path to each Release you click
    - [X] Add fetchSunburst action to sunburst segment component, and pass it along the url params.
    - [ ] Query the api database based on the params and return just the sunburst data.`
** DONE change keypath logic so it only highlights if parent is on keypath.
   CLOSED: [2018-11-04 Sun 22:30]
** DONE-AND-SHARED [6/6] Add Test Information To Webui
   CLOSED: [2018-11-06 Tue 03:37]
   - State "DONE-AND-SHARED" from "NEXT"       [2018-11-06 Tue 03:37]
   When I am looking at a release,  I can see both the sunburst and a list of tests that happen with this release, so that I have more context on what is actually happening with our test coverage.
   When I click on a test, I can see a chronological list of the endpoints it accesses, so I can understand what this test is doing and if it is necessary.
- [X] Add unique api endpoint for tests
- [X] Bring the tests into our redux store when app first loads.
- [X] Massage data to group by release, using same format as our endpoints
- [X] list tests to side of sunburst
- [X] clicking on a test makes it the 'active_test', which updates state.
- [X] When there is an active_test, display its chronological list.  does not need to be styled fancy.

** DONE-AND-SHARED Visually distinguish tested endpoints tagged [Conformance]
   SCHEDULED: <2018-12-06 Thu>
   - State "DONE-AND-SHARED" from "DONE"       [2018-12-05 Wed 14:22]
   [[https://github.com/cncf/apisnoop/issues/46][Github Issue]].  So we can do a bit of regex on the endpoint...though I thionk each one has a test tag and those would include conformance...right?
** DONE get basic webpage working with redux bundler
   CLOSED: [2018-12-05 Wed 11:29]
   just get it to say hello at least
** DONE bring back our headers and footers to basic page
   CLOSED: [2018-12-05 Wed 14:22]
** DONE add glossary of common react/redux terms.
** DONE get releaseNames showing on app page
   CLOSED: [2018-12-11 Tue 09:29]
** DONE Choose Current Release and Sync with URL
   CLOSED: [2018-12-11 Tue 09:29]
** DONE When URL shows current release, fetch current release and endpoints and test
   CLOSED: [2018-12-11 Tue 09:30]
** DONE Render Chart with data from Current Release
   CLOSED: [2018-12-11 Tue 09:30]
** DONE Better understand the use of resource as a bundle name.  Is this temporary, or a good pattern?
   CLOSED: [2018-12-11 Tue 09:29] SCHEDULED: <2018-12-06 Thu>
** DONE Hover over chart adds level, category, and method to url
   CLOSED: [2018-12-11 Tue 10:26]
** DONE Chart is focused based on the level, category, and method in url
   CLOSED: [2018-12-12 Wed 11:07]
** DONE Share a link to a chart filtered to an endpoint
   CLOSED: [2018-12-12 Wed 11:07]
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/12][gitlab link]]
  this would be filtered to level, category, endpoint, and method.  iT shoudl show the chart locked and highlighted.
** DONE Webui loads meaningful chart within seconds
   CLOSED: [2018-12-12 Wed 11:07] SCHEDULED: <2018-12-06 Thu>
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/9][gitlab link]]
  before any data lods, there'll be a chart outline to signify loading.  But the data should still come quickly.
** DONE Add path to the top of the sunburst chart
   CLOSED: [2018-12-13 Thu 12:39]
** DONE Add Tests to the side of the sunburst chart
   CLOSED: [2018-12-13 Thu 18:00]
** DONE only load the tests that matter for the release, not all possible tests.
   CLOSED: [2018-12-13 Thu 12:39]

   #+BEGIN_SRC js :result output
     var lodash = require('../node_modules/lodah')
   #+END_SRC
** DONE-AND-SHARED show tests properly based on endpoint.
   CLOSED: [2019-01-07 Mon 14:54]
   - State "DONE-AND-SHARED" from "TODO"       [2019-01-07 Mon 14:54]
    I want to add something for clicking on an endpoint that locks it in place.  If it's a category or level ikt should zoom, if it's ane dnpoint it should lock.  So it's listenikng in on a zoom query and updating locked to true.  What happens if you click again, then lock should be reset....so on mou8se click the zoom level is set.  When you mouse click again it should unlock...?  What shoudl the interaction be if you8 lock on an endpoint and then hove over another endpoint?  which information do you give?  there is a disagreement over hover-path and such....easiest way would be to zoom in still, and display tests if you are zoomed in on an endpoint....Mouse out would still work, and the tests should display...if endpoint is locked to that endpoint....otherwise to whichever one you are hovered over....
    So then the question is not settiong this, but whether we can base the tests on the urlQuery of zoomed instead of urlObjectquery....we can do this.
   if (query.zoomed === endpoint, test is endpoint else test is query.endpoint).
** DONE Add a summary card for information about path and endpoint.
   CLOSED: [2019-01-07 Mon 16:15]
** DONE add path as a selector, to remove logic from the summary Container
   CLOSED: [2019-01-07 Mon 18:27]
   right now it is checking whether we are zoomed or not, and deciding on the path it shows from that.  This could be a selector instead, which would keep our components dumb.  This is an optimization though and can be ignored for _right_ now.
** DONE [8/8] Overhaul styling:
   CLOSED: [2019-01-08 Tue 16:24]
   - [X] interior label.  This can be fixed by having a summary card, and moviung the path to there.   so the endpoint interior label just says 'tested' or 'untested'
   - [X] releases list
   - [X] Type
   - [X] footer always at foot
   - [X] clear button, name changed to 'RESET'.  Put it inside the sunburst.
   - [X] sunburst doesn't jump up and down when hovering between items with tests and without
   - [X] There is a summary section to right of chart that includes path and number of tests.
   - [X] Tests are styled closer to what's on staging (cleaerly differentiated timestamp, differentiated test-tag, etc)
     - [X] test list
     - [X] test run
** DONE when switching bedtween releases, title says 'switching to' until the graph itself has loaded.
   CLOSED: [2019-01-08 Tue 16:24]
** DONE test tags still show when zoomed in but not hovering over
   CLOSED: [2019-01-08 Tue 16:40]
   I think this has to do with the active endpoint, and the active endpoint should be based on zoom if zoomdepth is at endpoint, otherwise it is query.  If this happens enough, i wonder if this should be its own function of some sort (distinction between zoom and query.).
** DONE re-check how we are grabbing releases.  We aren't using the id, just the name.  Is that alright?
   CLOSED: [2019-01-08 Tue 16:43]
   We are matching on both!  we good!
** DONE We have distinct dev and prod environments for the client
   CLOSED: [2019-01-08 Tue 16:43]
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/11][gitlab link]]
  interesting note for debugging for production.  Redux dev-tools is built into redux bundle, and can be turned on or off based on if local.storage.debug is set to true or false.  From the  [[https://reduxbundler.com/guides/patterns.html][redux-bundle documentation]]:
===
Using Redux DevTools
Both the debug bundle and redux dev tools are enabled if localStorage.debug is set to something "truthy". In this way you can keep your production apps debuggable, you just have to flip that localStorage.debug flag to enable it. Also beware that running localStorage.debug = false in your browser console won't actually turn it off. This is because LocalStorage serializes everything to strings so the value that's stored is actually the string "false" which... is truthy! So to turn it back off again, you can just do: delete localStorage.debug instead.
===
** DONE-AND-SHARED When you click on an endpoint, it has different viz than level and category
   CLOSED: [2019-01-17 Thu 11:55]
   - State "DONE-AND-SHARED" from "IN-PROGRESS" [2019-01-17 Thu 11:55]
  [[https://github.com/cncf/apisnoop/issues/55][github link]]
   What we are doing now is having an onMouseClick for the sunburst.  When you click it updates the zoom section of our Url Query.  This contains the zoom depth and the full path to get there (as zooming might be a different path then the current mouseover)

   Then, we have a zoom selector that listens to that query and constructs an object from it.  This object is passed to our endpoint selector, which decides which endpoints ot give to the sunburst.  It filters by the current zoom object...so if we are zoomed to the level/core, then those are the only endpoints shown in the sunburst.  If we are filtered to level/core/endpointX then that's literally the only endpoint given to the entire sunburst...This is why it has a strange zoomed in view.

   So the immediate fix is to remove the endpoint filter when zoomed to an endpoint.  We still track the zoomin', but keep all endpoints up to level and category.  What this won't handle is mouse over stuff...so we can't lock into the current thang.
** DONE-AND-SHARED Get links to work properly on the production site
   CLOSED: [2019-01-22 Tue 13:27]
   - State "DONE-AND-SHARED" from "TODO"       [2019-01-22 Tue 13:27]
   On our dev site, where the site is being served up by the dev server, you can give an external link and it'll find it....like apisnoop.cncf.ci/master.  This means you can throw the exact endpoint and such and it will find it and show it.  This is not hte case on the built site.  IT just throws up a 404.  IT seems like the server mgith be interfering, it is not knowing to go to our index page first and then determine the url from there...which is how it works on the dev site.
  So when i serve it up locally, it works, and all sub-url's work...this is likely due to it being configured to work with react specifivally, and knows to fallback to the index.html.

  This is due to how redirects work on netlify.  We need to add a _redirects file to our public site, that says to take all redirects and send them to index.html no matter what.   More info can be found here: https://www.netlify.com/docs/redirects/
